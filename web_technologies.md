1. Что такое прогрессивный рендеринг?

    Прогрессивный рендеринг - это метод последовательного рендеринга частей веб-страницы на сервере и потоковой передачи ее клиенту по частям, не дожидаясь рендеринга всей страницы.

    До того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.

    Примеры технологий:
    - Ленивая загрузка картинок. Картинки на странице не загружаются все разом. JavaScript подгрузит картинки тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.
    - Приоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события DOMContentLoaded или load, чтобы загрузить остальные ресурсы и контент.
    - Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде. Более подробно про эту технологию можно почитать



2. Разница между адаптивным (adaptive) и отзывчивым (responsive) дизайнами?

   Responsive Design (RWD) — отзывчивый дизайн — проектирование сайта с определенными значениями свойств, например, гибкая сетка макета, которые позволяют одному макету работать на разных устройствах;

   Adaptive Design (AWD) — адаптивный дизайн, или динамический показ — проектирование сайта с условиями, которые изменяются в зависимости от устройства, базируясь на нескольких макетах фиксированной ширины.


3.  Разница между Progressive Enhancement и Graceful Degradation?

    * progressive enhancement - прогрессивное улучшение. Прогрессивное улучшение предполагает, что веб-интерфейсы должны создаваться поэтапно, циклически, от простого к сложному. На каждом из этапов должен получаться законченный веб-интерфейс, который будет лучше, красивее и удобнее предыдущего. Можно сказать, что сейчас таких этапов четыре:

    - «Старый-добрый-HTML» этап
    - CSS этап
    - CSS3 этап
    - JavaScript этап

    На первом этапе исходное содержание страницы размечается с помощью HTML. На этом этапе необходимо сделать логичную и семантически правильную разметку. Никакого дополнительного оформления не осуществляется. В результате получается корректно размеченный HTML-документ, который браузер отображает так, как считает нужным. Такой документ можно назвать «наименьшим общим знаменателем», так как он будет корректно отображаться в любом, даже самом простом, браузере. Прогрессивное улучшение настаивает, что первый этап является самым важным, так как нет в вебе ничего важнее, чем содержание.

    На втором этапе документ оформляется с помощью старого доброго CSS и обретает более аккуратный вид: появляется сетка страницы, задаются параметры шрифта элементов, фоновые изображения и так далее.

    На третьем этапе применяются новые возможности из семейства спецификаций CSS3, и документ доводится до блеска: полупрозрачные плашки, круглые уголки, тени. Также с помощью CSS3 можно добавить различные анимационно-декоративные фишечки: постепенное затухание или смещение элементов, подсвечивание полей форм и так далее.

    На четвёртом этапе до ума доводится процесс взаимодействия с интерфейсом: различные AJAX решения, динамические элементы, те же календарики и так далее. Тут во всю используется JavaScript. Этот этап отвечает за удобство.

    Резюмируем назначение описанных этапов:

    - Смысл документа, логическая разметка. Технология: HTML.
    - Внешний вид. Технология: CSS.
    - Безупречный внешний вид. Технология: CSS3.
    - Взаимодействие, интерактивность, удобство. Технология: JavaScript.



    * Graceful degradation, или «отказоустойчивость» - это более широкое понятие, которое применяется, не только в веб-дизайне. В общем смысле предполагает способность системы работать даже в случае отказа некоторых ее компонентов. И чем серьезнее отказ, тем ниже качество работы системы или работы с системой, но при этом основной функционал системы остается рабочим.

    Graceful degradation может выражаться в возможности работы с отключенным JavaScript, в акуратном отображении сайта в браузере без поддержки спецификации CSS3, в адекватном отображении сайта с отключенными картинками. Все эти отказы не должны влиять на работу веб-приложения. Однако, если все работает, то пользователю гораздо удобнее пользоваться сайтом.

    Если рассмотреть конкретный пример, например в области проектирования веб-интерфеса, то этот принцип можно сформулировать как «система может работать и с полностью отключенным JavaScript, но с включенным с ней будет работать намного удобнее». Вопрос не в том, может ли быть такая ситуация, что JS отключен или не функционирует полностью, или почему это происходит. Эта ситуация берется как данность. Дизайнер должен разработать такой интерфейс, который будет так же продолжать работать, пусть и с отключенным JS.

    Часто для следования этому принципу приходится переделывать логику серверной обработки форм. Однако, такой подход будет окупаться, если задуматься об отказоустойчивости еще на этапе планирования формы.

    Соблюдение принципа graceful degradation позволяет пользователям (а каждый пользователь — это потенциальный клиент) иметь возможность работы с сайтом в любых ситуациях.



4. Что такое кроссбраузерность?

    Кроссбраузерность – это способность веб-ресурса отображаться одинаково хорошо во всех популярных браузерах без перебоев в функционировании и ошибок в верстке, с одинаково корректной читабельностью контента. Это очень важный показатель как для поисковых систем, так и пользовательской аудитории.

    Конечно, нет необходимости добиваться совершенно одинакового отображения визуальной и текстовой информации сайта во всех без исключения версиях браузеров. Достаточно, чтобы ресурс обладал адаптивностью ко всем возможным устройствам просмотра вне зависимости от размеров экрана. Не должно быть проблем с версткой, когда картинки, баннеры, логотипы «наезжают» друг на друга или вовсе не отображаются. Текстовая информация должна быть читабельной, особенно это касается таблиц. Важно, чтобы корректно работали сервисные приложения, вшитые в ресурс.

    Кроссбраузерными считаются сайты, которые хорошо работают на: 

    - Google Chrome и производных обозревателях (Яндекс.Браузера, Chromium, Opera c 15 версии и т.д.); 
    - Microsoft Edge (сейчас он тоже работает на движке Blink, как и Chrome); 
    - Mozilla Firefox;
    - Safari (браузер, который используется на iOS и macOS).


5. Что такое Babel? Для чего он используется?

    Babel — это компилятор, который преобразует ваш современный JavaScript для запуска в старых браузерах. Он также может выполнять и другие задачи, такие как преобразование синтаксиса JSX, но это не единственный инструмент для этого.

    Babel — это JavaScript транспилятор, который очень популярен среди разработчиков из-за того, что он в мгновенье ока превращает код написанный на ES6, или более поздних стандартах, в более поддерживаемый всеми браузерами код. Как правило на выходе мы получаем ES5. 

    Babel – это транспилер. Он переписывает современный JavaScript-код в предыдущий стандарт.

    На самом деле, есть две части Babel:
    - Во-первых, транспилер, который переписывает код. Разработчик запускает Babel на своём компьютере. Он переписывает код в старый стандарт. И после этого код отправляется на сайт. Современные сборщики проектов, такие как webpack или brunch, предоставляют возможность запускать транспилер автоматически после каждого изменения кода, что позволяет экономить время.

    - Во-вторых, полифил.
    Новые возможности языка могут включать встроенные функции и синтаксические конструкции. Транспилер переписывает код, преобразовывая новые синтаксические конструкции в старые. Но что касается новых встроенных функций, нам нужно их как-то реализовать. JavaScript является высокодинамичным языком, скрипты могут добавлять/изменять любые функции, чтобы они вели себя в соответствии с современным стандартом.

    Термин «полифил» означает, что скрипт «заполняет» пробелы и добавляет современные функции.
    Два интересных хранилища полифилов:
    core js поддерживает много функций, можно подключать только нужные.
    polyfill.io – сервис, который автоматически создаёт скрипт с полифилом в зависимости от необходимых функций и браузера пользователя.


6.   В чём разница между feature detection (определение возможностей), feature inference (предположение возможностей) и анализом строки user-agent?

    Feature detection (определение возможностей)

    Определение возможностей браузера заключается в определении, поддерживает ли браузер определенный блок кода — и если нет, то будет выполняться другой код, так что браузер всегда сможет обеспечить работоспособность и предотвратить сбои/ошибки в некоторых браузерах. Например:


            if ('geolocation' in navigator) {
            // Можно использовать navigator.geolocation
            } else {
            // Обработка отсутствия возможности
            }


    Feature inference (предположение возможностей)

    Предположение возможностей проверяет на наличие определённых возможностей, как и предыдущий подход, но использует другую функцию, которая предполагает, что определённая возможность уже существует, например:

            if (document.getElementsByTagName) {
            element = document.getElementById(id);
            }

    Этот подход не рекомендуеся. Первый подход более надёжен.

    
    Строка User Agent

    Это строка, сообщаемая браузером, которая позволяет узлам сетевого протокола определить тип приложения, операционную систему, поставщика программного обеспечения или версию программного обеспечения пользователя, от которого исходит запрос. Доступ к ней можно получить через navigator.userAgent. Тем не менее строка User Agent сложна для обработки и может быть подделана. Например, браузер Chrome идентифицируется как Chrome и как Safari, нужно проверить на наличие строки Safari и отсутствие строки Chrome. Следует избегать этот метод.


7.  Что такое Веб-компоненты и какие технологии в них используются?

    Веб-компоненты - это набор различных технологий, позволяющих создавать повторно используемые настраиваемые элементы с их функциональностью, инкапсулированной отдельно от остальной части вашего кода - и использовать их в ваших веб-приложениях.

    Веб-компоненты направлены на решение таких проблем - они состоят из трёх основных технологий, которые можно использовать вместе для создания универсальных настраиваемых элементов с инкапсулированной функциональностью, которые можно повторно использовать где угодно, не опасаясь коллизий кода.

    - Пользовательские элементы: набор API-интерфейсов JavaScript, позволяющих определять пользовательские элементы и их поведение, которые затем можно использовать по желанию в пользовательском интерфейсе.
    - Shadow DOM: набор API-интерфейсов JavaScript для прикрепления инкапсулированного «теневого» дерева DOM к элементу, который отображается отдельно от DOM основного документа, и управления соответствующими функциями. Таким образом, вы можете сохранить функции элемента в секрете, поэтому для них можно создавать сценарии и стили, не опасаясь коллизий с другими частями документа.
    - HTML templates: элементы <template> и <slot> позволяют создавать шаблоны разметки, которых не видно на отображаемой странице. Затем их можно многократно использовать в качестве основы структуры настраиваемого элемента.

    Базовый подход к реализации веб-компонента обычно выглядит примерно так:

    - Создайте класс, в котором вы указываете функциональность своего веб-компонента, используя синтаксис классов ECMAScript 2015 (дополнительную информацию см. в разделе Классы).
    - Зарегистрируйте свой новый настраиваемый элемент с помощью метода CustomElementRegistry.define() (en-US), передав ему имя элемента, который будет определён, класс или функцию, в которых указана его функциональность, и, необязательно, от какого элемента он наследуется.
    - При необходимости прикрепите теневую DOM к настраиваемому элементу с помощью метода Element.attachShadow(). Добавьте дочерние элементы, обработчики событий и т.д. в теневой DOM, используя обычные методы DOM.
    - При необходимости определите HTML template, используя <template> и <slot>. Снова используйте обычные методы DOM, чтобы клонировать шаблон и прикрепить его к вашей теневой DOM.
    - Используйте свой настраиваемый элемент везде, где хотите, на своей странице, как и любой обычный элемент HTML.


8. Способы уменьшения времени загрузки веб-страницы?
 
    - уменьшить размер HTML
    - использовать сжатие gzip или brotli
    - использовать минификацию, то есть сократить HTML, CSS и JS
    - использовать кэш браузера для ускорения
    - сжать фотографии, иллюстрации и другую графику: подобрать разрешение, уменьшить количество цветов, прописать параметры в CSS и сжать сами файлы


    * CSS файлы в хедере
    Подключите css файлы в верхней части страницы. Так вы получите постепенный редеринг, поскольку страницы будут грузиться постепенно: вначале заголовок, затем логотип с навигацией и т.д. Все это служит индикатором загрузки для клиента и улучшит впечатление от сайта. Если же поместить css файлы в «подвале», браузеры начнут капризничать. Им нужно заново формировать элементы, которые сменили стиль после загрузки. Делать это проблематично. Поэтому css элементы нужно подключить в верхней части, секции head.

    * Javascript в конце страницы
    Позвольте браузеру вначале загрузить страницу с контентом, а уже потом javascript-файлы. Для этого поместите эти файлы вниз страницы. Но здесь важно не перестараться. Например, ваш сайт содержит множество интерактивных «примочек», из-за чего некоторые файлы весят под сотни килобайт. Губительно оставлять пользователя в ожидании, пока все ваши файлы прогрузятся. Помимо этого, параллельная загрузка блокируется внешними js-файлами. Как ускорить загрузку сайта в этом случае? В данных HTTP/1.1 есть указание, что браузеры должны параллельно выгружать с одного хоста максимум 2 компонента страницы. Получается, если картинки для сайта расположены на разных хостах, вы обеспечиваете более 2 параллельных загрузок. Браузер не начнет других загрузок, когда загружается скрипт.


    * Сокращение числа HTTP-запросов
    80% загрузки связано с загрузкой компонентов: изображений, скриптов, flash, CSS и т.д. Снова вспомним о HTTP/1.1: браузеры должны параллельно выгружать максимум 2 компонента страницы с единственного хоста. Сократив число компонентов, мы уменьшаем число HTTP-запросов к серверу. Но как ускорить работу сайта, не трогая его внешний вид? Тут есть несколько способов:
    - Скомпоновать нескольких файлов в один. Если на странице подключается больше одного js- или css- файла, попробуйте объединить их в один.
    - Использование CSS-спрайтов. Это комбинированное изображение, содержащее несколько маленьких изображений.
    - Использование Inline-картинок. Картинка встраивается в саму страницу по URL-схеме data. Но это увеличит HTML-размер документа.
    * Сокращение css и javascript
    Удалите из кода все несущественные файлы с целью сокращения его объема. В сокращенном файле нет комментариев, незначащих пробелов, символов табуляции и переносов строк. Чем меньше файл весит – тем меньше времени требуется браузеру на его загрузку. Для сокращения кода существует много разных программ.

    * Использование кэша браузера
    Как увеличить скорость загрузки сайта с помощью кэша браузера? Нужно правильно выставить HTTP-заголовок Expires в файл .htaccess, что находится в корневой папке сайта. Когда пользователь впервые зайдет на ваш сайт, браузер загрузит все css и javascript файлы. Так элементы страницы станут кэшируемыми. При повторном посещении сайта в кэше браузера уже будут все нужные элементы, и сайт откроется быстрее.

    * Использование поддоменов для параллельного скачивания
    Если на интернет-сайте много графики, ее стоит вынести в отдельный поддомен (вспоминаем спецификацию HTTP/1.1). Браузер сочтет это за наличие нескольких серверов. Как ускорить загрузку страниц в несколько раз? Алгоритм тут простой: чем больше вы сформируете поддоменов, тем больше файлов браузер выгрузит одновременно. Ваша задача при этом – изменить адрес изображений на новый.

    * Оптимизация изображений
    Определите подходящий формат для картинок.Выбор неверного формата существенно повысит размер файла. Вы можете выбрать:

    GIF. Подойдет для картинок с небольшим количеством цветов.
    JPEG. Подойдет для ярких детализированных картинок.
    PNG. Выбирайте этот формат, если нужно высококачественное изображение с прозрачностью.
    Оптимизировать картинку можно с помощью специальной программы:Punypng и Jpegmini


    * Загрузка javascript библиотек с помощью CDN
    CDN – это множество веб-серверов, специальным образом расположенных вдали друг от друга для достижения наибольшей скорости загрузки контента. Если на сайте есть крупный javascript фреймворк, то используйте CDN для его подключения. Это простой, но действенный способ решить вопрос о том, как сделать быструю загрузку сайта.

    * Использование Gzip-сжатия
    Если держать архивированные копии файлов на сервере, то получится обеспечить соединение в 3-4 раза быстрее. Gzip-сжатие – отличный «ускоритель» сайта. Сжатие текстовых файлов «на лету» в подавляющем большинстве случаев сокращает время на передачу файла браузеру. Начиная с версии протокола HTTP/1.1, веб-клиенты указывают, какие поддерживаются типы сжатия.

    * Отказ от масштабирования изображений
    Не меняйте размер картинок при помощи CSS или атрибутов width и height тега. Это негативно сказывается на загрузке страницы. Если вы задаетесь вопросом, как уменьшить размер сайта, используйте при изменении картинки графический редактор Photoshop. При этом чем меньше вес изображения, тем меньше времени потребуется для ее загрузки.
        

9. Особенности разработки мультиязычных сайтов?
    

    - В зависимости от страны, важно указывать дату в правильной последовательности. Для кого-то «04.05.11» может значить «5 апреля 2011 года», а для кого-то - «4 мая 2011 года». В некоторых странах это вовсе будет читаться как «2004 год, 4 мая».

    - Знак доллара или евро в СНГ ставят после цифры (50$), а в США и Европе – перед $50.

    - В разных регионах важно менять величины измерения: Цельсия на Фаренгейт. С расстоянием и длиной такая же ситуация.

    - При публикации контента обращайте внимание на то, что существуют культурные различия в юморе и отсылках для каждой страны. Здесь необходимо делать максимально универсальный контент или стараться все адаптировать. Пример: отсылки на какие-либо русские мультфильмы поймет только человек из СНГ. Можно поискать аналоги этих мультиков или если речь идет о шутках, заменить их другими. В крайнем случае стоит просто вырезать неадаптируемую часть контента под другой регион.  

    - Также важна адаптация изображений. К примеру, в Китае негативно относятся к контенту со скелетами. Если изображение включает подобные материалы, то лучше его заменить. Это лишь один из примеров.

    - Страницы каждого языка нужно проверять на верстку. Из-за перевода предложения меняют свой объем и от этого картинки или структура текста может «съехать».

    - Рекламную кампанию для каждой страны лучше вести отдельно, ведь поведенческие паттерны могут отличаться. Сначала проверьте свои предположения на небольшом бюджете, а потом – запускайте полную кампанию. Даже в рамках одного языка, но разных стран или регионов могут существовать отличающиеся предпочтения.

    - Тщательно проработайте условия доставки для каждого региона, чтобы не попасть в неприятную ситуацию и не нанести урон своей репутации.

    - Важно указать телефоны службы поддержки, которые будут доступны для каждой страны одного языка. Например, для русскоязычного сайта стоит сделать отдельные телефоны поддержки для России, Беларуси, Украины, Казахстана и т.д. Если у вас нет такой возможности, то лучше использовать только чат поддержки, но делать это качественно. Например, для этих целей во все шаблоны Ucraft уже интегрирован сервис Intercom, который не позволяет потерять ни одной переписки. 


10. Что такое FOUC (Flash Of Unstyled Content)? Как его избежать?
    FOUC (Flash Of Unstyled Content) - это появление неоформленного контента при загрузке.

    Избежать его можно путём вставки критичного CSS в тег <head>. Критичный CSS — это минимальный набор блокирующего CSS, требуемого для рендеринга первого экрана с контентом пользователю.   


11. Объясните разницу между раскладкой (layout), painting и композитингом (compositing).

    Layout: расчёт места для объекта на основе правил.
    Paint: рисовка пикселей для отображения визуальных элементов.
    Compositing: рисовка слоёв в правильном порядке (правильное наложение и т.д.).     

12. Progressive Web Application. 
    Это технология, которая позволяет взаимодействовать с сайтами на мобильных устройствах, как с приложением.    


13. Что такое межсайтовый скриптинг (XSS)?

    XSS (Cross-Site Scripting - Межсайтовый скриптинг) это термин, используемый для описания типа атак, которые позволяют злоумышленнику внедрять вредоносный код через веб-сайт в браузеры других пользователей. Поскольку внедрённый код поступает в браузер с сайта, он является доверенным и может выполнять такие действия, как отправка авторизационного файла cookie пользователя злоумышленнику. Когда у злоумышленника есть файл cookie, он может войти на сайт, как если бы он был пользователем, и сделать все, что может пользователь, например, получить доступ к данным кредитной карты, просмотреть контактные данные или изменить пароли.    


14. API (Application Programming Interface или интерфейс программирования приложений) — это совокупность инструментов и функций в виде интерфейса для создания новых приложений, благодаря которому одна программа будет взаимодействовать с другой. Это позволяет разработчикам расширять функциональность своего продукта и связывать его с другими. Большинство крупных компаний разрабатывают API для клиентов или для внутреннего использования.
    API включает в себя:

    - саму операцию, которую мы можем выполнить,
    - данные, которые поступают на вход,
    - данные, которые оказываются на выходе (контент данных или сообщение об ошибке).

    Вызвать API можно как напрямую, так и косвенно:
    - Система вызывает функции внутри себя
    - Система вызывает метод другой системы
    - Человек вызывает метод
    - Автотесты дергают методы
    - Пользователь работает с GUI