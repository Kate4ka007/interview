1. Что такое прогрессивный рендеринг?

    Прогрессивный рендеринг - это метод последовательного рендеринга частей веб-страницы на сервере и потоковой передачи ее клиенту по частям, не дожидаясь рендеринга всей страницы.

    До того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.

    Примеры технологий:
    - Ленивая загрузка картинок. Картинки на странице не загружаются все разом. JavaScript подгрузит картинки тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.
    - Приоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события DOMContentLoaded или load, чтобы загрузить остальные ресурсы и контент.
    - Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде. Более подробно про эту технологию можно почитать



2. Разница между адаптивным (adaptive) и отзывчивым (responsive) дизайнами?

   Responsive Design (RWD) — отзывчивый дизайн — проектирование сайта с определенными значениями свойств, например, гибкая сетка макета, которые позволяют одному макету работать на разных устройствах;

   Adaptive Design (AWD) — адаптивный дизайн, или динамический показ — проектирование сайта с условиями, которые изменяются в зависимости от устройства, базируясь на нескольких макетах фиксированной ширины.


3.  Разница между Progressive Enhancement и Graceful Degradation?

    * progressive enhancement - прогрессивное улучшение. Прогрессивное улучшение предполагает, что веб-интерфейсы должны создаваться поэтапно, циклически, от простого к сложному. На каждом из этапов должен получаться законченный веб-интерфейс, который будет лучше, красивее и удобнее предыдущего. Можно сказать, что сейчас таких этапов четыре:

    - «Старый-добрый-HTML» этап
    - CSS этап
    - CSS3 этап
    - JavaScript этап

    На первом этапе исходное содержание страницы размечается с помощью HTML. На этом этапе необходимо сделать логичную и семантически правильную разметку. Никакого дополнительного оформления не осуществляется. В результате получается корректно размеченный HTML-документ, который браузер отображает так, как считает нужным. Такой документ можно назвать «наименьшим общим знаменателем», так как он будет корректно отображаться в любом, даже самом простом, браузере. Прогрессивное улучшение настаивает, что первый этап является самым важным, так как нет в вебе ничего важнее, чем содержание.

    На втором этапе документ оформляется с помощью старого доброго CSS и обретает более аккуратный вид: появляется сетка страницы, задаются параметры шрифта элементов, фоновые изображения и так далее.

    На третьем этапе применяются новые возможности из семейства спецификаций CSS3, и документ доводится до блеска: полупрозрачные плашки, круглые уголки, тени. Также с помощью CSS3 можно добавить различные анимационно-декоративные фишечки: постепенное затухание или смещение элементов, подсвечивание полей форм и так далее.

    На четвёртом этапе до ума доводится процесс взаимодействия с интерфейсом: различные AJAX решения, динамические элементы, те же календарики и так далее. Тут во всю используется JavaScript. Этот этап отвечает за удобство.

    Резюмируем назначение описанных этапов:

    - Смысл документа, логическая разметка. Технология: HTML.
    - Внешний вид. Технология: CSS.
    - Безупречный внешний вид. Технология: CSS3.
    - Взаимодействие, интерактивность, удобство. Технология: JavaScript.



    * Graceful degradation, или «отказоустойчивость» - это более широкое понятие, которое применяется, не только в веб-дизайне. В общем смысле предполагает способность системы работать даже в случае отказа некоторых ее компонентов. И чем серьезнее отказ, тем ниже качество работы системы или работы с системой, но при этом основной функционал системы остается рабочим.

    Graceful degradation может выражаться в возможности работы с отключенным JavaScript, в акуратном отображении сайта в браузере без поддержки спецификации CSS3, в адекватном отображении сайта с отключенными картинками. Все эти отказы не должны влиять на работу веб-приложения. Однако, если все работает, то пользователю гораздо удобнее пользоваться сайтом.

    Если рассмотреть конкретный пример, например в области проектирования веб-интерфеса, то этот принцип можно сформулировать как «система может работать и с полностью отключенным JavaScript, но с включенным с ней будет работать намного удобнее». Вопрос не в том, может ли быть такая ситуация, что JS отключен или не функционирует полностью, или почему это происходит. Эта ситуация берется как данность. Дизайнер должен разработать такой интерфейс, который будет так же продолжать работать, пусть и с отключенным JS.

    Часто для следования этому принципу приходится переделывать логику серверной обработки форм. Однако, такой подход будет окупаться, если задуматься об отказоустойчивости еще на этапе планирования формы.

    Соблюдение принципа graceful degradation позволяет пользователям (а каждый пользователь — это потенциальный клиент) иметь возможность работы с сайтом в любых ситуациях.



4. Что такое кроссбраузерность?

    Кроссбраузерность – это способность веб-ресурса отображаться одинаково хорошо во всех популярных браузерах без перебоев в функционировании и ошибок в верстке, с одинаково корректной читабельностью контента. Это очень важный показатель как для поисковых систем, так и пользовательской аудитории.

    Конечно, нет необходимости добиваться совершенно одинакового отображения визуальной и текстовой информации сайта во всех без исключения версиях браузеров. Достаточно, чтобы ресурс обладал адаптивностью ко всем возможным устройствам просмотра вне зависимости от размеров экрана. Не должно быть проблем с версткой, когда картинки, баннеры, логотипы «наезжают» друг на друга или вовсе не отображаются. Текстовая информация должна быть читабельной, особенно это касается таблиц. Важно, чтобы корректно работали сервисные приложения, вшитые в ресурс.

    Кроссбраузерными считаются сайты, которые хорошо работают на: 

    - Google Chrome и производных обозревателях (Яндекс.Браузера, Chromium, Opera c 15 версии и т.д.); 
    - Microsoft Edge (сейчас он тоже работает на движке Blink, как и Chrome); 
    - Mozilla Firefox;
    - Safari (браузер, который используется на iOS и macOS).


5. Что такое Babel? Для чего он используется?

    Babel — это компилятор, который преобразует ваш современный JavaScript для запуска в старых браузерах. Он также может выполнять и другие задачи, такие как преобразование синтаксиса JSX, но это не единственный инструмент для этого.

    Babel — это JavaScript транспилятор, который очень популярен среди разработчиков из-за того, что он в мгновенье ока превращает код написанный на ES6, или более поздних стандартах, в более поддерживаемый всеми браузерами код. Как правило на выходе мы получаем ES5. 

    Babel – это транспилер. Он переписывает современный JavaScript-код в предыдущий стандарт.

    На самом деле, есть две части Babel:
    - Во-первых, транспилер, который переписывает код. Разработчик запускает Babel на своём компьютере. Он переписывает код в старый стандарт. И после этого код отправляется на сайт. Современные сборщики проектов, такие как webpack или brunch, предоставляют возможность запускать транспилер автоматически после каждого изменения кода, что позволяет экономить время.

    - Во-вторых, полифил.
    Новые возможности языка могут включать встроенные функции и синтаксические конструкции. Транспилер переписывает код, преобразовывая новые синтаксические конструкции в старые. Но что касается новых встроенных функций, нам нужно их как-то реализовать. JavaScript является высокодинамичным языком, скрипты могут добавлять/изменять любые функции, чтобы они вели себя в соответствии с современным стандартом.

    Термин «полифил» означает, что скрипт «заполняет» пробелы и добавляет современные функции.
    Два интересных хранилища полифилов:
    core js поддерживает много функций, можно подключать только нужные.
    polyfill.io – сервис, который автоматически создаёт скрипт с полифилом в зависимости от необходимых функций и браузера пользователя.


6.   В чём разница между feature detection (определение возможностей), feature inference (предположение возможностей) и анализом строки user-agent?

    Feature detection (определение возможностей)

    Определение возможностей браузера заключается в определении, поддерживает ли браузер определенный блок кода — и если нет, то будет выполняться другой код, так что браузер всегда сможет обеспечить работоспособность и предотвратить сбои/ошибки в некоторых браузерах. Например:


            if ('geolocation' in navigator) {
            // Можно использовать navigator.geolocation
            } else {
            // Обработка отсутствия возможности
            }


    Feature inference (предположение возможностей)

    Предположение возможностей проверяет на наличие определённых возможностей, как и предыдущий подход, но использует другую функцию, которая предполагает, что определённая возможность уже существует, например:

            if (document.getElementsByTagName) {
            element = document.getElementById(id);
            }

    Этот подход не рекомендуеся. Первый подход более надёжен.

    
    Строка User Agent

    Это строка, сообщаемая браузером, которая позволяет узлам сетевого протокола определить тип приложения, операционную систему, поставщика программного обеспечения или версию программного обеспечения пользователя, от которого исходит запрос. Доступ к ней можно получить через navigator.userAgent. Тем не менее строка User Agent сложна для обработки и может быть подделана. Например, браузер Chrome идентифицируется как Chrome и как Safari, нужно проверить на наличие строки Safari и отсутствие строки Chrome. Следует избегать этот метод.


7.  Что такое Веб-компоненты и какие технологии в них используются?

    Веб-компоненты - это набор различных технологий, позволяющих создавать повторно используемые настраиваемые элементы с их функциональностью, инкапсулированной отдельно от остальной части вашего кода - и использовать их в ваших веб-приложениях.

    Веб-компоненты направлены на решение таких проблем - они состоят из трёх основных технологий, которые можно использовать вместе для создания универсальных настраиваемых элементов с инкапсулированной функциональностью, которые можно повторно использовать где угодно, не опасаясь коллизий кода.

    - Пользовательские элементы: набор API-интерфейсов JavaScript, позволяющих определять пользовательские элементы и их поведение, которые затем можно использовать по желанию в пользовательском интерфейсе.
    - Shadow DOM: набор API-интерфейсов JavaScript для прикрепления инкапсулированного «теневого» дерева DOM к элементу, который отображается отдельно от DOM основного документа, и управления соответствующими функциями. Таким образом, вы можете сохранить функции элемента в секрете, поэтому для них можно создавать сценарии и стили, не опасаясь коллизий с другими частями документа.
    - HTML templates: элементы <template> и <slot> позволяют создавать шаблоны разметки, которых не видно на отображаемой странице. Затем их можно многократно использовать в качестве основы структуры настраиваемого элемента.

    Базовый подход к реализации веб-компонента обычно выглядит примерно так:

    - Создайте класс, в котором вы указываете функциональность своего веб-компонента, используя синтаксис классов ECMAScript 2015 (дополнительную информацию см. в разделе Классы).
    - Зарегистрируйте свой новый настраиваемый элемент с помощью метода CustomElementRegistry.define() (en-US), передав ему имя элемента, который будет определён, класс или функцию, в которых указана его функциональность, и, необязательно, от какого элемента он наследуется.
    - При необходимости прикрепите теневую DOM к настраиваемому элементу с помощью метода Element.attachShadow(). Добавьте дочерние элементы, обработчики событий и т.д. в теневой DOM, используя обычные методы DOM.
    - При необходимости определите HTML template, используя <template> и <slot>. Снова используйте обычные методы DOM, чтобы клонировать шаблон и прикрепить его к вашей теневой DOM.
    - Используйте свой настраиваемый элемент везде, где хотите, на своей странице, как и любой обычный элемент HTML.


8. Способы уменьшения времени загрузки веб-страницы?
 
    - уменьшить размер HTML
    - использовать сжатие gzip или brotli
    - использовать минификацию, то есть сократить HTML, CSS и JS
    - использовать кэш браузера для ускорения
    - сжать фотографии, иллюстрации и другую графику: подобрать разрешение, уменьшить количество цветов, прописать параметры в CSS и сжать сами файлы


    * CSS файлы в хедере
    Подключите css файлы в верхней части страницы. Так вы получите постепенный редеринг, поскольку страницы будут грузиться постепенно: вначале заголовок, затем логотип с навигацией и т.д. Все это служит индикатором загрузки для клиента и улучшит впечатление от сайта. Если же поместить css файлы в «подвале», браузеры начнут капризничать. Им нужно заново формировать элементы, которые сменили стиль после загрузки. Делать это проблематично. Поэтому css элементы нужно подключить в верхней части, секции head.

    * Javascript в конце страницы
    Позвольте браузеру вначале загрузить страницу с контентом, а уже потом javascript-файлы. Для этого поместите эти файлы вниз страницы. Но здесь важно не перестараться. Например, ваш сайт содержит множество интерактивных «примочек», из-за чего некоторые файлы весят под сотни килобайт. Губительно оставлять пользователя в ожидании, пока все ваши файлы прогрузятся. Помимо этого, параллельная загрузка блокируется внешними js-файлами. Как ускорить загрузку сайта в этом случае? В данных HTTP/1.1 есть указание, что браузеры должны параллельно выгружать с одного хоста максимум 2 компонента страницы. Получается, если картинки для сайта расположены на разных хостах, вы обеспечиваете более 2 параллельных загрузок. Браузер не начнет других загрузок, когда загружается скрипт.


    * Сокращение числа HTTP-запросов
    80% загрузки связано с загрузкой компонентов: изображений, скриптов, flash, CSS и т.д. Снова вспомним о HTTP/1.1: браузеры должны параллельно выгружать максимум 2 компонента страницы с единственного хоста. Сократив число компонентов, мы уменьшаем число HTTP-запросов к серверу. Но как ускорить работу сайта, не трогая его внешний вид? Тут есть несколько способов:
    - Скомпоновать нескольких файлов в один. Если на странице подключается больше одного js- или css- файла, попробуйте объединить их в один.
    - Использование CSS-спрайтов. Это комбинированное изображение, содержащее несколько маленьких изображений.
    - Использование Inline-картинок. Картинка встраивается в саму страницу по URL-схеме data. Но это увеличит HTML-размер документа.
    * Сокращение css и javascript
    Удалите из кода все несущественные файлы с целью сокращения его объема. В сокращенном файле нет комментариев, незначащих пробелов, символов табуляции и переносов строк. Чем меньше файл весит – тем меньше времени требуется браузеру на его загрузку. Для сокращения кода существует много разных программ.

    * Использование кэша браузера
    Как увеличить скорость загрузки сайта с помощью кэша браузера? Нужно правильно выставить HTTP-заголовок Expires в файл .htaccess, что находится в корневой папке сайта. Когда пользователь впервые зайдет на ваш сайт, браузер загрузит все css и javascript файлы. Так элементы страницы станут кэшируемыми. При повторном посещении сайта в кэше браузера уже будут все нужные элементы, и сайт откроется быстрее.

    * Использование поддоменов для параллельного скачивания
    Если на интернет-сайте много графики, ее стоит вынести в отдельный поддомен (вспоминаем спецификацию HTTP/1.1). Браузер сочтет это за наличие нескольких серверов. Как ускорить загрузку страниц в несколько раз? Алгоритм тут простой: чем больше вы сформируете поддоменов, тем больше файлов браузер выгрузит одновременно. Ваша задача при этом – изменить адрес изображений на новый.

    * Оптимизация изображений
    Определите подходящий формат для картинок.Выбор неверного формата существенно повысит размер файла. Вы можете выбрать:

    GIF. Подойдет для картинок с небольшим количеством цветов.
    JPEG. Подойдет для ярких детализированных картинок.
    PNG. Выбирайте этот формат, если нужно высококачественное изображение с прозрачностью.
    Оптимизировать картинку можно с помощью специальной программы:Punypng и Jpegmini


    * Загрузка javascript библиотек с помощью CDN
    CDN – это множество веб-серверов, специальным образом расположенных вдали друг от друга для достижения наибольшей скорости загрузки контента. Если на сайте есть крупный javascript фреймворк, то используйте CDN для его подключения. Это простой, но действенный способ решить вопрос о том, как сделать быструю загрузку сайта.

    * Использование Gzip-сжатия
    Если держать архивированные копии файлов на сервере, то получится обеспечить соединение в 3-4 раза быстрее. Gzip-сжатие – отличный «ускоритель» сайта. Сжатие текстовых файлов «на лету» в подавляющем большинстве случаев сокращает время на передачу файла браузеру. Начиная с версии протокола HTTP/1.1, веб-клиенты указывают, какие поддерживаются типы сжатия.

    * Отказ от масштабирования изображений
    Не меняйте размер картинок при помощи CSS или атрибутов width и height тега. Это негативно сказывается на загрузке страницы. Если вы задаетесь вопросом, как уменьшить размер сайта, используйте при изменении картинки графический редактор Photoshop. При этом чем меньше вес изображения, тем меньше времени потребуется для ее загрузки.
        

9. Особенности разработки мультиязычных сайтов?
    

    - В зависимости от страны, важно указывать дату в правильной последовательности. Для кого-то «04.05.11» может значить «5 апреля 2011 года», а для кого-то - «4 мая 2011 года». В некоторых странах это вовсе будет читаться как «2004 год, 4 мая».

    - Знак доллара или евро в СНГ ставят после цифры (50$), а в США и Европе – перед $50.

    - В разных регионах важно менять величины измерения: Цельсия на Фаренгейт. С расстоянием и длиной такая же ситуация.

    - При публикации контента обращайте внимание на то, что существуют культурные различия в юморе и отсылках для каждой страны. Здесь необходимо делать максимально универсальный контент или стараться все адаптировать. Пример: отсылки на какие-либо русские мультфильмы поймет только человек из СНГ. Можно поискать аналоги этих мультиков или если речь идет о шутках, заменить их другими. В крайнем случае стоит просто вырезать неадаптируемую часть контента под другой регион.  

    - Также важна адаптация изображений. К примеру, в Китае негативно относятся к контенту со скелетами. Если изображение включает подобные материалы, то лучше его заменить. Это лишь один из примеров.

    - Страницы каждого языка нужно проверять на верстку. Из-за перевода предложения меняют свой объем и от этого картинки или структура текста может «съехать».

    - Рекламную кампанию для каждой страны лучше вести отдельно, ведь поведенческие паттерны могут отличаться. Сначала проверьте свои предположения на небольшом бюджете, а потом – запускайте полную кампанию. Даже в рамках одного языка, но разных стран или регионов могут существовать отличающиеся предпочтения.

    - Тщательно проработайте условия доставки для каждого региона, чтобы не попасть в неприятную ситуацию и не нанести урон своей репутации.

    - Важно указать телефоны службы поддержки, которые будут доступны для каждой страны одного языка. Например, для русскоязычного сайта стоит сделать отдельные телефоны поддержки для России, Беларуси, Украины, Казахстана и т.д. Если у вас нет такой возможности, то лучше использовать только чат поддержки, но делать это качественно. Например, для этих целей во все шаблоны Ucraft уже интегрирован сервис Intercom, который не позволяет потерять ни одной переписки. 


10. Что такое FOUC (Flash Of Unstyled Content)? Как его избежать?
    FOUC (Flash Of Unstyled Content) - это появление неоформленного контента при загрузке.

    Избежать его можно путём вставки критичного CSS в тег ```<head>```. Критичный CSS — это минимальный набор блокирующего CSS, требуемого для рендеринга первого экрана с контентом пользователю.   


11. Объясните разницу между раскладкой (layout), painting и композитингом (compositing).

    Layout: расчёт места для объекта на основе правил.
    Paint: рисовка пикселей для отображения визуальных элементов.
    Compositing: рисовка слоёв в правильном порядке (правильное наложение и т.д.).     

12. Progressive Web Application. 
    Это технология, которая позволяет взаимодействовать с сайтами на мобильных устройствах, как с приложением.    


13. Что такое межсайтовый скриптинг (XSS)?

    XSS (Cross-Site Scripting - Межсайтовый скриптинг) это термин, используемый для описания типа атак, которые позволяют злоумышленнику внедрять вредоносный код через веб-сайт в браузеры других пользователей. Поскольку внедрённый код поступает в браузер с сайта, он является доверенным и может выполнять такие действия, как отправка авторизационного файла cookie пользователя злоумышленнику. Когда у злоумышленника есть файл cookie, он может войти на сайт, как если бы он был пользователем, и сделать все, что может пользователь, например, получить доступ к данным кредитной карты, просмотреть контактные данные или изменить пароли.    


14. API (Application Programming Interface или интерфейс программирования приложений) — это совокупность инструментов и функций в виде интерфейса для создания новых приложений, благодаря которому одна программа будет взаимодействовать с другой. Это позволяет разработчикам расширять функциональность своего продукта и связывать его с другими. Большинство крупных компаний разрабатывают API для клиентов или для внутреннего использования.
    API включает в себя:

    - саму операцию, которую мы можем выполнить,
    - данные, которые поступают на вход,
    - данные, которые оказываются на выходе (контент данных или сообщение об ошибке).

    Вызвать API можно как напрямую, так и косвенно:
    - Система вызывает функции внутри себя
    - Система вызывает метод другой системы
    - Человек вызывает метод
    - Автотесты дергают методы
    - Пользователь работает с GUI


15. Что такое CDN?

    CDN (Content Delivery Network - сеть доставки контента) - это группа серверов, расположенных во многих местах. Эти сервера хранят дубликаты данных, чтобы сервера могли выполнять запросы данных на основе того, какие сервера ближе всего к конечным пользователям.

    Чаще всего CDN используется для уменьшения времени отклика кэшированного контента, что, как мы уже упоминали выше, уменьшает отток посетителей из-за медленной загрузки ресурса и тем самым сокращает возможные финансовые потери. Также CDN помогает снизить риск потери доступа к контенту из-за падения основного сервера. Контент будет доступен всё время, пока вы восстанавливаете работоспособность основного сервера.

    Использование CDN существенно снижает нагрузку на основной сервер, что помогает решить проблему пиковых нагрузок. Современная CDN способна переживать очень большие нагрузки.


16.  Что такое REST?

     Representational State Transfer — это архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Архитектурный стиль – это набор согласованных ограничений и принципов проектирования, позволяющий добиться определённых свойств системы.

    назначение REST в том, чтобы придать проектируемой системе такие свойства как:

    - Производительность,

    - Масштабируемость,

    - Гибкость к изменениям,

    - Отказоустойчивость,

    - Простота поддержки.


    6 принципов REST:

        * Клиент-серверная архитектура

        * Stateless

        * Кэширование

        * Единообразие интерфейса

        * Layered system

        * Code on demand

   
    Принцип 1. Клиент-серверная архитектура
        Сама концепция клиент-серверной архитектуры заключается в разделении некоторых зон ответственности: в разделении функций клиента и сервера. Что это означает?

        Например, мы разделяем нашу систему так, что клиент (допустим, это мобильное приложение) реализует только функциональное взаимодействие с сервером. При этом сервер реализует в себе логику хранения данных, сложные взаимодействия со смежными системами и т.д.

        Тем не менее, в случае с REST мы говорим о том, что разделяем ответственность. Например, отображение информации, её обработку и хранение.

        Клиент-серверная архитектура
        Также сервер может иметь базу данных (см. рисунок ниже). В данном случае надо понимать, что пара «сервер и БД» тоже будет парой «клиент-сервер». Только в данном случае сервером будет БД, а сам сервер — клиентом.

        Что дает клиент-серверная архитектура и зачем она нужна?

        Во-первых, клиент-серверная архитектура дает нам определённую масштабируемость: есть сервер, есть единая точка обработки запросов. При необходимости выдерживать большую нагрузку мы можем поставить несколько серверов. Также к нему можно подключать достаточно большое количество клиентов (сколько сможет выдержать). Таким образом, клиент-серверная архитектура позволяет добиться масштабируемости.

        Во-вторых, REST даёт определённую простоту поддержки. Если мы хотим изменить логику обработки информации на сервере, то выполним эти изменения на сервере. В данном случае мы можем и не менять каждого клиента, как если бы они были абсолютно равноценной сетью.

        Конечно, есть и минусы. В случае с клиент-серверной архитектурой мы понимаем, что у нас есть единая точка отказа в виде сервера. Если отказал сервер и у нас нет дополнительных инстансов, то для нас это будет означать неработоспособность системы.

        Также потенциально может увеличиться нагрузка, поскольку часть логики мы вынесли с клиента на сервер. Клиент будет совершать меньше каких-либо действий самостоятельно, соответственно, у нас возрастёт количество запросов между клиентом и сервером.


    Принцип 2. Stateless
        Принцип заключается в том, что сервер не должен хранить у себя информацию о сессии с клиентом. Он должен в каждом запросе получать всю информацию для обработки.

        Вернёмся к Statless-подходу. Почему в REST-архитектуре мы должны использовать именно Statless-подход?

        Какие он даёт плюсы?

        Масштабируемость сервера,

        Уменьшение времени обработки запроса,

        Простота поддержки,

        Возможность использовать кэширование.

        Также подход Stateless позволяет использовать кэширование.

        Какие проблемы может создать Stateless-подход?

        Усложнение логики клиента (именно на стороне клиента нам нужно хранить всю информацию о состоянии, о допустимых действиях, о недопустимых действиях и подобных вещах).

        Увеличение нагрузки на сеть (каждый раз мы передаём всю информацию, весь контекст. Таким образом, больше информации гоняем по сети).


    Принцип 3. Кэширование
        В оригинале этот принцип говорит нам о том, что каждый ответ сервера должен иметь пометку, можно ли его кэшировать.
        Gеред тем, как сервер ответит клиенту, он должен сохранить эту информацию в кэше. И только потом вернуть ответ. Когда клиент в следующий раз отправит ровно такой же запрос, сервер сможет не обращаться к метеостанции. Он сможет извлечь прогноз из кэша и вернуть ответ клиенту.

        Какие у кэширования плюсы?
        Уменьшение количества сетевых взаимодействий.
        Уменьшение нагрузки на системы (не грузим их дополнительными запросами).


    Принцип 4. Единообразие интерфейса. HATEOAS
        Hypermedia as the Engine of Application State (HATEOAS) — одно из ограничений REST, согласно которому сервер возвращает не только ресурс, но и его связи с другими ресурсами и действия, которые можно с ним совершить.

        В качестве обратной стороны медали мы получаем сильное усложнение логики, в первую очередь, клиента. Это может потянуть за собой и усложнение логики на сервере, потому что такие ответы нужно правильно формировать. Фактически ответственность за действия, которые совершает клиент, мы передаём на его же сторону. Мы ослабляем контроль валидности совершаемых операций на стороне сервера.

    Принцип 5. Layered system (слоистая архитектура)
        Концепция слоистой архитектуры заключается в том, что ни клиент, ни сервер не должны знать о том, как происходит цепочка вызовов дальше своих прямых соседей.        
        Знания балансировщика в этой схеме об участниках конкретно этой цепочки вызовов должны заканчиваться proxy-сервером слева и сервером справа. О клиенте он уже ничего не знает.

        Если изменяется поведение proxy-сервера (балансировщика, роутера или чего-то ещё), это не должно повлечь изменения для клиентского приложения или для сервера. Помещая их в эту цепочку вызовов, мы не должны замечать никакой разницы. Это позволяет нам изменять общую архитектуру без доработок на стороне клиента или сервера.

        Минусы:
        Увеличение нагрузки на сеть (больше участников и больше вызовов, чем если бы мы шли один раз от клиента до сервера напрямую).
        Увеличение времени получения ответа (из-за появления дополнительных участников).

    Принцип 6. Code on done (код по требованию)

        Идея передачи некоторого исполняемого кода (по сути какой-то программы) от сервера клиенту.
        Что это значит?

        сервер передаёт исходный код клиенту, а тот его выполняет.

        Мы позволяем клиенту стать гибче. Если мы захотим изменить цвет фейерверка, то нам не нужно вносить изменений на клиенте — мы можем сделать это на сервере, а затем передавать клиенту. Пример такого языка — javascript.    





        REST — это архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Термин был введён Роем Филдингом в 2000 году. Также им были введены требования, которым должно удовлетворять распределённое приложение, чтобы соответствовать архитектуре REST (такие приложения ещё называют RESTful). Вот эти требования:

            - Модель "Клиент-Сервер" (означает, что сеть должна состоять из клиента и сервера; сервер - это тот, кто обладает ресурсами, клиент - тот, который их запрашивает))
            - Отсутствие состояния (означает, что ни клиент, ни сервер не отслеживают состояния друг друга)
            - Кеширование (клиенты и промежуточные узлы могут кешировать результаты запросов; сооответственно, ответы сервера должны иметь явное или неявное обозначение, что они кешируемые или некешируемые)
            - Единообразие интерфейса (означает, что между клиентами и серверами существует общий язык взаимодействия, который позволяет им быть заменяемыми или изменяемыми, без нарушения целостности системы):
            - Определение ресурса (означает, что каждый ресурс должны быть обозначен постоянным идентефикатором)
            - Управление ресурсами через представление (означает, что клиент хранит ресурс в виде его представления, и при желании изменения ресурса он отправляет серверу информацию о том, в каком виде он хотел бы видеть этот ресурс; сервер же рассматривает этот как запрос как предложение, и сам решает, что делать ему с хранимым ресурсом)
            - Самодостаточные сообщения (каждое сообщение содержит достаточно информации, чтобы понять, как его обрабатывать)
            Гипермедиа (означает, что клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервер)
            Система слоёв (означает, что в системе может быть больше двух слоёв (клиент и сервер), и при этом каждый такой слой знает только о своих соседних слоях, и не знает об остальных слоях, и взаимодействует только с соседними слоями)
            Код по требованию (означает, что функциональность клиента может быть расширения за счёт загрузки кода с сервера в виде апплетов или сценариев)
            Удовлетворение этим требованиям позволяет добиться следующего:

            Надёжность
            Производительность
            Масштабируемость
            Прозрачность взаимодействия
            Простота интерфейсов
            Портативность компонентов
            Лёгкость внесения изменений
            Способность эволюционировать, приспосабливаясь к новым требованиям


17. Что такое IP-адрес?

    IP-адрес — уникальный сетевой адрес узла в компьютерной сети, построенной на основе стека протоколов TCP/IP (TCP/IP – это набор интернет-протоколов). IP-адрес представляет собой серию из 32 двоичных бит (единиц и нулей). Так как человек невосприимчив к большому однородному ряду чисел, такому как этот 11100010101000100010101110011110 (здесь, к слову, 32 бита информации, так как 32 числа в двоичной системе), было решено разделить ряд на четыре 8-битных байта и получилась следующая последовательность: 11100010.10100010.00101011.10011110. Это не сильно облегчило жизнь и было решение перевести данную последовательность в, привычную нам, последовательность из четырёх чисел в десятичной системе, то есть 226.162.43.158. 4 разряда также называются октетами. Данный IP адрес определяется протоколом IPv4. По такой схеме адресации можно создать более 4 миллиардов IP-адресов.

    Максимальным возможным числом в любом октете будет 255 (так как в двоичной системе это 8 единиц), а минимальным – 0.

    IP-адреса делятся на 5 классов (A, B, C, D, E). 
    A, B и C — это классы коммерческой адресации. 
    D – для многоадресных рассылок, а класс E – для экспериментов.

    Класс А: 1.0.0.0 — 126.0.0.0, маска 255.0.0.0
    Класс В: 128.0.0.0 — 191.255.0.0, маска 255.255.0.0
    Класс С: 192.0.0.0 — 223.255.255.0, маска 255.255.255.0
    Класс D: 224.0.0.0 — 239.255.255.255, маска 255.255.255.255
    Класс Е: 240.0.0.0 — 247.255.255.255, маска 255.255.255.255

    У всех IP адресов есть две части сеть и узел.
        Сеть – это та часть IP, которая не меняется во всей сети и все адреса устройств начинаются именно с номера сети.
        Узел – это изменяющаяся часть IP. Каждое устройство имеет свой уникальный адрес в сети, он называется узлом.


    IP-адрес — это уникальный сетевой адрес узла в компьютерной сети, построенной на стеке протоколов TCP/IP. В сети Интернет требуется глобальная уникальность адреса; в случае работы в локальной сети требуется уникальность адреса в пределах сети. В версии протокола IPv4 IP-адрес имеет длину 4 байта, а в версии протокола IPv6 IP-адрес имеет длину 16 байт. Обычно IP-адрес в версии протокола IPv4 записывают в виде четырёх десятичных чисел со значениями от 0 до 255, разделённых точкой, например, 192.168.0.3.
    


18. Разница между host и domain?

    Хост (от англ. host – «хозяин, принимающий гостей») – какое-либо устройство, предоставляющее услуги по технологии «клиент - сервер» по каким-либо интерфейсам и уникально определенное на этом сервере. Это то место, где хранится различная информация, например, ваш сайт, потому что понятие «хост» чаще всего используется в связи с размещением веб-ресурса в интернете. В более частном случае хостом называется локальный компьютер, подключенный к интернету. Для обозначения хоста используется его сетевое имя – если хостом является домашний компьютер, и домен или ip-адрес – если речь идет о хосте в интернете.


    Домен (от англ. domain – «сфера», «территория») – это область пространства иерархических имен, идентифицирующихся доменом. Иначе говоря, под доменом понимается адрес сайта, его имя. Имя сайту, или адрес, необходимо затем, чтобы указать посетителям дорогу к ресурсу.
    Каждый входящий в интернет компьютер имеет свой уникальный доменный адрес (domain address), или по-другому доменное имя (domain name), или просто имя узла (host name). Адрес, или домен, существует в виде слова, иногда цифр, разделенные точками. От количества точек в имени зависит, домен какого уровня перед нами. Наиболее часто встречаются домены первого (или верхнего), второго и третьего уровней.



    - Домен — это адрес сайта или определённая зона, которая имеет своё имя, не похожее ни на какое другое имя в системе доменных имён. Домены бывают первого уровня, второго уровня, третьего уровня и т.д. Обычно домен первого уровня не доступен обычным пользователям для регистрации (примеры доменов первого уровня - ".ru", ".com", ".net"). Обычно домены третьего и следующих уровней называют субдоменами.
    - Хост — это определённый компьютер или сервер, подключенный к локальной или глобальной сети. Хост обладает обладает уникальным адресом в среде сервисов TCP/IP (IP-адресом).

19. Какие методы в HTTP вы знаете

    GET, POST, PUT, DELETE, OPTIONS, HEAD, PATCH, TRACE, LINK, UNLINK, CONNECT


20. Чем отличаются методы GET, POST и HEAD?

                                       GET       POST      HEAD
    Тело Запроса	                   Нет	     Есть	   Нет      
    Тело Ответа	                        Да	      Да	   Нет  
    Кеширование результата Запроса	    Да	      Нет	Да, заголовки    
    Идемпотентность	                    Да	      Нет	    Да  


21.    Разница между URI и URL?


URI - это унифицированный идентификатор ресурса, а URL - унифицированный указатель ресурса.

        URI (Uniform Resource Identifier) - унифицированный идентификатор ресурса. В кратце, он позволяет идентифицировать какой-либо ресурс: физический (https://assets.habr.com/habr-web/img/favicons/favicon-16.png - файл на сервере) или абстрактный (https://vk.com/settings - его не существует).

        Сам по себе URI ничего нам не дает, это всего лишь "интерфейс" (выражаясь на ООП). Самое интересное нам дают его подтипы.

        Его "интерфейс":

        URI = [ схема ":" ] иерархическая-часть [ "?" запрос ] [ "#" фрагмент ]

        URL (Uniform Resource Locator) - унифицированный локатор ресурса. Говорит, где нам нужно найти ресурс. 


        URI - унифицированный идентификатор ресурса
        Каждый доступный в Интернете ресурс, такой как документы HTML, изображения, видеоклипы, программы и т. д., находится по URI.
        URI обычно состоит из трех частей
        mechanism Механизм именования для доступа к ресурсам
        name Имя хоста для хранения ресурсов
        name Имя самого ресурса, представленное путем, подчеркивает ресурс.

 

        URL - унифицированное расположение ресурса
        URL - это строка, используемая для описания информационных ресурсов в Интернете, в основном используемая в различных клиентских программах WWW и серверных программах, особенно в знаменитой мозаике.
        URL-адрес может использоваться для описания различных информационных ресурсов в едином формате, включая файлы, адреса серверов и каталоги.
        URL обычно состоит из трех частей
        tocolПротокол (или метод обслуживания)
        IP IP-адрес хоста, на котором хранится ресурс (иногда включая номер порта)
        ③ Конкретный адрес хост-ресурса. Такие как каталог и имя файла