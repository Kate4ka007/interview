1. Что такое HTTP?

    HTTP — это протокол, позволяющий получать различные ресурсы, например HTML-документы. Протокол HTTP лежит в основе обмена данными в Интернете. HTTP является протоколом клиент-серверного взаимодействия, что означает инициирование запросов к серверу самим получателем, обычно веб-браузером (web-browser). Полученный итоговый документ будет (может) состоять из различных поддокументов, являющихся частью итогового документа: например, из отдельно полученного текста, описания структуры документа, изображений, видео-файлов, скриптов и многого другого.

    Клиенты и серверы взаимодействуют, обмениваясь одиночными сообщениями (а не потоком данных). Сообщения, отправленные клиентом, обычно веб-браузером, называются запросами, а сообщения, отправленные сервером, называются ответами.

    HTTP является протоколом прикладного уровня, который чаще всего использует возможности другого протокола - TCP (или TLS - защищённый TCP) - для пересылки своих сообщений, однако любой другой надёжный транспортный протокол теоретически может быть использован для доставки таких сообщений. Благодаря своей расширяемости, он используется не только для получения клиентом гипертекстовых документов, изображений и видео, но и для передачи содержимого серверам, например, с помощью HTML-форм. HTTP также может быть использован для получения только частей документа с целью обновления веб-страницы по запросу (например, посредством AJAX запроса).

    Каждый запрос (англ. request) отправляется серверу, который обрабатывает его и возвращает ответ (англ. response). Между этими запросами и ответами как правило существуют многочисленные посредники, называемые прокси, которые выполняют различные операции и работают как шлюзы или кэш, например.

    Ниже перечислены общие функции, управляемые с HTTP.

    - Кеш
    Сервер может инструктировать прокси и клиенты, указывая что и как долго кешировать. Клиент может инструктировать прокси промежуточных кешей игнорировать хранимые документы.
    - Ослабление ограничений источника
    Для предотвращения шпионских и других нарушающих приватность вторжений, веб-браузер обеспечивает строгое разделение между веб-сайтами. Только страницы из того же источника могут получить доступ к информации на веб-странице. Хотя такие ограничение нагружают сервер, заголовки HTTP могут ослабить строгое разделение на стороне сервера, позволяя документу стать частью информации с различных доменов (по причинам безопасности).
    - Аутентификация
    Некоторые страницы доступны только специальным пользователям. Базовая аутентификация может предоставляться через HTTP, либо через использование заголовка WWW-Authenticate (en-US) и подобных ему, либо с помощью настройки спецсессии, используя куки.
    - Прокси и туннелирование
    Серверы и/или клиенты часто располагаются в интернете и скрывают свои истинные IP-адреса от других. HTTP запросы идут через прокси для пересечения этого сетевого барьера. Не все прокси — HTTP прокси. SOCKS-протокол, например, оперирует на более низком уровне. Другие, как, например, ftp, могут быть обработаны этими прокси.
    - Сессии
    Использование HTTP кук позволяет связать запрос с состоянием на сервере. Это создаёт сессию, хотя ядро HTTP — протокол без состояния. Это полезно не только для корзин в интернет-магазинах, но также для любых сайтов, позволяющих пользователю настроить выход.


    HTTP поток
    Когда клиент хочет взаимодействовать с сервером, являющимся конечным сервером или промежуточным прокси, он выполняет следующие шаги:

    - Открытие TCP соединения: TCP-соединение будет использоваться для отправки запроса (или запросов) и получения ответа. Клиент может открыть новое соединение, переиспользовать существующее или открыть несколько TCP-соединений к серверу.
    - Отправка HTTP-сообщения: HTTP-сообщения (до HTTP/2) являются человекочитаемыми. Начиная с HTTP/2, простые сообщения инкапсулируются во фреймы, делая невозможным их чтение напрямую, но принципиально остаются такими же.

        GET / HTTP/1.1
        Host: developer.mozilla.org
        Accept-Language: fr

    - Читает ответ от сервера:


        HTTP/1.1 200 OK
        Date: Sat, 09 Oct 2010 14:28:02 GMT
        Server: Apache
        Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
        ETag: "51142bc1-7449-479b075b2891b"
        Accept-Ranges: bytes
        Content-Length: 29769
        Content-Type: text/html

        <!DOCTYPE html... (here comes the 29769 bytes of the requested web page)

    - Закрывает или переиспользует соединение для дальнейших запросов.
      Если активирован HTTP-конвейер, несколько запросов могут быть отправлены без ожидания получения первого ответа целиком. HTTP-конвейер тяжело внедряется в существующие сети, где старые куски ПО сосуществуют с современными версиями. HTTP-конвейер был заменён в HTTP/2 на более надёжные мультиплексные запросы во фрейме.


2. HTTP-запросы

    Запросы содержат следующие элементы:

    - HTTP-метод, обычно глагол подобно GET, POST или существительное, как OPTIONS или HEAD, определяющее операцию, которую клиент хочет выполнить. Обычно, клиент хочет получить ресурс (используя GET) или передать значения HTML-формы (используя POST), хотя другие операция могут быть необходимы в других случаях.
    - Путь к ресурсу: URL ресурсы лишены элементов, которые очевидны из контекста, например без протокола (http://), домена (здесь developer.mozilla.org), или TCP порта (здесь 80).
    - Версию HTTP-протокола.
    - Заголовки (опционально), предоставляющие дополнительную информацию для сервера.
      Или тело, для некоторых методов, таких как POST, которое содержит отправленный ресурс.      

3. Какие методы в HTTP вы знаете

    GET, POST, PUT, DELETE, OPTIONS, HEAD, PATCH, TRACE, LINK, UNLINK, CONNECT


4. Что такое HTTP cookie? Для чего они используются?

   HTTP cookie (web cookie, куки браузера) - это небольшой фрагмент данных, который сервер отправляет браузеру пользователя. Браузер может сохранить этот фрагмент у себя и отправлять на сервер с каждым последующим запросом. Это, в частности, позволяет узнать, с одного ли браузера пришли несколько запросов (например, для аутентификации пользователя). С помощью кук можно сохранить любую информацию о состоянии, HTTP-протокол сам по себе этого делать не умеет.

    Куки часто используются для:

    - Управления сеансом (логины, корзины для виртуальных покупок)
    - Персонализации (пользовательские предпочтения)
    - Трекинга (отслеживания поведения пользователей)

   Получив HTTP-запрос, вместе с ответом сервер может отправить заголовок Set-Cookie. Куки обычно запоминаются браузером и посылаются в HTTP-заголовке Cookie (en-US) с каждым новым запросом к одному и тому же серверу. Можно задать срок действия кук, а также срок их жизни, после которого куки не будут отправляться. Также можно указать ограничения на путь и домен, то есть указать, в течении какого времени и к какому сайту они будут отсылаться.


   * Сессионные cookie
       Простой cookie, пример которого приведён выше, представляет собой сессионный cookie (session cookie) - такие cookie удаляются при закрытии клиента, то есть существуют только на протяжении текущего сеанса, поскольку атрибуты Expires или  Max-Age для него не задаются. Однако, если в браузере включено автоматическое восстановление сеанса, что случается очень часто, cookie сеанса может храниться постоянно, как если бы браузер никогда не закрывался.

    * Постоянные cookies
       Постоянные cookie (permanent cookies) удаляются не с закрытием клиента, а при наступлении определённой даты (атрибут Expires) или после определённого интервала времени (атрибут Max-Age).

           Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;


    * Secure ("безопасные") и HttpOnly куки
        "Безопасные" (secure) куки отсылаются на сервер только тогда, когда запрос отправляется по протоколу SSL и HTTPS. Однако важные данные никогда не следует передавать или хранить в куках, поскольку сам их механизм весьма уязвим в отношении безопасности, а флаг secure никакого дополнительного шифрования или средств защиты не обеспечивает. Начиная с Chrome 52 и Firefox 52, незащищённые сайты (http:) не могут создавать куки с флагом Secure.

        Куки HTTPonly не доступны из JavaScript через свойства Document.cookie API, что помогает избежать межсайтового скриптинга (XSS (en-US)). Устанавливайте этот флаг для тех кук, к которым не требуется обращаться через JavaScript. В частности, если куки используются только для поддержки сеанса, то в JavaScript они не нужны, так что в этом случае следует устанавливать флаг HttpOnly.


5. Что такое WebSocket? В чем принцип его работы?  

   WebSocket — это двунаправленный протокол связи между клиентом (браузером) и сервером, позволяющий обмениваться сообщениями в режиме реального времени. Он устанавливает одно соединение и передает ответ на единственный запрос в тот момент, когда ответ появился — без дополнительных запросов, как у HTTP-протокола.

   Протокол HTTP однонаправленный. После цикла «запрос — ответ» соединение закрывается, а любой следующий запрос каждый раз устанавливает новое соединение с сервером: сколько запросов, столько и соединений. Процесс передачи данных происходит с некоторыми задержками за счет того, что есть накладные расходы на установку нового соединения при каждом запросе/ответе, а также сетевая и серверная нагрузка из-за обилия периодических запросов. В чистом виде протокол HTTP сейчас используется все реже, ему на смену приходит HTTPS. Это не отдельный протокол, а надстройка над HTTP, позволяющая шифровать данные.

   Протокол WebSocket двунаправленный, полнодуплексный, что означает, что он может одновременно и получать, и передавать информацию. Веб-сокет делает это множество раз в одном открытом соединении. У такого соединения и скорость выше, чем у HTTP.

   У веб-сокетов также есть возможность шифровать передаваемые данные, для этого используется надстройка над протоколом — WSS. Если передаваемые данные не зашифрованы, они становятся объектом для привлечения таких угроз, как несанкционированный доступ к клиенту третьих сторон, использование вредоносного ПО. Специальные надстройки протоколов передачи данных кодируют информацию на стороне отправителя и раскодируют на стороне получателя, оставляя ее зашифрованной для любых посредников. Так достигается безопасный транспортный уровень.

6. Разница между HTTP и HTTPS?

  HTTPS не является отдельным протоколом передачи данных, а представляет собой расширение протокола HTTP с надстройкой шифрования; передаваемые по протоколу HTTP данные не защищены, HTTPS обеспечивает конфиденциальность информации путем ее шифрования; HTTP использует порт 80, HTTPS — порт 443.


  КЛЮЧЕВЫЕ РАЗЛИЧИЯ
  - В HTTP отсутствует механизм защиты для шифрования данных, в то время как HTTPS для защиты связи между сервером и клиентом использует цифровой сертификат SSL или TLS.
  - HTTP работает на уровне приложения, а HTTPS - на транспорном уровне.
  - HTTP по умолчанию работает по 80-ому порту, а HTTPS – через 443-му.
  - HTTP передает данные открытым текстом, а HTTPS - зашифрованным.
  - HTTP по сравнению с HTTPS работает быстрее, поскольку последнему нужно время для шифрования канала связи.

  ПРЕИМУЩЕСТВА HTTP:
  - HTTP может быть реализован на основе другого протокола в Интернете или в других сетях;
  - Страницы HTTP хранятся в кэше компьютера и Интернета, поэтому доступ к ним осуществляется быстрее;
  - Кроссплатформенность
  - Не нуждается в поддержке среды выполнения
  - Можно использовать через брандмауэры. Возможны глобальные приложения
  - Не ориентирован на подключение; таким образом, отсутствуют накладные расходы на сеть для создания и поддержания состояния сеанса и информации

  ПРЕИМУЩЕСТВА HTTPS
  - В большинстве случаев сайты, работающие по протоколу HTTPS, будут перенаправлены. Поэтому даже если ввести HTTP://, он перенаправит на https через защищенное соединение
  - Это позволяет пользователям выполнять безопасные транзакции электронной коммерции, такие как онлайн-банкинг.
  - Технология SSL защищает всех пользователей и создает доверие
  - Независимый орган проверяет личность владельца сертификата. Таким образом, каждый SSL-сертификат содержит уникальную аутентифицированную информацию о владельце сертификата.

  ОГРАНИЧЕНИЯ HTTP
  - Нет защиты информации, так как любой может прослушать и увидеть передаваемый контент
  - Обеспечение целостности данных является большой проблемой, поскольку есть возможность изменения содержимого на лету во время передачи.
  - Не знаешь кто на противоположной стороне. Любой, кто перехватит запрос, может получить имя пользователя и пароль.

  ОГРАНИЧЕНИЯ HTTPS
  - Протокол HTTPS не может остановить кражу конфиденциальной информации со страниц, кэшированных в браузере
  - Данные SSL могут быть зашифрованы только во время передачи по сети. Поэтому он не может очистить текст в памяти браузера
  - HTTPS ввиду вычислений может увеличить задержки во время передачи данных.

 
7. Разница между Long-Polling, Websockets и Server-Sent Events?

   - HTTP Long Polling

   Клиент отправляет запрос на сервер, сервер держит открытым соединение пока не придут какие-нибудь данные или клиент не отключится самостоятельно. Как только данные пришли — отправляется ответ и соединение закрывается и открывается следующее и так далее.
      Плюсы по сравнению с Polling:
      — Минимальное количество запросов
      — Высокая временная точность событий
      — Сервер хранит события только на время реконнекта
      Минусы по сравнению с Polling:
      — Более сложная схема


   - WebSockets

      Это бинарный дуплексный протокол, позволяющий клиенту и серверу общаться на равных. Этот протокол можно применять для игр, чатов и всех тех приложений где вам нужны предельно точные события близкие к реальному времени.WebSocket - это протокол связи с компьютером который обеспечивает полнодуплексный каналы связи через одиночное TCP-соединение.

      Особенности протокола

      * Он отличается от HTTP, но совместим с HTTP.
      * Находится на уровне 7 в модели OSI и зависит от TCP на уровне 4.
      * Работает через порт 80 и 443 (в случае шифрования TLS) и поддерживает HTTP-прокси и посредников.
      * Для достижения совместимости при подтверждении связи WebSocket используется заголовок Upgrade для обновления протокола до протокола WebSocket.
      
      Плюсы по сравнению с Long Polling:

      * Поднимается одно соединение
      * Предельно высокая временная точность событий
      * Управление сетевыми сбоями контролирует браузер
      * Протокол WebSocket обеспечивает взаимодействие между клиентом и веб-сервером с меньшими накладными расходами, обеспечивая передачу данных в реальном времени с сервера и на сервер.
      * Основное преимущество серверной части WebSockets заключается в том, что это не HTTP-запрос (после рукопожатия), а правильный протокол связи на основе сообщений. Это позволяет достичь огромных преимуществ в производительности и архитектуре . Например, в node.js вы можете использовать одну и ту же память для разных соединений сокетов, чтобы каждый из них мог получить доступ к общим переменным. Следовательно, вам не нужно использовать базу данных в качестве точки обмена посередине (например, с AJAX или длинным опросом с таким языком, как PHP). Вы можете хранить данные в ОЗУ или даже сразу же повторно публиковать их между сокетами.

      Минусы по сравнению с Long Polling:
      — HTTP не совместимый протокол, нужен свой сервер, усложняется отладка

    - Протокол Server-Sent Events
  
  Идея SSE проста — клиент подписывается на события сервера и как только происходит событие — клиент сразу же получает уведомление и некоторые данные, связанные с этим событием. Чтобы понять полезность протокола SSE необходимо сравнить его с привычными методами получения событий, вкратце объясню их суть:

  Клиент отправляет запрос на сервер, сервер в ответ отправляет следующий заголовок:

  Content-Type: text/event-stream

  И не закрывает соединение. Чтобы отправить клиенту какие-то данные сервер просто пишет в сокет строку следующего формата:

  data: My message\n\n

  Если необходимо отправить несколько строк данных, то формат будет следующим:

  data: {\n
  data: "msg": "hello world",\n
  data: "id": 12345\n
  data: }\n\n  

  Вот, впринципе, и вся база протокола. Кроме этого сервер может отправлять id сообщения это нужно на случай если соединение было разорвано. Если соединение было сброшено, то клиент при попытке подключения отправит специальный заголовок (Last-Event-ID), чтобы восстановить утраченные события:

  id: 12345\n
  data: GOOG\n
  data: 556\n\n

  Время переподключения (retry) в случае ошибок:

  retry: 10000\n
  data: hello world\n\n

  Поле id и retry не обязательны.

 
8. Разница между PUT- и POST-запросами?

   - PUT — создать новую запись
   - POST — обновить существующую запись


POST запрос подразумевает создание записи, результатом ее должены быть пустое тело ответа и заголовок location c uri нового объекта.

PUT — подмена записей. Тобиш обновить одно какое-то поле у записи нельзя. Опять же, если вы заменили объект — то вы уже имеете на руках все нужные данные, посему ответом может быть опять же заголовок location.

есть еще метод PATCH, который позволяет именно обновлять запись (конкретное поле или несколько из них). Тут тоже подразумевается возврат только URI. По сути какие либо данные вам может вернуть только GET запрос.


   
