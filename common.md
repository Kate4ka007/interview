1. Разница между классовым и прототипным наследованием?
   - Как прототипное наследование, так и классическое наследование являются парадигмами объектно-ориентированного программирования (т. е. они имеют дело с объектами)

    * Классовое наследование: экземпляры наследуются от классов, создаются подклассовые отношения (иерархическая систематизация классов). Экземпляры реализуются через конструктор функции, через дескриптор new. Экземпляр класса может не содержать дескриптор class начиная с ES6.
      - В классическом наследовании объекты являются абстракциями «вещей» реального мира, но мы можем ссылаться на объекты только через классы. Классы — в данном случае это обобщение объекта. Другими словами, получается что классы — это абстракция объекта реального мира. При обобщении мы наследуем один класс от другого. И при классическом наследовании процесс наследования должен создавать уровень абстракции. При каждом наследовании, каждый дочерний класс должен повышать уровень абстракции, тем самым повышая уровень обобщения. 
      Объекты в классических объектно-ориентированных языках программирования могут быть созданы только путем создания экземпляров классов.

    * Прототипное наследование: экземпляры наследуются напрямую от других объектов, реализуются через фабрики или Object.create() и экземпляры могут быть составлены из множества различных объектов для упрощения выборочного наследования. Прототипное наследование более простое и гибкое, нежели классовое. 
      - В отличие от классического наследования, прототипное наследование не имеет дело с увеличивающимися уровнями абстракции. Объект — это либо абстракция реальной вещи, как и раньше, либо прямая копия другого Объекта (другими словами, Прототипа (Prototype)). Объекты могут быть созданы из ничего, или они могут быть созданы из других объектов. Уровень абстракции здесь не обязан быть глубже одного уровня (хотя при желание может и быть).

      Некоторые преимущества прототипного наследования:


      - Слабая связь. Экземпляр никогда не нуждается в прямой ссылке на родительский класс или прототип. Можно сохранить ссылку на прототип объекта, но это не рекомендуется, потому что это будет способствовать тесной связи в иерархии объектов — одна из самых больших ошибок классического наследования.


      - Плоские иерархии. С прототипным наследованием легко поддерживать плоские иерархии наследования — используя конкатенацию (выборочное использование свойств одного объекта для создания другого ) и делегирование (клонирование одного объекта в другой), вы можете иметь один уровень делегирования объекта и один экземпляр без ссылок на родительские классы.


      - Тривиальное множественное наследование. Наследование от нескольких предков так же просто, как объединение свойств из нескольких прототипов с использованием конкатенации для формирования нового объекта или нового делегата для нового объекта.


      - Гибкая архитектура. Поскольку вы можете выборочно наследоваться, вам не нужно беспокоиться о проблеме «неправильного дизайна». Новый класс может наследовать любую комбинацию свойств от любой комбинации исходных объектов. Из-за простоты выравнивания иерархии, изменение в одном месте не обязательно вызывает рябь в длинной цепочке объектов-потомков.



2. Что такое двусторонняя связь данных и однонаправленный поток данных и в чем разница между ними?

    * Двусторонняя связь данных подразумевает, что поля интерфейса связаны с моделью данных динамически, то есть при изменении полей интерфейса меняется модель, и наоборот. Данные в двунаправленном потоке могут передаваться между частями программы в обе стороны. 
    Чаще всего это используется для связывания модели и представления, чтобы обновление, например, текста в поле ввода сразу обновило данные в модели — это называется двунаправленным связыванием данных (two-way data binding).

    * В однонаправленном потоке данных каждая часть программы от другой части может либо получить данные, либо передать. Направление такого потока не меняется. Однонаправленный поток можно схематично представить, как водопровод, а модуль — как часть трубы.
    Однонаправленный поток данных означает, что только модель – источник истины. Изменения в интерфейсе запускают сообщения, которые сигнализируют пользователю о намерении модели (или «store» в терминах React). Смысл в том, что данные всегда идут в одном направлении, что облегчает понимание.
    Односторонние потоки данных детерминированы, тогда как двусторонняя привязка может вызывать нежелательные эффекты, которые труднее отследить и понять.

    Хорошо упомянуть:

    React – новый канонический пример однонаправленного потока данных, так что упоминание Реакта будет хорошей идеей. Cycle.js — еще одна популярная реализация однонаправленного потока данных.
    
    Angular – популярный фреймворк, использующий двустороннюю привязку.


3. Функциональное программирование — это стиль программирования, в котором особое значение придается использованию функций и неизменяемых данных.  
Смысл функционального программирования в том, что мы задаём не последовательность нужных нам команд, а описываем взаимодействие между ними и подпрограммами. 
Команды можно собирать в подпрограммы, но их последовательность не имеет значения.

Принципы функционального программирования
    * Переменные и функции
    Ключевыми составляющими функциональной программы являются уже не объекты и методы, а переменные и функции. При этом следует избегать глобальных переменных, потому что изменяемые глобальные переменные усложняют понимание программы и ведут к появлению у функций побочных эффектов.

    * Чистые функции
    Для чистых функций характерны два свойства:
      они не создают побочных эффектов;
      они всегда производят одинаковый вывод при получении одинакового ввода, что еще можно называть как ссылочную прозрачность. 
    Побочные эффекты же возникают, если функция изменяет состояние программы, переписывает вводную переменную или в общем вносит какие-либо изменения при генерации вывода. Отсутствие же побочных эффектов снижает риски появления ошибок по вине чистых функций. 


    * Неизменяемость и состояния
    Неизменяемые данные или состояния не могут изменяться после их определения, что позволяет сохранять постоянство стабильной среды для вывода функций. Лучше всего программировать каждую функцию так, чтобы она выводила один и тот же результат независимо от состояния программы. Если же она зависит от состояния, то это состояние должно быть неизменяемым, чтобы вывод такой функции оставался постоянным.
    Подходы функционального программирования обычно избегают применения функций с общим состоянием (когда несколько функций опираются на одно состояние) и функций с изменяющимся состоянием (которые зависят от изменяемых функций), потому что они уменьшают модульность программы. Если же вы не можете обойтись без функций с общим состоянием, сделайте это состояние неизменяемым. 

    * Рекурсия
    Одно из серьезных отличий объектно-ориентированного программирования от функционального в том, что программы последнего избегают таких конструкций, как инструкции if else или циклы, которые в разных случаях выполнения могут выдавать разные выводы.
    Вместо циклов функциональные программы используют для всех задач по перебору рекурсию.

    * Функции первого класса
    Функции в ФП рассматриваются как типы данных и могут использоваться как любое другое значение. Например, мы заполняем функциями массивы, передаем их в качестве параметров или сохраняем их в переменных. 

    * Функции высшего порядка
    Эти функции могут принимать другие функции в качестве параметров или возвращать функции в качестве вывода. Они делают возможности вызова функций более гибкими и позволяют легче абстрагироваться от действий.

    * Композиция функций
    Для выполнения сложных операций функции можно выполнять последовательно. В этом случае результат каждой функции передается следующей функции в виде аргумента. Это позволяет с помощью всего одного вызова функции активировать целую серию их последовательных вызовов. 

    Преимущества функционального программирования
    - Легкая отладка: чистые функции и неизменяемые данные упрощают обнаружение мест определения значений переменных. В чистых функциях меньше факторов, влияющих на них, что позволяет быстрее находить проблемные участки кода. 
    - Отложенное вычисление: функциональные программы производят вычисления только при необходимости. Это позволяет им повторно использовать ранее полученные результаты и экономить время на выполнение. 
    - Модульность: чистые функции не полагаются на внешние переменные или состояния, в связи с чем их можно легко переиспользовать в разных местах программы. Кроме того, функции будут выполнять только одну операцию или вычисление, что не позволит вам при их использовании случайно импортировать лишний код.
    - Лучшая читаемость: функциональные программы легко читать, потому что поведение каждой функции неизменяемо и изолировано от состояния программы. В результате вы зачастую можете легко понять, что будет делать функция, просто по ее имени.
    - Параллельное программирование: программы легче создавать при помощи функционального подхода, потому что неизменяемые переменные снижают число изменений внутри этих программ. Каждой функции приходится работать только с вводом пользователя, и она может быть уверена, что состояние программы в основном останется прежним. 


плюсы:
  - Unit тестирование
  - Отладка
  - Многопоточность
  - Развёртывание по горячему 
  - Функции высшего порядка
  - Каррирование
  - Ленивые вычисления
  - Оптимизация
  - Абстрагирование структур управления
  - Бесконечные структуры данных

         
3. Что такое MVC?
    MVC — это шаблон (pattern) программирования, который позволяет разделить логику приложения на три части:
        - Model (модель). Получает данные от контроллера, выполняет необходимые операции и передаёт их в вид.
        - View (вид или представление). Получает данные от модели и выводит их для пользователя.
        - Controller (контроллер). Обрабатывает действия пользователя, проверяет полученные данные и передаёт их модели.
        
        Этот паттерн разработки нужен для того, чтобы разделить логические части приложения и создавать их отдельно друг от друга. То есть писать независимые блоки кода, которые можно как угодно менять, не затрагивая другие.

        Модель — метод, который запускается обработчиком и выполняет все основные операции (получение записей из базы данных, проведение вычислений).
        Вид — интерфейс.
        Контроллер — обработчик событий, инициируемых пользователем (нажатие на кнопку, переход по ссылке, отправка формы).

4. Что такое MVVM? 
MVVM — это паттерн разработки, позволяющий разделить приложение на три функциональные части:

Model — основная логика программы (работа с данными, вычисления, запросы и так далее).
View — вид или представление (пользовательский интерфейс).
ViewModel — модель представления, которая служит прослойкой между View и Model.

5. Что такое MVP? 
MVP — это паттерн программирования графических интерфейсов. В нём приложение делится на три компонента:

Model (Модель) работает с данными, проводит вычисления и руководит всеми бизнес-процессами.
View (Вид или представление) показывает пользователю интерфейс и данные из модели.
Presenter (Представитель) служит прослойкой между моделью и видом.

6. В чем разница между null и undefined?

   Для начала давайте поговорим о том, что у них общего.
     - они принадлежат к 7 «примитивам» (примитивным типам) JS:
       ['string', 'number', 'null', 'undefined', 'boolean', 'symbol', 'bigint']
     - они являются ложными значениями, т.е. результатом их преобразования в логическое значение с помощью Boolean() или оператора "!!" является false:
        console.log(!!null) // false
        console.log(!!undefined) // false

        console.log(Boolean(null)) // false
        console.log(Boolean(undefined)) // false

   Различия:
       * undefined («неопределенный») представляет собой значение по умолчанию:
           - переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;
           - функции, которая ничего не возвращает явно, например, console.log(1);
           - несуществующего свойства объекта.

            let _thisIsUndefined
            const doNothing = () => {}
            const someObj = {
                a: 'ay'
              }
            console.log(_thisIsUndefined) // undefined
            console.log(doNothing()) // undefined
            console.log(someObj['b']) // undefined


        * null — это «значение отсутствия значения». null — это значение, которое присваивается переменной явно. В примере ниже мы получаем null, когда метод fs.readFile отрабатывает без ошибок:

            fs.readFile('path/to/file', (e, data) => {
                console.log(e) // здесь мы получаем null
            if(e) {
                console.log(e)
            }
                console.log(data)
            })

        При сравнении null и undefined мы получаем true, когда используем оператор "==", и false при использовании оператора "===". О том, почему так происходит, см. ниже.
            console.log(null == undefined) // true
            console.log(null === undefined) // false

7. Для чего используется оператор "&&"?
       Оператор "&&" (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежание лишних затрат:
          console.log(false && 1 && []) // false
          console.log(' ' && true && 5) // 5


8. Для чего используется оператор "||"?

       Оператор "||" (логическое или) находит и возвращает первое истинное значение. Он также использует короткое замыкание. Данный оператор использовался для присвоения параметров по умолчанию в функциях до того, как параметры по умолчанию были стандартизированы в ES6.
            console.log(null || 1 || undefined) // 1

9. Является ли использование унарного плюса (оператор "+") самым быстрым способом преобразования строки в число? 
    Согласно MDN оператор "+" действительно является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом.

10. Что такое DOM?

    - DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. DOM представляет собой древовидную структуру (дерево документа). DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.
    - В JS DOM представлен объектом Document. Объект Document имеет большое количество методов для работы с элементами, их созданием, модификацией, удалением и т.д.    

11. Что такое распространение события (Event Propagation)?

    Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:
    - Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков.
    - Целевая фаза — это когда событие достигает целевого элемента.
    - Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window.

12. Что такое всплытие события?

    Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window.
    У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения (для «прослушивателей» событий, прикрепленных к цели события, событие находится в целевой фазе, а не в фазах погружения или всплытия. События в целевой фазе инициируют все прослушиватели на элементе в том порядке, в котором они были зарегистрированы независимо от параметра useCapture — прим. пер.). Если мы кликнем по элементу child, в консоль будет выведено: child, parent, grandparent, html, document, window. Вот что такое всплытие события.   

13. Что такое погружение события?

    Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков.
    У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения. Если мы кликнем по элементу child, то увидим в консоли следующее: window, document, html, grandparent, parent, child. Это и есть погружение события.  


14.  В чем разница между методами event.preventDefault() и event.stopPropagation()?

     - Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.).
     - Метод event.stopPropagation() отключает распространение события (его всплытие или погружение). 

15.  Как узнать об использовании метода event.preventDefault()?

     Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault.   

16. Почему obj.someprop.x приводит к ошибке? 

        const obj = {}
        console.log(obj.someprop.x)
    Ответ очевиден: мы пытается получить доступ к свойству x свойства someprop, которое имеет значение undefined. obj.__proto__.__proto = null, поэтому возвращается undefined, а у undefined нет свойства x.    

17. Что такое цель события или целевой элемент (event.target)?
    event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие.

18. Что такое текущая цель события (event.currentTarget)?
    Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий.    

19. В чем разница между операторами "==" и "==="?

    Разница между оператором "==" (абстрактное или нестрогое равенство) и оператором "===" (строгое равенство) состоит в том, что первый сравнивает значения после их преобразования или приведения к одному типу (Coersion), а второй — без такого преобразования.

    Преобразование представляет собой процесс приведения значения к другому типу или, точнее, процесс приведения сравниваемых значений к одному типу. При сравнении оператор "==" производит так называемое неявное сравнение. Оператор "==" выполняет некоторые операции перед сравнением двух значений.

      Допустим, мы сравниваем x и y.

      Алгоритм следующий:
          Если x и y имеют одинаковый тип, сравнение выполняется с помощью оператора "===".
          Если x = null и y = undefined возвращается true.
          Если x = undefined и y = null возвращается true.
          Если x = число, а y = строка, возвращается x == toNumber(y) (значение y преобразуется в число).
          Если x = строка, а y = число, возвращается toNumber(x) == y (значение x преобразуется в число).
          Если x = логическое значение, возвращается toNumber(x) == y.
          Если y = логическое значение, возвращается x == toNumber(y).
          Если x = строка, символ или число, а y = объект, возвращается x == toPrimitive(y) (значение y преобразуется в примитив).
          Если x = объект, а y = строка, символ или число, возвращается toPrimitive(x) == y.
          Возвращается false.

          Запомните: для приведения объекта к «примитиву» метод toPrimitive сначала использует метод valueOf, затем метод toString.


20. Почему результатом сравнения двух похожих объектов является false?

        let a = {
            a: 1
        }
        let b = {
            a: 1
        }
        let c = a

        console.log(a === b) // false
        console.log(a === c) // true хм...


        - В JS объекты и примитивы сравниваются по-разному. Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная. Вот почему первый console.log возвращает false, а второй — true. Переменные «a» и «c» ссылаются на один объект, а переменные «a» и «b» — на разные объекты с одинаковыми свойствами и значениями.  

21. Для чего используется оператор "!!"?
        Оператор "!!" (двойное отрицание) приводит значение справа от него к логическому значению.          
              console.log(!!null) // false
              console.log(!!undefined) // false
              console.log(!!'') // false
              console.log(!!0) // false
              console.log(!!NaN) // false
              console.log(!!' ') // true
              console.log(!!{}) // true
              console.log(!![]) // true
              console.log(!!1) // true
              console.log(!![].length) // false

22. Как записать несколько выражений в одну строку?

        Для этого мы можем использовать оператор "," (запятая). Этот оператор «двигается» слева направо и возвращает значение последнего выражения или операнда.

        let x = 5

        x = (x++, x = addFive(x), x *= 2, x -= 5, x += 10)

        function addFive(num) {
            return num + 5
        }


    Если мы выведем значение x в консоль, то получим 27. Сначала мы увеличиваем значение x на единицу (x = 6). Затем вызываем функцию addFive() с параметром 6, к которому прибавляем 5 (x = 11). После этого мы умножаем значение x на 2 (x = 22). Затем вычитаем 5 (x = 17). И, наконец, прибавляем 10 (x = 27).              
             
23. Что такое поднятие (Hoisting)?

    Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.

    Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения.
    Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение.

    - Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.).

    - Выполнение. В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.

    Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.

    Предположим, что у нас есть такой код:

          console.log(y)
          y = 1
          console.log(y)
          console.log(greet('Mark'))

          function greet(name) {
              return 'Hello ' + name + '!'
          }

          var y

          Получаем undefined, 1 и 'Hello Mark!'.

          Вот как выглядит фаза компиляции:

          function greet(name) {
              return 'Hello ' + name + '!'
          }

          var y // присваивается undefined

          // ожидается завершение фазы компиляции

          // затем начинается фаза выполнения
          /*
          console.log(y)
          y = 1
          console.log(y)
          console.log(greet('Mark'))
          */


    После завершения фазы компиляции начинается фаза выполнения, когда переменным присваиваются значения и вызываются функции. 
      


24. Контекст выполнения

    Контекст выполнения (execution context) — это, если говорить упрощённо, концепция, описывающая окружение, в котором производится выполнение кода на JavaScript. Код всегда выполняется внутри некоего контекста.

      ▍Типы контекстов выполнения
      В JavaScript существует три типа контекстов выполнения:
          * Глобальный контекст выполнения. Это базовый, используемый по умолчанию контекст выполнения. Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, которым, в случае с браузером, является объект window, и тем, что ключевое слово this указывает на этот глобальный объект. В программе может быть лишь один глобальный контекст.
          * Контекст выполнения функции. Каждый раз, когда вызывается функция, для неё создаётся новый контекст. Каждая функция имеет собственный контекст выполнения. В программе может одновременно присутствовать множество контекстов выполнения функций. При создании нового контекста выполнения функции он проходит через определённую последовательность шагов, о которой мы поговорим ниже.
          * Контекст выполнения функции eval. Код, выполняемый внутри функции eval, также имеет собственный контекст выполнения. Однако функцией eval пользуются очень редко, поэтому здесь мы об этом контексте выполнения говорить не будем.

25. Стек выполнения

        Стек выполнения (execution stack), который ещё называют стеком вызовов (call stack), это LIFO-стек, который используется для хранения контекстов выполнения, создаваемых в ходе работы кода. 
        Когда JS-движок начинает обрабатывать скрипт, движок создаёт глобальный контекст выполнения и помещает его в текущий стек. При обнаружении команды вызова функции движок создаёт новый контекст выполнения для этой функции и помещает его в верхнюю часть стека.

        Движок выполняет функцию, контекст выполнения которой находится в верхней части стека. Когда работа функции завершается, её контекст извлекается из стека и управление передаётся тому контексту, который находится в предыдущем элементе стека.

        Изучим эту идею с помощью следующего примера:
        let a = 'Hello World!';
        function first() {
          console.log('Inside first function');
          second();
          console.log('Again inside first function');
        }
        function second() {
          console.log('Inside second function');
        }
        first();
        console.log('Inside Global Execution Context');


    Вот как будет меняться стек вызовов при выполнении этого кода.
    Состояние стека вызовов
    Когда вышеприведённый код загружается в браузер, JavaScript-движок создаёт глобальный контекст выполнения и помещает его в текущий стек вызовов. При выполнении вызова функции first() движок создаёт для этой функции новый контекст и помещает его в верхнюю часть стека.
    При вызове функции second() из функции first() для этой функции создаётся новый контекст выполнения и так же помещается в стек. После того, как функция second() завершает работу, её контекст извлекается из стека и управление передаётся контексту выполнения, находящемуся в стеке под ним, то есть, контексту функции first().
    Когда функция first() завершает работу, её контекст извлекается из стека и управление передаётся глобальному контексту. После того, как весь код оказывается выполненным, движок извлекает глобальный контекст выполнения из текущего стека.    

26. Что такое область видимости (Scope)?

    Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).

        - Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.

        - Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.

        - Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.


    Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).          

27. Что такое замыкание (Closures)?
        По сути, замыкание — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости, в области видимости родительской функции, в области видимости родителя родительской функции и так до глобальной области видимости с помощью цепочки областей видимости. Обычно область видимости определяется при создании функции.

        Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.
        
        Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.  в JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").
        То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и все они могут получить доступ к внешним переменным.

        Когда на собеседовании фронтенд-разработчик получает вопрос: «что такое замыкание?», – правильным ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, как работает лексическое окружение.

28. Какие значения в JS являются ложными?

    const falsyValues = ['', 0, null, undefined, NaN, false]
    Ложными являются значения, результатом преобразования которых в логическое значение является false.   

29. Как проверить, является ли значение ложным?
    Следует использовать функцию Boolean или оператор "!!" (двойное отрицание).   

30. Для чего используется директива «use strict»?

    «use strict» — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах.

    Вот какие ограничения накладывает строгий режим.
        - Нельзя присваивать значения или обращаться к необъявленным переменным:
              function returnY() {
                  'use strict'
                  y = 123
                  return y
              }
              returnY() // Uncaught ReferenceError: y is not defined

        - Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи:
          'use strict'
          var NaN = NaN // Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#<Window>'
          var undefined = undefined
          var Infinity = 'and beyond'

        - Нельзя удалить «неудаляемое» свойство объекта:

          'use strict'
          const obj = {}
          Object.defineProperties(obj, 'x', {
              value: 1
          })

          delete obj.x // Uncaught TypeError: Property description must be an object: x

        - Запрещено дублирование параметров:

          'use strict'
          function someFunc(a, b, b, c) {} // Uncaught SyntaxError: Duplicate parameter name not allowed in this context

        - Нельзя создавать функции с помощью функции eval:

          'use strict'
          eval('var x = 1')
          console.log(x) // Uncaught ReferenceError: x is not defined

        - Значением «this» по умолчанию является undefined:

          'use strict'

          function showMeThis() {
              return this
          }
          showMeThis() // undefined

31. Какое значение имеет this?

    Обычно this ссылается на значение объекта, который в данный момент выполняет или вызывает функцию. «В данный момент» означает, что значение this меняется в зависимости от контекста выполнения, от того места, где мы используем this.  

    Call и apply принимают в качестве первого аргумента объект, который будет являться значением this внутри функции.

    В IIFE, функциях, которые создаются в глобальном области видимости, анонимных функциях и внутренних функциях методов объекта значением this по умолчанию является объект window.     

    Стрелочные функции не имеют собственного значения this. Они копируют значение this из внешнего лексического окружения. 

32. Что такое прототип объекта?

    В двух словах, прототип — это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS.

    const o = {}
    console.log(o.toString()) // [object Object]

    Несмотря на то, что объект «о» не имеет свойства toString, обращение к этому свойству не вызывает ошибки. Если определенного свойства нет в объекте, его поиск осуществляется сначала в прототипе объекта, затем в прототипе прототипа объекта и так до тех пор, пока свойство не будет найдено. Это называется цепочкой прототипов. На вершине цепочки прототипов находится Object.prototype.

33. Что такое IIFE?

    IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так: (function(){})().
    const utility = (function( ) {
        return {
            // утилиты
        }
    })
    мы можем сохранить результат IIFE в переменной.

    Лучшее использование IIFE — это выполнение функций настройки инициализации и предотвращение конфликтов имен с другими переменными в глобальной области видимости (загрязнение глобального пространства имен). Приведем пример.

34. Для чего используется метод Function.prototype.apply?

    Apply используется для привязки определенного объекта к значению this вызываемой функции.

        const details = {
            message: 'Hello World!'
        }

        function getMessage() {
            return this.message
        }

        getMessage.apply(details) // Hello World!


    Этот метод похож на Function.prototype.call. Единственное отличие состоит в том, что в apply аргументы передаются в виде массива.

        const person = {
            name: 'Marko Polo'
        }

        function greeting(greetingMessage) {
            return `${greetingMessage} ${this.name}`
        }

        greeting.apply(person, ['Hello']) // Hello Marko Polo

35.  Для чего используется метод Function.prototype.call?

     Call используется для привязки определенного объекта к значению this вызываемой функции.

        const details = {
            message: 'Hello World!'
        };

        function getMessage() {
            return this.message;
        }

        getMessage.call(details); // Hello World!


     Этот метод похож на Function.prototype.apply. Отличие состоит в том, что в call аргументы передаются через запятую.      

36. В чем разница между методами call и apply?
    Отличие между call и apply состоит в том, как мы передаем аргументы в вызываемой функции. В apply аргументы передаются в виде массива, в call — через запятую.

    const obj1 = {
        result: 0
    }

    const obj2 = {
        result: 0
    }

    function reduceAdd() {
        let result = 0
        for (let i = 0, len = arguments.length; i < len; i++) {
            result += arguments[i]
        }
        this.result = result
    }

    reduceAdd.apply(obj1, [1, 2, 3, 4, 5]) // 15
    reduceAdd.call(obj2, 1, 2, 3, 4, 5) // 15

37. Для чего используется метод Function.prototype.bind?

    Bind возвращает новую функцию, значением this которой является объект, указанный в качестве первого параметра. В отличие от bind, call и apply сразу же вызывают функцию.   

38. Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?

    Функциональное программирование — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им передаются.

    Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования.

    Метод map возвращает новый массив с результатами вызова callback для каждого элемента массива:

    const words = ['Functional', 'Procedural', 'Object-Oriented']

    const wordsLength = words.map(word => word.length)


    Метод filter создает новый массив со всеми элементами, которые удовлетворяют условию, указанному в callback:

    const data = {
        {
            name: 'Mark',
            isRegistered: true
        } {
            name: 'Mary',
            isRegistered: false
        } {
            name: 'Mae',
            isRegistered: true
        }
    }

    const registeredUsers = data.filter(user => user.isRegistered)


    Метод reduce выполняет callback один раз для каждого элемента массива, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего callback), значение текущего элемента, текущий индекс и итерируемый массив:

    const strs = ['I', ' ', 'am', ' ', 'Iron', ' ', 'Man']
    const result = strs.reduce((acc, currentStr) => acc + str, '')

39. Что такое функции высшего порядка (Higher Order Functions)?

    Функция высшего порядка — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента.   

40. Почему функции в JS называют объектами первого класса (First-class Objects)?

    Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана.     
     
41. Как бы Вы реализовали метод Array.prototype.map?


        function map(arr, mapCallback) {
            // проверяем переданные параметры
            if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') {
                return []
            } else {
                let result = []
                // мы создаем массив с результатами при каждом вызове функции
                // поскольку мы не хотим менять оригинальный массив
                for (let i = 0, len = arr.length; i < len; i++) {
                    result.push(mapCallback(arr[i], i, arr))
                    // помещаем результаты mapCallback в result
                }
                return result
            }
        }


    Метод map создает новый массив с результатом вызова указанной функции для каждого элемента массива.      


42. Как бы Вы реализовали метод Array.prototype.filter?


        function filter(arr, filterCallback) {
            // проверяем передаваемые параметры
            if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') {
                return []
            } else {
                let result = []
                // ...
                for (let i = 0, len = arr.length; i < len; i++) {
                    // определяем соответствие возвращаемого результата заданному условию
                    if (filterCallback(arr[i], i, arr)) {
                        // помещаем значение, прошедшее фильтр, в result
                        result.push(arr[i])
                    }
                }
                return result
            }
        }

    Метод filter создает новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.    

43. Как бы Вы реализовали метод Array.prototype.reduce?


        function reduce(arr, reduceCallbak, initialValue) {
            // ..
            if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') {
                return []
            } else {
                // если в функцию не было передано значения initialValue, то
                let hasInitialValue = initialValue !== undefined
                let value = hasInitialValue ? initialValue : arr[0]
                // мы будем использовать первый элемент initialValue

                // затем мы перебираем массив, начиная с 1, если в функцию не передавалось значения initialValue, либо с 0, если значение было передано
                for (let i = hasInitialValue ? 0 : 1, len = arr.length; i < len; i++) {
                    // затем на каждой итерации мы присваиваем результат вызова reduceCallback переменной
                    value = reduceCallback(value, arr[i], i, arr)
                }
                return value
            }
        }


    Метод reduce применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.  

44. Что такое объект arguments?

    Arguments — это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство length, мы можем получить доступ к определенному значению с помощью arguments[i], но у него отсутствуют методы forEach, reduce, filter и map. Он позволяет узнать количество параметров функции.

    Преобразовать arguments в массив можно с помощью Array.prototype.slice:

    Array.prototype.slice.call(arguments)

    Запомните: в стрелочных функциях объект arguments не работает.

    function one() {
        return arguments
    }
    const two = function() {
        return arguments
    }
    const three = function three({
        return arguments
    })
    const four = () => arguments

    four() // arguments is not defined


    Вызов функции four приводит к ошибке ReferenceError: arguments is not defined. Эту проблему можно решить с помощью оператора rest:

    const four = (...args) => args
    Это автоматически поместит все параметры в массив.    

45. Как создать объект, не имеющий прототипа?

    Это можно сделать с помощью Object.create:

    const o1 = {}
    console.log(o1.toString) // [object Object]

    const o2 = Object.create(null) // в качестве первого параметра методу Object-create передается объект-прототип
    // нам не нужен объект-прототип, поэтому передаем null
    console.log(o2.toString) // o2.toString is not a function
          
46. Почему в представленном коде переменная b становится глобальной при вызове функции?


    function myFunc(){
        let a = b = 0
    }
    myFunc()


    Так происходит, потому что оператор присваивания ("=") имеет правостороннюю ассоциативность, т.е. присваивает значения справа налево. Поэтому код принимает следующий вид:

    function myFunc(){
        let a = (b = 0)
    }
    myFunc()


    Сначала значение 0 присваивается переменной «b», которая не объявлена. Движок JS делает ее глобальной. Возвращаемое выражением b = 0 значение (0) затем присваивается локальной переменной «a».

    Эту проблему можно решить сначала объявив локальные переменные, а затем присвоив им значения:

    function myFunc(){
        let a, b
        a = b = 0
    }
    myFunc()

47. Что такое ECMAScript?

    ECMAScript — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.    

48.  Что нового привнес в JS стандарт ES6 или ECMAScript2015?

        - Стрелочные функции (Arrow Functions).
        - Классы (Classes).
        - Шаблонные строки (Template Strings).
        - Расширенные объектные литералы (Enhanced Object literals).
        - Деструктуризация (Object Destructuring).
        - Промисы (Promises).
        - Генераторы (Generators).
        - Модули (Modules).
        - Symbol.
        - Прокси (Proxies).
        - Множества (Sets).
        - Параметры по умолчанию.
        - Операторы rest и spread.
        - Блочная область видимости (ключевые слова «let» и «const»).

49. В чем разница между ключевыми словами «var», «let» и «const»?

      Переменные, объявленные с помощью ключевого слова «var», являются глобальными. Это означает, что они доступны из любого места в коде:

      function giveMeX(showX){
          if(showX){
              var x = 5
          }
          return x
      }

      console.log(giveMeX(false))
      console.log(giveMeX(true))

      Результатом первого console.log будет undefined, второго — 5. Мы имеем доступ к переменной «x» из-за ее всплытия в глобальную область видимости. Код из примера выше интерпретируется следующим образом:

      function giveMeX(showX){
          var x // имеет значение undefined
          if(showX){
              x = 5
          }
          return x
      }

      Результатом первого console.log является undefined, поскольку объявленные переменные, которым не присвоено значения, имеют значение undefined по умолчанию.
      Переменные, объявленные с помощью ключевых слов «let» и «const» имеют блочную область видимости. Это означает, что они доступны только внутри блока ({ }):

      function giveMeX(showX){
          if(showX){
              let x = 5
          }
          return x
      }

      function giveMeY(showY){
          if(showY){
              let y = 5
          }
          return y
      }

      Вызов этих функций с параметром false приведет к ошибке ReferenceError, потому что к переменным «x» и «y» нет доступа снаружи блока и их значения не возвращаются (не всплывают).
      Разница между «let» и «const» состоит в том, что в первом случае мы может менять значение переменной, а во втором — нет (константа). При этом, мы можем менять значение свойства объекта, объявленного с помощью const, но не само свойство (переменную).        

50. Что такое стрелочные функции (Arrow Functions)?

    Стрелочная функция — это относительно новый способ создания функций в JS. Стрелочные функции создаются быстрее и имеют более читаемый синтаксис, чем функциональные выражения. В стрелочных функциях опускается слово «function»:

        // ES5
        var getCurrentDate = function(){
            return new Date()
        }

        // ES6
        const getCurrentDate = () => new Date()


    В функциональном выражении мы используем ключевое слово «return» для возврата значения. В стрелочной функции мы этого не делаем, поскольку стрелочные функции неявно возвращают значения при условии, что мы возвращаем одно выражение или значение:

        // ES5
        function greet(name){
            return 'Hello ' + name + '!' 
        }

        // ES6
        const greet = (name) => `Hello ${name}`
        const greet2 = name = > `Hello ${name}`


    Мы также можем передавать параметры стрелочным функциям. Если мы передаем один параметр, его можно не оборачивать в круглые скобки:

        const getArgs = () => arguments
        const getArgs2 = (...rest) => rest


    У стрелочных функций нет доступа к объекту arguments. Поэтому вызов первой функции приведет к ошибке. Для получения параметров, переданных функции, мы можем использовать оператор rest.

        const data = {
            result: 0
            nums: [1,2,3,4,5]
            computeResult(){
                // this ссылается на объект data
                const addAll = () => {
                // стрелочные функции копируют значение this из лексического окружения
                return this.nums.reduce((total, cur) => total + cur, 0)
                }
            this.result = addAll()
            }
        }
        
51. Что такое классы (Classes)?

    Классы — это относительно новый способ написания функций-конструкторов в JS. Это синтаксический сахар для функций-конструкторов. В основе классов лежат те же прототипы и прототипное наследование:



        // ES5
        function Person(firstName, lastName, age, address){
            this.firstName = firstName
            this.lastName = lastName
            this.age = age
            this.address = address
        }

        Person.self = function(){
            return this
        }

        Person.prototype.toString = function(){
            return '[object Person]'
        }

        Person.prototype.getFullName = function(){
            return this.firstName + ' ' + this.lastName
        }

        // ES6
        class Person{
            constructor(firstName, lastName, age, address){
                this.firstName = firstName
                this.lastName = lastName
                this.age = age
                this.address = address
            }

            static self(){
                return this
            }

            toString(){
                return '[object Person]'
            }

            getFullName(){
                return `${this.firstName} ${this.lastName}`
            }
        }


  Переопределение методов и наследование от другого класса:



        // ES5
        Employee.prototype = Object.create(Person.prototype)

        function Employee(firstName, lastName, age, address, jobTitle, yearStarted){
            Person.call(this, firstName, lastName, age, address)
            this.jobTitle = jobTitle
            this.yearStarted = yearStarted
        }

        Employee.prototype.describe = function(){
            return `I am ${this.getFullName()} and I have a position of #{this.jobTitle} and I started at ${this.yearStarted}}`
        }

        Employee.prototype.toString = function(){
            return '[object Employee]'
        }

        // ES6
        class Employee extends Person{ // наследуемся от Person
            constructor(firstName, lastName, age, address, jobTitle, yearStarted){
                super(firstName, lastName, age, address)
                this.jobTitle = jobTitle
                this.yearStarted = yearStarted
            }

            describe(){
              return `I am ${this.getFullName()} and I have a position of #{this.jobTitle} and I started at ${this.yearStarted}}` 
            }

            toString(){ // переопределяем метод toString класса Person
                return '[object Employee]'
            }
        }


  Как узнать об использовании прототипов?


        class Something{ }

        function AnotherSomething(){ }

        const as = new AnotherSomething()
        const s = new Something()

        console.log(typeof Something) // function
        console.log(typeof AnotherSomething) // function
        console.log(as.toString()) // [object Object]
        console.log(a.toString()) // [object Object]
        console.log(as.toString === Object.prototype.toString)
        console.log(a.toString === Object.prototype.toString)
        // в обоих случаях получаем true
        // Object.prototype находится на вершине цепочки прототипов
        // Something и AnotherSomething наследуют от Object.prototype
        

52. Что такое шаблонные литералы (Template Literals)?

    Шаблонные литералы — относительно новый способ создания строк в JS. Шаблонные литералы создаются с помощью двойных обратных кавычек (``):


        // ES5
        var greet = 'Hi I\'m Mark'

        // ES6
        let greet = `Hi I'm Mark`


    В шаблонных литералах нам не нужно экранировать одинарные кавычки.


        // ES5
        var lastWords = '\n'
            + ' I \n'
            + ' am \n'
            + 'Iron Man \n'

        // ES6
        let lastWords = `
            I
            am
            Iron Man
`


    В ES6 нам не нужно использовать управляющую последовательность "\n" для перевода строки.


        // ES5
        function greet(name){
            return 'Hello ' + name + '!'
        }

        // ES6
        function greet(name){
            return `Hello ${name}!`
        }


     В ES6 нам не нужно использовать конкатенацию строк для объединения текста с переменной: мы можем использовать выражение ${expr} для получения значения переменной.  


53. Что такое деструктуризация объекта (Object Destructuring)?

    Деструктуризация — относительно новый способ получения (извлечения) значений объекта или массива.

    Допустим, у нас есть такой объект:

        const employee = {
            firstName: 'Marko',
            lastName: 'Polo',
            position: 'Software Developer',
            yearHired: 2017
        }


    Раньше для получения свойств объекта мы создавали переменные для каждого свойства. Это было очень скучно и сильно раздражало:

        var firstName = employee.firstName
        var lastName = employee.lastName
        var position = employee.position
        var yearHired = employee.yearHired


    Использование деструктуризации позволяет сделать код чище и отнимает меньше времени. Синтаксис деструктуризации следующий: заключаем свойства объекта, которые хотим получить, в фигурные скобки ({ }), а если речь идет о массиве — в квадратные скобки ([ ]):

        let { firstName, lastName, position, yearHired } = employee


    Для изменения имени переменной следует использовать «propertyName: newName»:

        let { firstName: fName, lastName: lName, position, yearHired } = employee


    Для присвоения переменным значения по умолчанию следует использовать «propertyName = 'defaultValue'»:

        let { firstName = 'Mark', lastName: lName, position, yearHired } = employee


54. Что такое модули (Modules)?

    Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле. До появления модулей в JS существовало две популярные системы модулей для поддержки кода:

        CommonJS — Nodejs
        AMD (AsyncronousModuleDefinition) — Browsers


    Синтаксис модулей очень простой: мы используем import для импорта функциональности или значений из другого файла или файлов и export для экспорта.

    Экспорт функциональности в другой файл (именной экспорт):

        // ES5 CommonJS - helpers.js
        exports.isNull = function(val){
            return val === null
        }

        exports.isUndefined = function(val){
            return val === undefined
        }

        exports.isNullOrUndefined = function(val){
            return exports.isNull(val) || exports.isUndefined(val)
        }

        // ES6 модули
        export function isNull(val){
            return val === null;
        }

        export function isUndefined(val) {
            return val === undefined;
        }

        export function isNullOrUndefined(val) {
            return isNull(val) || isUndefined(val);
        }


    Импорт функциональности в другой файл:

        // ES5 CommonJS - index.js
        const helpers = require('./helpers.js')
        const isNull = helpers.isNull
        const isUndefined = helpers.isUndefined
        const isNullOrUndefined = helpers.isNullOrUndefined

        // либо с помощью деструктуризации
        const { isNull, isUndefined, isNullOrUndefined } = require('./helpers.js')

        // ES6 модули
        import * as helpers from './helpers.js' // helpers - это объект

        // либо
        import { isNull, isUndefined, isNullOrUndefined as isValid} from './helpers.js' // используем "as" для переименовывания


    Экспорт по умолчанию:

        // ES5 CommonJS - index.js
        class Helpers {
            static isNull(val){
                return val === null
            }

            static isUndefined(val){
                return val === undefined
            }

            static isNullOrUndefined(val){
                return this.isNull(val) || this.isUndefined(val)
            }
        }

        module.exports = Helpers

        // ES6 модули
        class Helpers {
            static isNull(val){
                return val === null
            }

            static isUndefined(val){
                return val === undefined
            }

            static isNullOrUndefined(val){
                return this.isNull(val) || this.isUndefined(val)
            }
        }

        export default Helpers


    Импорт:

        // ES5 CommonJS - index.js
        const Helpers = require('./helpers.js')
        console.log(Helpers.isNull(null))

        // ES6 модули
        import Helpers from './helpers.js'
        console.log(Helpers.isNull(null))


    Это базовое использование модулей. Я не стал вдаваться в подробности, поскольку мой пост и без того получается слишком большим.        

55. Что такое объект Set?

    Объект Set позволяет хранить уникальные значения, примитивы и ссылки на объекты. Еще раз: в Set можно добавлять только уникальные значения. Он проверяет хранящиеся в нем значения с помощью алгоритма SameZeroValue.

    Экземпляр Set создается с помощью конструктора Set. Мы также можем передать ему некоторые значения при создании:

        const set1 = new Set()
        const set2 = new Set(['a','b','c','d','d','e']) // вторая "d" не добавится


    Мы можем добавлять значения в Set, используя метод add. Поскольку метод add является возвращаемым, мы может использовать цепочку вызовов:

        set2.add('f')
        set2.add('g').add('h').add('i').add('j').add('k').add('k') // вторая "k" не добавится


    Мы можем удалять значения из Set, используя метод delete:

        set2.delete('k') // true
        set2.delete('z') // false, потому что в set2 нет такого значения


    Мы можем проверить наличие свойства в Set, используя метод has:

        set2.has('a') // true
        set2.has('z') // false


    Для получения длины Set используется метод size:

        set2.size // 10


    Метод clear очищает Set:

        set2.clear() // пусто


    Мы можем использовать Set для удаления повторяющихся значений в массиве:

        const nums = [1,2,3,4,5,6,6,7,8,8,5]
        const uniqNums = [...new Set(nums)] // [1,2,3,4,5,6,7,8]


56. Что такое функция обратного вызова (Callback Function)?

    Функция обратного вызова — это функция, вызов которой отложен на будущее (происходит при некоторых условиях, например, при наступлении события).

        const btnAdd = document.getElementById('btnAdd')

        btnAdd.addEventListener('click', function clickCallback(e)){
            // делаем нечто полезное
        }


    В примере мы ждем события «клик» на элементе с идентификатором «btnAdd». По клику вызывается функция clickCallback. Функция обратного вызова добавляет некоторый функционал данным или событию. Методам reduce, filter и map в качестве второго аргумента передается функция обратного вызова. 

57. Что такое промисы (Promises)?

    Промисы — это один из приемов работы с асинхронным кодом в JS. Они возвращают результат асинхронной операции. Промисы были придуманы для решения проблемы так называемого «ада функций обратного вызова».

        fs.readFile('somefile.txt', function(e, data){
            if(e){
                console.log(e)
            }
            console.log(data)
        })


    Проблемы при таком подходе начинаются, когда нам необходимо добавить еще одну асинхронную операцию в первую (внутрь первой), затем еще одну и т.д. В результате мы получаем беспорядочный и нечитаемый код:

        fs.readFile('somefile.txt', function(e,data){
            // код
            fs.readFile('directory', function(e, files){
                // код
                fs.mkdir('directory', function(e){
                    // код
                })
            })
        })


    А вот как это выглядит с промисами:

        promReadFile('file/path')
        .then(data => {
            return promReaddir('directory')
        })
        .then(data => {
            return promMkdir('directory')
        })
        .catch(e => {
            console.error(e)
        })


    У промиса есть четыре состояния:

        Ожидание — начальное состояние промиса. Результата промиса неизвестен, поскольку операция не завершена.
        Выполнено — асинхронная операция выполнена, имеется результат.
        Отклонено — асинхронная операция не выполнена, имеется причина.
        Завершено — выполнено или отклонено.


    В качестве параметров конструктор промиса принимает resolve и reject. В resolve записывается результат выполнения операции, в reject — причина невыполнения операции. Результат может быть обработан в методе .then, ошибка — в методе .catch. Метод .then также возвращает промис, поэтому мы можем использовать цепочку, состоящую из нескольких .then.

        const myPromiseAsync = (...args) => {
            return new Promise((resolve, reject) => {
                doSomeAsync(...args, (error, data) => {
                    if(error){
                        reject(error)
                    } else{
                        resolve(data)
                    }
                })
            })
        }

        myPromiseAsync()
        .then(result => {
            console.log(result)
        })
        .catch(reason => {
            console.error(reason)
        })


    Мы можем создать вспомогательную функцию для преобразования асинхронной операции с callback в промис. Она будет работать наподобие util из Node.js («промисификация»):

        const toPromise = (asyncFuncWithCallback) => {
            return (...args) => {
                return new Promise((res, rej) => {
                    asyncFuncWithCallback(...args, (e, result) => {
                        return e ? rej(e) : res(result)
                    })
                })
            }
        }

        const promiseReadFile = toPromise(fs.readFile)

        promiseReadFile('file/path')
        .then((data) => {
            console.log(data)
        })
        .catch(e => console.error(e))


58. Что такое async/await?

    Async/await — относительно новый способ написания асинхронного (неблокирующего) кода в JS. Им оборачивают промис. Он делает код более читаемым и чистым, чем промисы и функции обратного вызова. Однако для использования async/await необходимо хорошо знать промисы.

        // промис
        function callApi(){
            return fetch('url/to/api/endpoint')
            .then(resp => resp.json())
            .then(data => {
                // работаем с данными
            }).catch(err => {
                // работаем с ошибкой
            })
        }

        // async/await
        // для перехвата ошибок используется try/catch
        async function callApi(){
            try{
                const resp = await fetch('url/to/api/endpoint')
                const data = await res.json()
                // работаем с данными
            } catch(e){
                // работаем с ошибкой
            }
        }


    Запомните: использование ключевого слова «async» перед функцией заставляет ее возвращать промис:

        const giveMeOne = async () = 1

        giveMeOne()
        .then((num) => {
            console.log(num) // 1
        })


    Ключевое слово «await» можно использовать только внутри асинхронной функции. Использование «await» внутри другой функции приведет к ошибке. Await ожидает завершения выражения справа, чтобы вернуть его значение перед выполнением следующей строчки кода.

        const giveMeOne = async() => 1

        function getOne(){
            try{
                const num = await giveMeOne()
                console.log(num)
            } catch(e){
                console.log(e)
            }
        }
        // Uncaught SyntaxError: await is only valid in an async function

        async function getTwo(){
            try{
                const num1 = await giveMeOne()
                const nm2 = await giveMeOne()
                return num1 + num2
            } catch(e){
                console.log(e)
            }
        }

        await getTwo() // 2

59. В чем разница между spread-оператором и rest-оператором?

    Операторы spread и rest имеют одинаковый синтаксис ("..."). Разница состоит в том, что с помощью spread мы передаем или распространяем данные массива на другие данные, а с помощью rest — получаем все параметры функции и помещаем их в массив (или извлекаем часть параметров).

        function add(a, b){
            return a + b
        }

        const nums = [5, 6]
        const sum = add(...nums)
        console.log(sum) // 11


    В этом примере мы используем spread при вызове функции add с данными массива nums. Значением переменной «a» будет 5, b = 6, sum = 11.

        function add(...rest){
            return rest.reduce((total, current) => total + current)
        }

        console.log(add(1, 2)) // 3
        console.log(add(1, 2, 3, 4, 5)) // 15


    Здесь мы вызываем функцию add с любым количеством аргументов. Add возвращает сумму этих аргументов.

        const [first, ...others] = [1, 2, 3, 4, 5]
        console.log(first) // 1
        console.log(others) // [2, 3, 4, 5]


    В этом примере мы используем rest для помещения любого количества параметров, кроме первого, в массив others.

60. Что такое параметры по умолчанию (Default Parameters)?

    Это относительно новый способ определения значений переменных по умолчанию.

        // ES5
        function add(a,b){
            a = a || 0
            b = b || 0
            return a + b
        }

        // ES6
        function add(a = 0, b = 0){
            return a + b
        }
        // если мы не присвоим переменным "a" и "b" какие-нибудь значения, они будут равняться 0
        add(1) // 1


    Можно использовать деструктуризацию:

        function getFirst([first, ...rest] = [0, 1]){
            return first
        }

        getFirst() // 0
        getFirst([10,20,30]) // 10

        function getArr({ nums } = { nums: [1,2,3,4] }){
            return nums
        }

        getArr // [1,2,3,4]
        getArr({nums:[5,4,3,2,1]}) // [5,4,3,2,1]


    Мы даже можем использовать по умолчанию параметры, объявленные в том же месте:

        function doSomethingWithValue(value = 'Hello World', callback = () => { console.log(value) }){
            callback()
        }
        doSomethingWithValue() // Hello World

61. Что такое объектная обертка (Wrapper Objects)?

    Примитивы строка, число и boolean имеют свойства и методы, несмотря на то, что они не являются объектами:

        let name = 'marko'

        console.log(typeof name) // string
        console.log(name.toUpperCase()) // MARKO


    Name — это строка (примитивный тип), у которого нет свойств и методов, но когда мы вызываем метод toUpperCase(), это приводит не к ошибке, а к «MARKO».

    Причина такого поведения заключается в том, что name временно преобразуется в объект. У каждого примитива, кроме null и undefined, есть объект-обертка. Такими объектами являются String, Number, Boolean, Symbol и BigInt. В нашем случае код принимает следующий вид:

        console.log(new String(name).toUpperCase()) // MARKO


    Временный объект отбрасывается по завершении работы со свойством или методом.        
    

62.   В чем разница между явным и неявным преобразованием или приведением к типу (Implicit and     Explicit Coercion)?

      Неявное преобразование — это способ приведения значения к другому типу без нашего ведома (участия).

      Предположим, у нас есть следующее:

            console.log(1 + '6')
            console.log(false + true)
            console.log(6 * '2')

        Результатом первого console.log будет 16. В других языках это привело бы к ошибке, но в JS 1 конвертируется в строку и конкатенируется (присоединяется) c 6. Мы ничего не делали, преобразование произошло автоматически.

        Результатом второго console.log будет 1. False было преобразовано в 0, true — в 1. 0 + 1 = 1.

        Результатом третьего console.log будет 12. Строка 2 была преобразована в число перед умножением на 6.

        Явное преобразование предполагает наше участие в приведении значения к другому типу:

            console.log(1 + parseInt('6'))

       В этом примере мы используем parseInt для приведения строки 6 к числу, затем складываем два числа и получаем 7.  

63. Что такое NaN? Как проверить, является ли значение NaN?

    NaN или Not A Number (не число) — это значение, получаемое в результате выполнения числовой операции над нечисловым значением:


            let a
            console.log(parseInt('abc'))
            console.log(parseInt(null))
            console.log(parseInt(undefined))
            console.log(parseInt(++a))
            console.log(parseInt({} * 10))
            console.log(parseInt('abc' - 2))
            console.log(parseInt(0 / 0))
            console.log(parseInt('10a' * 10))

    В JS есть встроенный метод isNaN, позволяющий проверять, является ли значение NaN, но он ведет себя довольно странно:

            console.log(isNaN()) // true
            console.log(isNaN(undefined)) // true
            console.log(isNaN({})) // true
            console.log(isNaN(String('a'))) // true
            console.log(isNaN(() => { })) // true

    Результатом всех console.log является true, несмотря на то, что ни одно из значений не является NaN.

    ES6 для проверки, является ли значение NaN, рекомендует использовать метод Number.isNaN. Мы также можем написать вспомогательную функцию для решения проблемы «неравенства NaN самому себе»:

            function checkIsNan(value){
            return value !== value
            }   


64. Как проверить, является ли значение массивом?

    Для этого следует использовать метод Array.isArray:

            console.log(Array.isArray(5)) // false
            console.log(Array.isArray('')) // false
            console.log(Array.isArray()) // false
            console.log(Array.isArray(null)) // false
            console.log(Array.isArray( {length: 5 })) // false
            console.log(Array.isArray([])) // true

    Если среда, в которой Вы работаете, не поддерживает данный метод, можете использовать такой полифил:

            function isArray(value){
                return Object.prototype.toString.call(value) === '[object Array]'
            } 


65. Как проверить, что число является четным, без использования деления по модулю или деления с остатком (оператора "%")?

    Для решения данной задачи можно использовать оператор "&" (бинарное и). Оператор "&" сравнивает операнды как бинарные значения.

        function isEven(num){
            if(num & 1){
                return false
            } else{
                return true
            }
        }

    Console.log(5 & 1) вернет 1. Сначала оператор "&" конвертирует оба числа в бинарные значения, 5 превращается в 101, 1 — в 001. Затем производится побитовое сравнение:

        Сравниваем 1 и 0, получаем 0.
        Сравниваем 0 и 0, получаем 0.
        Сравниваем 1 и 1, получаем 1.
        Преобразуем бинарное значение в целое число, получаем 1.

    Если эта информация кажется Вам слишком сложной, мы можем решить поставленную задачу с помощью рекурсивной функции:

        function isEven(num){
            if(num < 0 || num === 1) return false
            if(num == 0) return true
            return isEven(num - 2)
        }   

66. Как определить наличие свойства в объекте?

    Существует три способа это сделать.
    Первый способ состоит в использовании оператора «in»:

        const o = {
            'prop': 'bwahahah',
            'prop2': 'hweasa'
        }

    console.log('prop' in o) // true
    console.log('prop1' in o) // false

    Второй — использовать метод hasOwnProperty:

        console.log(o.hasOwnProperty('prop2')) // true
        console.log(o.hasOwnProperty('prop1')) // false

    Третий — индексная нотация массива:

        console.log(o['prop']) // bwahahah
        console.log(o['prop1']) // undefined  

67. Что такое AJAX?

    AJAX или Asyncronous JavaScript and XML — это набор взаимосвязанных технологий, которые позволяют работать с данными в асинхронном режиме. Это означает, что мы можем отправлять данные на сервер и получать данные с него без перезагрузки веб-страницы.
    AJAX использует следующие технологии:
    HTML — структура веб-страницы.
    CSS — стили веб-страницы.
    JavaScript — поведение страницы и работа с DOM.
    XMLHttpRequest API — отправка и получение данных с сервера.
    PHP, Python, Nodejs — какой-нибудь серверный язык. 

68. Как в JS создать объект?
    Объектный литерал:

        const o = {
            name: 'Mark',
            greeting(){
                return `Hi, I'm ${this.name}`
            }
        }
        o.greeting // Hi, I'm Mark


    Функция-конструктор:

        function Person(name){
            this.name = name
        }
        Person.prototype.greeting = function(){
            return `Hi, I'm ${this.name}`
        }
        const mark = new Person('Mark')
        mark.greeting() // Hi, I'm Mark


    Метод Object.create:

        const n = {
            greeting(){
                return `Hi, I'm ${this.name}`
            }
        }

        const o = Object.create(n)
        o.name = 'Mark'
        console.log(o.greeting) // Hi, I'm Mark 

69. В чем разница между методами Object.freeze и Object.seal?

    Разница заключается в том, что при использовании метода Object.freeze мы не можем менять или редактировать свойства объекта, а при использовании Object.seal у нас такая возможность имеется.     


70. В чем разница между оператором «in» и методом hasOwnProperty?

    Отличие состоит в том, что оператор «in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод hasOwnProperty — только в объекте.

        console.log('prop' in o) // true
        console.log('toString' in o) // true

        console.log(o.hasOwnProperty('prop')) // true
        console.log(o.hasOwnProperty('toString')) // false    


71. Какие приемы работы с асинхронным кодом в JS Вы знаете?

      - Функции обратного вызова (Callbacks).
      - Промисы (Promises).
      - Async/await.
      - Библиотеки вроде async.js, blueprint, q, co.    


72. В чем разница между обычной функцией и функциональным выражением?

    Допустим, у нас есть следующее:

        hoistedFunc()
        notHoistedFunc()

        function hoistedFunc(){
            console.log('I am hoisted')
        }

        var notHoistedFunc = function(){
            console.log('I will not be hoisted!')
        }

    Вызов notHoistedFunc приведет к ошибке, а вызов hoistedFunc нет, потому что hoistedFunc «всплывает», поднимается в глобальную область видимости, а notHoistedFunc нет.  


73. Как в JS вызвать функцию?

    В JS существует 4 способа вызвать функцию. Вызов определяет значение this или «владельца» функции.

    - Вызов в качестве функции. Если функция вызывается как метод, конструктор или с помощью методов apply или call, значит она вызывается как функция. Владельцем такой функции является объект window:

        function add(a,b){
            console.log(this)
            return a + b
        }

        add(1,5) // window, 6

        const o = {
            method(callback){
                callback()
            }
        }

        o.method(function(){
            console.log(this) // window
        })


    - Вызов в качестве метода. Когда функция является свойством объекта, мы называем ее методом. Когда вызывается метод, значением this становится объект этого метода:

          const details = {
              name: 'Marko',
              getName(){
                  return this.name
              }
          }
          details.getName() // Marko, значением this является объект details


    - Вызов в качестве конструктора. Когда функция вызывается с использованием ключевого слова «new», мы называем такую функцию конструктором. При этом создается пустой объект, являющийся значением this:

        function Employee(name, position, yearHired){
            // создается пустой объект, являющийся значением this
            // this = {}
            this.name = name
            this.position = position
            this.yearHired = yearHired
            // наследование от Employee.prototype неявно возвращает this, если не указано иное
        }

        const emp = new Employee('Marko Polo', 'Software Development', 2017)

    - Вызов с помощью методов apply или call. Мы используем эти методы, когда хотим явно определить значение this или владельца функции:

        const obj1 = {
            result: 0
        }

        const obj2 = {
            result: 0
        }

        function reduceAdd(){
            let result = 0
            for(let i = 0, len = arguments.length; i < len; i++){
                result += arguments[i]
            }
            this.result = result
        }

        reduceAdd.apply(obj1, [1,2,3,4,5]) // значением this является obj1
        reduceAdd.call(obj2, 1,2,3,4,5) // значением this является obj2    


74. Что такое запоминание или мемоизация (Memoization)?

    Мемоизация — это прием создания функции, способной запоминать ранее вычисленные результаты или значения. Преимущество мемоизации заключается в том, что мы избегаем повторного выполнения функции с одинаковыми аргументами. Недостатком является то, что мы вынуждены выделять дополнительную память для сохранения результатов.  


75. Почему typeof null возвращает object? Как проверить, является ли значение null?

    typeof null == 'object' всегда будет возвращать true по историческим причинам. Поступало предложение исправить эту ошибку, изменив typeof null = 'object' на typeof null = 'null', но оно было отклонено в интересах сохранения обратной совместимости (такое изменение повлекло бы за собой большое количество ошибок).

    Для проверки, является ли значение null можно использовать оператор строгого равенства (===):

        function isNull(value){
            return value === null
        }      

76. Для чего используется ключевое слово «new»?

    Ключевое слово «new» используется в функциях-конструкторах для создания нового объекта (нового экземпляра класса).

    Допустим, у нас есть такой код:

        function Employee(name, position, yearHired){
            this.name = name
            this.position = position
            this.yearHired = yearHired
        }

        const emp = new Employee('Marko Polo', 'Software Development', 2017)

    Ключевое слово «new» делает 4 вещи:

    - Создает пустой объект.
    - Привязывает к нему значение this.
    - Функция наследует от functionName.prototype.
    - Возвращает значение this, если не указано иное.   

77. Недостатки MVVM
    А вот недостатки, в отличие от "достоинств", вполне реальны и ощутимы.

    - Сильное зацепление (tight coupling)
      Есть смысл разделять один модуль на несколько под-модулей в том случае, когда у них разная зона ответственности. В идеале, изменения в одном модуле никак не должны влиять на другой модуль.
      На практике, однако, View и ViewModel сильно cцеплены (coupled), а изменения в требованиях к UI приводят к изменениям в обоих классах.
      Представьте, что у нас есть экран профиля с кнопкой Log out. В первой итерации всё просто: нажимаем на кнопку – заканчивается сессия. В следующем спринте к вам подходит дизайнер и говорит: "Слушай, надо добавить диалог с подтверждением". Изменения придется вносить как во ViewModel (изменяется логика работы), так и во View (он теперь должен реагировать на запрос диалога).

    - Сложности с тестированием
      Если у нас View и ViewModel – это разные классы, нам понадобится по крайней мере два типа тестов:

      Для ViewModel – убедиться, что она дергает правильные методы бизнес-логики и правильно преобразует данные для презентации.
      Для View – проверить правильность отображения данных презентационной модели. А выше мы уже обсуждали, что в нативном Андроиде UI-тесты – это очень больно. Так что, скорее всего, это часть кода будет не очень хорошо покрыта тестами.
      В случае с виджетами, нам нужен тест виджета. И смысла в этом гораздо больше, так как мы можем протестировать ожидаемый результат, а не внутреннюю логику.
      Вы же помните правило для написания хороших комментариев? Не комментируйте, как работает код, пишите, почему это так сделано. То же и с тестами: не надо тестировать, как работает система, проверяйте, выдает ли она ожидаемый результат.
      В случае с диалогом подтверждения – мне не важно, вызывает ли нажатие на кнопку метод onLogoutButtonClicked. Мне нужно знать, что если я нажму на кнопку, появится диалог.
      Повторюсь, в нативном Андроиде с этим всё сложно, во Flutter'е – гораздо проще.

    - Больше кода
      Естественно, больше сущностей – больше кода (как правило). Само по себе это не страшно, многие хорошие практики вообще-то увеличивают количество кода. Но это имеет смысл лишь в том случае, когда большее количество кода компенсируется лучшей читаемостью или поддерживаемостью. Иначе это просто больше кода.  

78. Разница между функцией и методом?
    Разница между методом и функцией лишь в том, что методы - это функции, определённые внутри объектов. Встроенные функции (методы) браузера и переменные (так называемые свойства) хранятся внутри структурированных объектов, чтобы сделать код более эффективным и более простым в использовании.       


79. Что такое каррирование (Currying)?

    Каррирование или карринг (currying) в функциональном программирование — это преобразование функции с множеством аргументов в набор вложенных функций с одним аргументом. При вызове каррированной функции с передачей ей одного аргумента, она возвращает новую функцию, которая ожидает поступления следующего аргумента. Новые функции, ожидающие следующего аргумента, возвращаются при каждом вызове каррированной функции — до тех пор, пока функция не получит все необходимые ей аргументы. Ранее полученные аргументы, благодаря механизму замыканий, ждут того момента, когда функция получит всё, что ей нужно для выполнения вычислений. После получения последнего аргумента функция выполняет вычисления и возвращает результат.

    Говоря о каррировании, можно сказать, что это процесс превращения функции с несколькими аргументами в функцию с меньшей арностью.

    Арность — это количество аргументов функции. Например — вот объявление пары функций:

        function fn(a, b) {
            //...

        }
        function _fn(a, b, c) {
            //...

        }

    Функция fn принимает два аргумента (это бинарная или 2-арная функция), функция _fn принимает три аргумента (тернарная, 3-арная функция).
    Поговорим о ситуации, когда, в ходе каррирования, функция с несколькими аргументами преобразуется в набор функций, каждая из которых принимает один аргумент.

    Рассмотрим пример. У нас имеется следующая функция:

        function multiply(a, b, c) {
            return a * b * c;
        }

    Она принимает три аргумента и возвращает их произведение:

        multiply(1,2,3); // 6

    Теперь подумаем о том, как преобразовать её к набору функций, каждая из которых принимает один аргумент. Создадим каррированный вариант этой функции и посмотрим на то, как получить тот же результат в ходе вызова нескольких функций:

        function multiply(a) {
            return (b) => {
                return (c) => {
                    return a * b * c
                }
            }
        }
        log(multiply(1)(2)(3)) // 6

    Как видите, здесь мы преобразовали вызов единственной функции с тремя аргументами — multiply(1,2,3) к вызову трёх функций — multiply(1)(2)(3).

    Оказывается, что одна функция превратилась в несколько функций. При использовании новой конструкции каждая функция, кроме последней, возвращающей результат вычислений, принимает аргумент и возвращает другую функцию, также способную принять аргумент и возвратить другую функцию. Если конструкция вида multiply(1)(2)(3) кажется вам не слишком понятной, давайте, чтобы лучше в этом разобраться, распишем её в таком виде:

        const mul1 = multiply(1);
        const mul2 = mul1(2);
        const result = mul2(3);
        log(result); // 6

    Теперь построчно разберём то, что здесь происходит.
    Сначала мы передаём аргумент 1 функции multiply:

        const mul1 = multiply(1);

    При работе этой функции срабатывает такая конструкция:

        return (b) => {
                return (c) => {
                    return a * b * c
                }
            }

    Теперь в mul1 имеется ссылка на функцию, принимающую аргумент b. Вызовем функцию mul1, передав ей 2:

        const mul2 = mul1(2);

    В результате этого вызова выполнится следующий код:

        return (c) => {
                    return a * b * c
                }

    Константа mul2 будет содержать ссылку на функцию, которая могла бы оказаться в ней, например, в результате выполнения следующей операции:

        mul2 = (c) => {
                    return a * b * c
                }

    Если теперь вызвать функцию mul2, передав ей 3, то функция выполнит необходимые вычисления, воспользовавшись аргументами a и b:

        const result = mul2(3);

    Результатом этих вычислений будет 6:

        log(result); // 6

    Функция mul2, обладающая самым большим уровнем вложенности, имеет доступ к областям видимости, к замыканиям, формируемым функциями multiply и mul1. Именно поэтому в функции mul2 можно производить вычисления с переменными, объявленными в функциях, выполнение которых уже завершено, которые уже возвратили некие значения и обработаны сборщиком мусора.

    Выше мы рассмотрели абстрактный пример, а вот, в сущности, такая же функция, которая предназначена для вычисления объёма прямоугольного параллелепипеда.

        function volume(l,w,h) {
            return l * w * h;
        }
        const vol = volume(100,20,90) // 180000

    Вот как выглядит её каррированный вариант:

        function volume(l) {
            return (w) => {
                return (h) => {
                    return l * w * h
                }
            }
        }
        const vol = volume(100)(20)(90) // 180000

    Итак, каррирование базируется на следующей идее: на основе некоей функции создают другую функцию, которая возвращает специализированную функцию.


80. Плюсы и минусы ФП и ООП?
    
    Плюсы ООП: простая для понимания концепция объектов и методов вызова. ООП стремится использовать императивный стиль, нежели декларативный, который читается как прямой набор машинных инструкций.

    Минусы ООП: как правило, присутствует зависимость от общих состояний. Объекты и их поведение связаны одной сущностью, к которой случайно может быть получен доступ любым количеством функций в неопределенном порядке, что может привести к непредсказуемому поведению, например, состоянию гонки.

    Плюсы ФП: используется функциональная парадигма, позволяющая избежать общих состояний и нежелательных эффектов, исключаются ошибки, возможные из-за конкурирования функций. Благодаря таким фичам, как неявное программирование, функции, как правило, радикально упрощаются и легко перестраиваются для более легкого, по сравнению с ООП, повторного использования кода.

    Вычисления, использующие чистые функции легко масштабируются на несколько процессоров или распределенных вычислительных кластеров без опасения возникновения борьбы за ресурсы.

    Минусы ФП: чрезмерная эксплуатация функциональных подходов, вроде неявного программирования, может привести к снижению читабельности кода, так как конечный код получается более абстрактным, кратким и менее конкретным.

    Чаще люди больше знакомы с ООП и императивным подходом, так что некоторые общие идиомы функционального программирования могут вызывать трудности у новичков.

    Функциональное программирование имеет более крутую кривую обучения, нежели ООП, имеющего большую популярность и более понятного для изучения. Концепции ФП часто описываются идиомами и обозначениями из лямбда-исчислений, алгебры и теории категорий, требующих знаний основ в этих областях для понимания.

    Хорошо упомянуть:

    1. Проблемы общих состояний, нежелательного поведения

    2. Возможности ФП по радикальному упрощению кода программ

    3. Разность в сложности изучения

    4. Побочные эффекты и их влияние на надежность программ

    5. Сложность изменения и общая хрупкость базы ОО кода в сравнении с таковой в функциональном стиле

    Следует избегать:

    Не упомянуть недостатки одного из подходов – каждый, кто сталкивался с одним из них, знает и о паре-другой недостатков


81. Каковы плюсы и минусы монолитной архитектуры и микросервисов?

    - Монолитная архитектура означает, что ваше приложение написано как единый связный блок кода, чьи компоненты спроектированы для совместной работы и использования общих ресурсов.    

      * Преимущества монолитной архитектуры: основным преимуществом монолитной архитектуры является то, что большинство приложений, как правило, имеют множество общих проблем, таких как логирование, ограничение скорости и необходимость функций безопасности – в едином приложении для каждого компонента их проще решать.

      * Минусы монолитного приложения: так как все компоненты тесно связаны друг с другом, по мере развития приложения, становится труднее его понимать, появляется много неочевидных зависимостей и побочных эффектов.


    - Подход микросервисов подразумевает, что приложение состоит из множества небольших независимых приложений, способных работать с собственными ресурсами и потенциально на большом количестве отдельных машин.

      * Плюсы микросервисов: микросервисы обычно лучше организованы, так как каждый компонент выполняет свою задачу и работает независимо от каждого другого компонента. Приложение на основе обособленных компонентов также проще переконфигурировать и изменять.

      * Минусы микросервисов: при создании нового микросервиса может появится много внезапных проблем, которые не ожидались при проектировании. Для монолитного приложения можно использовать промежуточное программное обеспечение для решения различных сквозных проблем без особых трудозатрат.

    При микросервисной архитектуре либо потребуются накладные расходы на отдельные модули для каждой сквозной проблемы, либо нужно инкапсулировать их на другом уровне обслуживания, через который проходит весь трафик.

    В конце концов, даже монолитные архитектуры имеют тенденцию направлять трафик через внешний уровень обслуживания, но с монолитной архитектурой можно отложить затраты на эту работу до тех пор, пока проект не станет более зрелым.

    Микросервисы же часто развертываются в собственных виртуальных машинах или контейнерах, что приводит к быстрому увеличению числа конфликтов по виртуальным ресурсам.

    Хорошо упомянуть:

    1. Несмотря на начальную дороговизну, микросервисы выигрывают в долгосрочной перспективе за счет лучшего масштабирования

    2. Практические различия микросервисов и монолитных приложений


    Следует избегать:

    1. Незнание различий архитектур

    2. Незнание недостатков микросервисов

    3. Недооценивать преимущества масштабирования микросервисов


82. Какие принципы можно использовать вместе с наследованием?

    Используйте следующее вместе с наследованием
    - Делегация — перепоручение задачи от внешнего объекта внутреннему
    - Композиция — включение объектом-контейнером объекта-содержимого и управление его поведением; последний не может существовать вне первого
    - Агрегация — включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование    


83. Какие ещё принципы кроме SOLID вы знаете?

    1. YAGNI
    You Aren’t Gonna Need It / Вам это не понадобится

    Этот принцип прост и очевиден, но ему далеко не все следуют. Если пишете код, то будьте уверены, что он вам понадобится. Не пишите код, если думаете, что он пригодится позже.
    Этот принцип применим при рефакторинге. Если вы занимаетесь рефакторингом метода, класса или файла, не бойтесь удалять лишние методы. Даже если раньше они были полезны – теперь они не нужны.

    2. DRY
    Don’t Repeat Yourself / Не повторяйтесь

    Эта концепция была впервые сформулирована в книге Энди Ханта и Дэйва Томаса «Программист-прагматик: путь от подмастерья к мастеру».
    Идея вращается вокруг единого источника правды (single source of truth — SSOT). Что это вообще такое?
    В проектировании и теории информационных систем единый источник истины (SSOT) – это практика структурирования информационных моделей и схемы данных, которая подразумевает, что все фрагменты данных обрабатываются (или редактируются) только в одном месте… SSOT предоставляют достоверные, актуальные и пригодные к использованию данные.

    Использование SSOT позволит создать более прочную и понятную кодовую базу.
    Дублирование кода – пустая трата времени и ресурсов. Вам придется поддерживать одну и ту же логику и тестировать код сразу в двух местах, причем если вы измените код в одном месте, его нужно будет изменить и в другом.
    В большинстве случаев дублирование кода происходит из-за незнания системы. Прежде чем что-либо писать, проявите прагматизм: осмотритесь. Возможно, эта функция где-то реализована. Возможно, эта бизнес-логика существует в другом месте. Повторное использование кода – всегда разумное решение.

    3. KISS
    Keep It Simple, Stupid / Будь проще

    Этот принцип был разработан ВМС США в 1960 году. Этот принцип гласит, что простые системы будут работать лучше и надежнее.
    У этого принципа много общего с переизобретением колеса, которым занимались в 1970-х. Тогда он звучал как деловая и рекламная метафора.
    Применительно к разработке ПО он значит следующее – не придумывайте к задаче более сложного решения, чем ей требуется.
    Иногда самое разумное решение оказывается и самым простым. Написание производительного, эффективного и простого кода – это прекрасно.
    Одна из самых распространенных ошибок нашего времени – использование новых инструментов исключительно из-за того, что они блестят. Разработчиков следует мотивировать использовать новейшие технологии не потому, что они новые, а потому что они подходят для работы.

    4. Big Design Up Front
    Глобальное проектирование прежде всего

    Этот подход к разработке программного обеспечения очень важен, и его часто игнорируют. Прежде чем переходить к реализации, убедитесь, что все хорошо продумано.    

    Многие разработчики считают, что если они не пишут код, то они не добиваются прогресса. Это неверный подход. Составив план, вы избавите себя от необходимости раз за разом начинать с нуля.

    Иногда в недостатках и процессах разработки архитектуры должны быть замешаны и другие люди. Чем раньше вы все это обсудите, тем лучше будет для всех.

    Очень распространенный контраргумент заключается в том, что стоимость решения проблем зачастую ниже стоимости времени планирования. Чем с меньшим количеством ошибок столкнется пользователь, тем лучше будет его опыт. У вас может не быть другого шанса справиться с этими ошибками.

    5. SOLID

    Это наиболее известный принцип разработки ПО. Solid — это аббревиатура от:

    S) Single-responsibility principle /Принцип единственной ответственности

    Его важность невозможно переоценить. Каждый объект, класс и метод должны отвечать только за что-то одно. Если ваш объект/класс/метод делает слишком много, вы получите спагетти-код. Вот пример:

    const saveTodo = async () => {
        try {
            response = await saveTodoApi(); 
            showSuccessPop('Success'); 
            window.location.href = '/successPage';
        } catch (error) { 
            showErrorPopup(`Error: ${error} `);
        }
    }

    Этот метод кажется безобидным, но на самом деле он делает слишком много:

    Сохраняет объект
    Обрабатывает уведомление в UI
    Выполняет навигацию

    Еще один побочный эффект такого кода – проблемы с тестированием. Запутанный функционал тестировать сложно.

    O) Open–closed principle / Принцип открытости-закрытости

    Программные объекты должны быть открыты для расширения, но закрыты для модификации. Речь о том, что нельзя переопределять методы или классы, просто добавляя дополнительные функции по мере необходимости.

    Хороший способ решения этой проблемы – использование наследования. В JavaScript эта проблема решается с помощью композиции.

    Простое правило: если вы изменяете сущность, чтобы сделать ее расширяемой, вы впервые нарушили этот принцип.

    L) Liskov substitution principle / Принцип подстановки Лисков

    Этот принцип гласит, что объекты старших классов должны быть заменимы объектами подклассов, и приложение при такой замене должно работать так, как ожидается.

    I) Interface segregation principle / Принцип разделения интерфейсов

    Этот принцип был сформулирован Робертом Мартином, когда он консультировал Xerox, и он очевиден.

    Объекты не должны зависеть от интерфейсов, которые они не используют


    ПО должно разделяться на независимые части. Побочные эффекты необходимо сводить к минимуму, чтобы обеспечивать независимость.

    Убедитесь, что вы не заставляете объекты реализовывать методы, которые им никогда не понадобятся. Вот пример:

        interface Animal {
          eat: () => void;
          walk: () => void;
          fly: () => void;
          swim: () => void;
        }

    Не все животные могут fly, walk или swim, поэтому эти методы не должны быть частью интерфейса или должны быть необязательными.

    D) Dependency inversion principle / Принцип инверсии зависимостей

    Этот принцип невозможно переоценить. Мы должны полагаться на абстракции, а не на конкретные реализации. Компоненты ПО должны иметь низкую связность и высокую согласованность.
    Заботиться нужно не о том, как что-то устроено, а о том, как оно работает. Простой пример – использование дат в JavaScript. Вы можете написать для них свой слой абстракции. Тогда если у вас сменится источник получения дат, вам нужно будет внести изменения в одном месте, а не в тысяче.
    Иногда добавление этого уровня абстракции требует усилий, но в конечном итоге они окупаются.
    В качестве примера взгляните на date-io, в этой библиотеке создан тот уровень абстракции, который позволяет вам использовать её с разными источниками дат.

    6. Avoid Premature Optimization
    Избегайте преждевременной оптимизации

    Эта практика побуждает разработчиков оптимизировать код до того, как необходимость этой оптимизации будет доказана. Думаю, что если вы следуете KISS или YAGNI, вы не попадетесь на этот крючок.
    Поймите правильно, предвидеть, что произойдет что-то плохое – это хорошо. Но прежде чем вы погрузитесь в детали реализации, убедитесь, что эти оптимизации действительно полезны.
    Очень простой пример – масштабирование. Вы не станете покупать 40 серверов из предположения, что ваше новое приложение станет очень популярным. Вы будете добавлять серверы по мере необходимости.
    Преждевременная оптимизация может привести к задержкам в коде и, следовательно, увеличит затраты времени на вывод функций на рынок.
    Многие считают преждевременную оптимизацию корнем всех зол.

    7. Бритва Оккама

    Бри́тва О́ккама (иногда ле́звие О́ккама) — методологический принцип, в кратком виде гласящий: «Не следует множить сущее без необходимости» (либо «Не следует привлекать новые сущности без крайней на то необходимости»).
    Что это значит в мире программирования? Не создавайте ненужных сущностей без необходимости. Будьте прагматичны — подумайте, нужны ли они, поскольку они могут в конечном итоге усложнить вашу кодовую базу.


84. Что такое дескрипторы свойств объектов?

    Дескриптор (флаг) - это объект, позволяющий описать поведение свойства при выполнении определённых операций над ним (например, чтения или записи).

    Типы дескрипторов свойств объектов:
    - дескрипторы данных (для свойства, имеющего значение, которое может (или не может) быть записываемым);
    - дескрипторы доступа (свойство, описываемое парой функций — геттером (get) и сеттером (set).
    
    Дескриптор может быть только одним из этих двух типов; он не может быть одновременно обоими.

    Дескрипторы свойств (как объекты) могут содержать следующие ключи:
      * [[value]] - значение, ассоциированное со свойством; может быть любым допустимым значением JavaScript (числом, объектом, функцией и т.д.); Этот атрибут хранит то, что выдаётся при попытке получения значения свойства объекта. То есть, если в предыдущем примере мы воспользуемся конструкцией вида object.x, мы получим то, что хранится в атрибуте [[Value]]. То же самое произойдёт и при попытке чтения свойства объекта с использованием квадратных скобок.

      * [[writable]] - Этот атрибут хранит логическое значение. Оно указывает на то, можно ли перезаписывать значение свойства или нет. Если здесь хранится значение false, то попытки изменить значение свойства успехом не увенчаются.

      * [[enumerable]] - Здесь тоже хранится логическое значение. Этот атрибут регулирует выдачу свойства в циклах for-in. Если он установлен в значение true, то со свойством можно будет работать с помощью таких циклов.

      * [[configurable]] - Этот атрибут тоже представлен логическим значением. Вот что происходит в том случае, если в нём хранится значение false:
          - Свойство нельзя будет удалить.
          - Нельзя будет преобразовывать свойства, хранящие данные, в свойства с методами доступа, и наоборот. Попытки выполнения подобных преобразований ни к чему не приведут.
          - Будет запрещено изменять значения атрибутов свойства. То есть неизменяемыми окажутся текущие значения атрибутов [[Enumerable]], [[Configurable]], [[Get]] и [[Set]].

          Эффект, оказываемый установкой этого атрибута в значение false, кроме того, зависит от вида свойства. Этот атрибут, помимо вышеописанного воздействия на свойства, действует на них и так:
          - Если перед нами — свойство, которое хранит данные, то атрибут [[Writable]] можно лишь изменить с true на false.
          - До тех пор, пока атрибут [[Writable]] не установлен false, можно менять атрибут [[Value]];
          - Но после того как в false будут установлены атрибуты [[Writable]] и [[Configurable]], свойство окажется незаписываемым, неудаляемым и неизменяемым;


      * [[get]] - Данный атрибут хранит ссылку на функцию, которая представляет собой свойство-геттер. Эта функция вызывается без аргументов при попытке чтения значения свойства;

      * [[set]] - функция, используемая как сеттер свойства (undefined, если свойство не имеет сеттера); функция принимает единственным аргументом новое значение, присваиваемое свойству.


    В JavaScript существуют специальные функции, предназначенные для работы с дескрипторами свойств. 

    * Метод Object.getOwnPropertyDescriptor()
        Мы уже встречались с этим методом. Он, принимая объект и имя его свойства, возвращает либо undefined, либо объект с дескриптором свойства.

    * Метод Object.defineProperty()
        Это — статический метод Object, который позволяет добавлять свойства к объектам или менять существующие свойства. Он принимает три аргумента — объект, имя свойства и объект с дескриптором. Этот метод возвращает модифицированный объект. 


    Защита объектов

    Периодически разработчику нужно защищать объекты от вмешательства извне. Например, учитывая гибкость JavaScript, очень легко по ошибке изменить свойства некоего объекта, которые меняться не должны. Существует три основных способа защиты объектов.

      * Метод Object.preventExtensions()

        Метод Object.preventExtensions() предотвращает расширение объекта, то есть — добавление в него новых свойств. Он принимает объект и делает его нерасширяемым. Обратите внимание на то, что свойства из такого объекта можно удалять. Рассмотрим пример:

            const obj = {
              id: 42
            };
            Object.preventExtensions(obj);
            obj.name = 'Arfat';
            console.log(obj);
            // => { id: 42 }

        Для того чтобы узнать, является ли некий объект нерасширяемым, можно воспользоваться методом Object.isExtensible(). Если он вернёт true, значит в объект можно добавлять новые свойства.


      * Метод Object.seal()

          Метод seal() как бы «запечатывает» объекты. Вот о чём идёт речь:

          - Его применение предотвращает добавление в объект новых свойств (в этом он похож на Object.preventExtensions()).
          - Он делает все существующие свойства объекта неконфигурируемыми.
          Значения существующих свойств, если их атрибут [[Writable]] не установлен в false, можно менять.

          В результате оказывается, что этот метод предотвращает добавление в объект новых свойств и удаление из него существующих в нём свойств.

          Рассмотрим пример:

              const obj = {
                id: 42
              };
              Object.seal(obj);
              delete obj.id 
              // (не работает)
              obj.name = 'Arfat';
              // (не работает)
              console.log(obj);
              // => { id: 42 }
              Object.isExtensible(obj);
              // => false
              Object.isSealed(obj);
              //=> true

          Для проверки того, «запечатан» объект или нет, можно воспользоваться методом Object.isSealed().

      * Метод Object.freeze()

            Метод freeze() позволяет «замораживать» объекты, оснащая их максимально возможным в JavaScript уровнем защиты. Вот как он работает:

      * «Запечатывает» объект с помощью Object.seal().
            Полностью запрещает модификацию любых существующих свойств объекта.
            Запрещает модификацию дескрипторов свойств.

              Вот пример:

              const obj = {
                id: 42
              };
              Object.freeze(obj);
              delete obj.id 
              // (не работает)
              obj.name = 'Arfat';
              // (не работает)
              console.log(obj);
              // => { id: 42 }
              Object.isExtensible(obj);
              // => false
              Object.isSealed(obj);
              //=> true
              Object.isFrozen(obj);
              // => true

      Проверить объект на то, «заморожен» ли он, можно с помощью метода Object.isFrozen(). 


85. В чем заключаются особенности геттеров и сеттеров?

...

86. Что такое статический метод класса (static)? Как осуществляется его вызов?


...