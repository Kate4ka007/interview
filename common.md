1. Разница между классовым и прототипным наследованием?
   - Как прототипное наследование, так и классическое наследование являются парадигмами объектно-ориентированного программирования (т. е. они имеют дело с объектами)

    * Классовое наследование: экземпляры наследуются от классов, создаются подклассовые отношения (иерархическая систематизация классов). Экземпляры реализуются через конструктор функции, через дескриптор new. Экземпляр класса может не содержать дескриптор class начиная с ES6.
      - В классическом наследовании объекты являются абстракциями «вещей» реального мира, но мы можем ссылаться на объекты только через классы. Классы — в данном случае это обобщение объекта. Другими словами, получается что классы — это абстракция объекта реального мира. При обобщении мы наследуем один класс от другого. И при классическом наследовании процесс наследования должен создавать уровень абстракции. При каждом наследовании, каждый дочерний класс должен повышать уровень абстракции, тем самым повышая уровень обобщения. 
      Объекты в классических объектно-ориентированных языках программирования могут быть созданы только путем создания экземпляров классов.

    * Прототипное наследование: экземпляры наследуются напрямую от других объектов, реализуются через фабрики или Object.create() и экземпляры могут быть составлены из множества различных объектов для упрощения выборочного наследования. Прототипное наследование более простое и гибкое, нежели классовое. 
      - В отличие от классического наследования, прототипное наследование не имеет дело с увеличивающимися уровнями абстракции. Объект — это либо абстракция реальной вещи, как и раньше, либо прямая копия другого Объекта (другими словами, Прототипа (Prototype)). Объекты могут быть созданы из ничего, или они могут быть созданы из других объектов. Уровень абстракции здесь не обязан быть глубже одного уровня (хотя при желание может и быть).

      Некоторые преимущества прототипного наследования:
          - Слабая связь. Экземпляр никогда не нуждается в прямой ссылке на родительский класс или прототип. Можно сохранить ссылку на прототип объекта, но это не рекомендуется, потому что это будет способствовать тесной связи в иерархии объектов — одна из самых больших ошибок классического наследования.

          - Плоские иерархии. С прототипным наследованием легко поддерживать плоские иерархии наследования — используя конкатенацию (выборочное использование свойств одного объекта для создания другого ) и делегирование (клонирование одного объекта в другой), вы можете иметь один уровень делегирования объекта и один экземпляр без ссылок на родительские классы.

          - Тривиальное множественное наследование. Наследование от нескольких предков так же просто, как объединение свойств из нескольких прототипов с использованием конкатенации для формирования нового объекта или нового делегата для нового объекта.

          - Гибкая архитектура. Поскольку вы можете выборочно наследоваться, вам не нужно беспокоиться о проблеме «неправильного дизайна». Новый класс может наследовать любую комбинацию свойств от любой комбинации исходных объектов. Из-за простоты выравнивания иерархии, изменение в одном месте не обязательно вызывает рябь в длинной цепочке объектов-потомков.


2. Что такое двусторонняя связь данных и однонаправленный поток данных и в чем разница между ними?

    * Двусторонняя связь данных подразумевает, что поля интерфейса связаны с моделью данных динамически, то есть при изменении полей интерфейса меняется модель, и наоборот. Данные в двунаправленном потоке могут передаваться между частями программы в обе стороны. 
    Чаще всего это используется для связывания модели и представления, чтобы обновление, например, текста в поле ввода сразу обновило данные в модели — это называется двунаправленным связыванием данных (two-way data binding).

    * В однонаправленном потоке данных каждая часть программы от другой части может либо получить данные, либо передать. Направление такого потока не меняется. Однонаправленный поток можно схематично представить, как водопровод, а модуль — как часть трубы.
    Однонаправленный поток данных означает, что только модель – источник истины. Изменения в интерфейсе запускают сообщения, которые сигнализируют пользователю о намерении модели (или «store» в терминах React). Смысл в том, что данные всегда идут в одном направлении, что облегчает понимание.
    Односторонние потоки данных детерминированы, тогда как двусторонняя привязка может вызывать нежелательные эффекты, которые труднее отследить и понять.

    Хорошо упомянуть:

    React – новый канонический пример однонаправленного потока данных, так что упоминание Реакта будет хорошей идеей. Cycle.js — еще одна популярная реализация однонаправленного потока данных.
    
    Angular – популярный фреймворк, использующий двустороннюю привязку.


3. Функциональное программирование — это стиль программирования, в котором особое значение придается использованию функций и неизменяемых данных.  
Смысл функционального программирования в том, что мы задаём не последовательность нужных нам команд, а описываем взаимодействие между ними и подпрограммами. 
Команды можно собирать в подпрограммы, но их последовательность не имеет значения.

Принципы функционального программирования
    * Переменные и функции
    Ключевыми составляющими функциональной программы являются уже не объекты и методы, а переменные и функции. При этом следует избегать глобальных переменных, потому что изменяемые глобальные переменные усложняют понимание программы и ведут к появлению у функций побочных эффектов.

    * Чистые функции
    Для чистых функций характерны два свойства:
      они не создают побочных эффектов;
      они всегда производят одинаковый вывод при получении одинакового ввода, что еще можно называть как ссылочную прозрачность. 
    Побочные эффекты же возникают, если функция изменяет состояние программы, переписывает вводную переменную или в общем вносит какие-либо изменения при генерации вывода. Отсутствие же побочных эффектов снижает риски появления ошибок по вине чистых функций. 


    * Неизменяемость и состояния
    Неизменяемые данные или состояния не могут изменяться после их определения, что позволяет сохранять постоянство стабильной среды для вывода функций. Лучше всего программировать каждую функцию так, чтобы она выводила один и тот же результат независимо от состояния программы. Если же она зависит от состояния, то это состояние должно быть неизменяемым, чтобы вывод такой функции оставался постоянным.
    Подходы функционального программирования обычно избегают применения функций с общим состоянием (когда несколько функций опираются на одно состояние) и функций с изменяющимся состоянием (которые зависят от изменяемых функций), потому что они уменьшают модульность программы. Если же вы не можете обойтись без функций с общим состоянием, сделайте это состояние неизменяемым. 

    * Рекурсия
    Одно из серьезных отличий объектно-ориентированного программирования от функционального в том, что программы последнего избегают таких конструкций, как инструкции if else или циклы, которые в разных случаях выполнения могут выдавать разные выводы.
    Вместо циклов функциональные программы используют для всех задач по перебору рекурсию.

    * Функции первого класса
    Функции в ФП рассматриваются как типы данных и могут использоваться как любое другое значение. Например, мы заполняем функциями массивы, передаем их в качестве параметров или сохраняем их в переменных. 

    * Функции высшего порядка
    Эти функции могут принимать другие функции в качестве параметров или возвращать функции в качестве вывода. Они делают возможности вызова функций более гибкими и позволяют легче абстрагироваться от действий.

    * Композиция функций
    Для выполнения сложных операций функции можно выполнять последовательно. В этом случае результат каждой функции передается следующей функции в виде аргумента. Это позволяет с помощью всего одного вызова функции активировать целую серию их последовательных вызовов. 

    Преимущества функционального программирования
    - Легкая отладка: чистые функции и неизменяемые данные упрощают обнаружение мест определения значений переменных. В чистых функциях меньше факторов, влияющих на них, что позволяет быстрее находить проблемные участки кода. 
    - Отложенное вычисление: функциональные программы производят вычисления только при необходимости. Это позволяет им повторно использовать ранее полученные результаты и экономить время на выполнение. 
    - Модульность: чистые функции не полагаются на внешние переменные или состояния, в связи с чем их можно легко переиспользовать в разных местах программы. Кроме того, функции будут выполнять только одну операцию или вычисление, что не позволит вам при их использовании случайно импортировать лишний код.
    - Лучшая читаемость: функциональные программы легко читать, потому что поведение каждой функции неизменяемо и изолировано от состояния программы. В результате вы зачастую можете легко понять, что будет делать функция, просто по ее имени.
    - Параллельное программирование: программы легче создавать при помощи функционального подхода, потому что неизменяемые переменные снижают число изменений внутри этих программ. Каждой функции приходится работать только с вводом пользователя, и она может быть уверена, что состояние программы в основном останется прежним. 


плюсы:
  - Unit тестирование
  - Отладка
  - Многопоточность
  - Развёртывание по горячему 
  - Функции высшего порядка
  - Каррирование
  - Ленивые вычисления
  - Оптимизация
  - Абстрагирование структур управления
  - Бесконечные структуры данных

         
3. Что такое MVC?
    MVC — это шаблон (pattern) программирования, который позволяет разделить логику приложения на три части:
        - Model (модель). Получает данные от контроллера, выполняет необходимые операции и передаёт их в вид.
        - View (вид или представление). Получает данные от модели и выводит их для пользователя.
        - Controller (контроллер). Обрабатывает действия пользователя, проверяет полученные данные и передаёт их модели.
        
        Этот паттерн разработки нужен для того, чтобы разделить логические части приложения и создавать их отдельно друг от друга. То есть писать независимые блоки кода, которые можно как угодно менять, не затрагивая другие.

        Модель — метод, который запускается обработчиком и выполняет все основные операции (получение записей из базы данных, проведение вычислений).
        Вид — интерфейс.
        Контроллер — обработчик событий, инициируемых пользователем (нажатие на кнопку, переход по ссылке, отправка формы).

4. Что такое MVVM? 
MVVM — это паттерн разработки, позволяющий разделить приложение на три функциональные части:

Model — основная логика программы (работа с данными, вычисления, запросы и так далее).
View — вид или представление (пользовательский интерфейс).
ViewModel — модель представления, которая служит прослойкой между View и Model.

5. Что такое MVP? 
MVP — это паттерн программирования графических интерфейсов. В нём приложение делится на три компонента:

Model (Модель) работает с данными, проводит вычисления и руководит всеми бизнес-процессами.
View (Вид или представление) показывает пользователю интерфейс и данные из модели.
Presenter (Представитель) служит прослойкой между моделью и видом.