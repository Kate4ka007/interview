1. Разница между классовым и прототипным наследованием?
   - Как прототипное наследование, так и классическое наследование являются парадигмами объектно-ориентированного программирования (т. е. они имеют дело с объектами)

    * Классовое наследование: экземпляры наследуются от классов, создаются подклассовые отношения (иерархическая систематизация классов). Экземпляры реализуются через конструктор функции, через дескриптор new. Экземпляр класса может не содержать дескриптор class начиная с ES6.
      - В классическом наследовании объекты являются абстракциями «вещей» реального мира, но мы можем ссылаться на объекты только через классы. Классы — в данном случае это обобщение объекта. Другими словами, получается что классы — это абстракция объекта реального мира. При обобщении мы наследуем один класс от другого. И при классическом наследовании процесс наследования должен создавать уровень абстракции. При каждом наследовании, каждый дочерний класс должен повышать уровень абстракции, тем самым повышая уровень обобщения. 
      Объекты в классических объектно-ориентированных языках программирования могут быть созданы только путем создания экземпляров классов.

    * Прототипное наследование: экземпляры наследуются напрямую от других объектов, реализуются через фабрики или Object.create() и экземпляры могут быть составлены из множества различных объектов для упрощения выборочного наследования. Прототипное наследование более простое и гибкое, нежели классовое. 
      - В отличие от классического наследования, прототипное наследование не имеет дело с увеличивающимися уровнями абстракции. Объект — это либо абстракция реальной вещи, как и раньше, либо прямая копия другого Объекта (другими словами, Прототипа (Prototype)). Объекты могут быть созданы из ничего, или они могут быть созданы из других объектов. Уровень абстракции здесь не обязан быть глубже одного уровня (хотя при желание может и быть).

      Некоторые преимущества прототипного наследования:
          - Слабая связь. Экземпляр никогда не нуждается в прямой ссылке на родительский класс или прототип. Можно сохранить ссылку на прототип объекта, но это не рекомендуется, потому что это будет способствовать тесной связи в иерархии объектов — одна из самых больших ошибок классического наследования.

          - Плоские иерархии. С прототипным наследованием легко поддерживать плоские иерархии наследования — используя конкатенацию (выборочное использование свойств одного объекта для создания другого ) и делегирование (клонирование одного объекта в другой), вы можете иметь один уровень делегирования объекта и один экземпляр без ссылок на родительские классы.

          - Тривиальное множественное наследование. Наследование от нескольких предков так же просто, как объединение свойств из нескольких прототипов с использованием конкатенации для формирования нового объекта или нового делегата для нового объекта.

          - Гибкая архитектура. Поскольку вы можете выборочно наследоваться, вам не нужно беспокоиться о проблеме «неправильного дизайна». Новый класс может наследовать любую комбинацию свойств от любой комбинации исходных объектов. Из-за простоты выравнивания иерархии, изменение в одном месте не обязательно вызывает рябь в длинной цепочке объектов-потомков.


2. Что такое двусторонняя связь данных и однонаправленный поток данных и в чем разница между ними?

    * Двусторонняя связь данных подразумевает, что поля интерфейса связаны с моделью данных динамически, то есть при изменении полей интерфейса меняется модель, и наоборот. Данные в двунаправленном потоке могут передаваться между частями программы в обе стороны. 
    Чаще всего это используется для связывания модели и представления, чтобы обновление, например, текста в поле ввода сразу обновило данные в модели — это называется двунаправленным связыванием данных (two-way data binding).

    * В однонаправленном потоке данных каждая часть программы от другой части может либо получить данные, либо передать. Направление такого потока не меняется. Однонаправленный поток можно схематично представить, как водопровод, а модуль — как часть трубы.
    Однонаправленный поток данных означает, что только модель – источник истины. Изменения в интерфейсе запускают сообщения, которые сигнализируют пользователю о намерении модели (или «store» в терминах React). Смысл в том, что данные всегда идут в одном направлении, что облегчает понимание.
    Односторонние потоки данных детерминированы, тогда как двусторонняя привязка может вызывать нежелательные эффекты, которые труднее отследить и понять.

    Хорошо упомянуть:

    React – новый канонический пример однонаправленного потока данных, так что упоминание Реакта будет хорошей идеей. Cycle.js — еще одна популярная реализация однонаправленного потока данных.
    
    Angular – популярный фреймворк, использующий двустороннюю привязку.


3. Функциональное программирование — это стиль программирования, в котором особое значение придается использованию функций и неизменяемых данных.  
Смысл функционального программирования в том, что мы задаём не последовательность нужных нам команд, а описываем взаимодействие между ними и подпрограммами. 
Команды можно собирать в подпрограммы, но их последовательность не имеет значения.

Принципы функционального программирования
    * Переменные и функции
    Ключевыми составляющими функциональной программы являются уже не объекты и методы, а переменные и функции. При этом следует избегать глобальных переменных, потому что изменяемые глобальные переменные усложняют понимание программы и ведут к появлению у функций побочных эффектов.

    * Чистые функции
    Для чистых функций характерны два свойства:
      они не создают побочных эффектов;
      они всегда производят одинаковый вывод при получении одинакового ввода, что еще можно называть как ссылочную прозрачность. 
    Побочные эффекты же возникают, если функция изменяет состояние программы, переписывает вводную переменную или в общем вносит какие-либо изменения при генерации вывода. Отсутствие же побочных эффектов снижает риски появления ошибок по вине чистых функций. 


    * Неизменяемость и состояния
    Неизменяемые данные или состояния не могут изменяться после их определения, что позволяет сохранять постоянство стабильной среды для вывода функций. Лучше всего программировать каждую функцию так, чтобы она выводила один и тот же результат независимо от состояния программы. Если же она зависит от состояния, то это состояние должно быть неизменяемым, чтобы вывод такой функции оставался постоянным.
    Подходы функционального программирования обычно избегают применения функций с общим состоянием (когда несколько функций опираются на одно состояние) и функций с изменяющимся состоянием (которые зависят от изменяемых функций), потому что они уменьшают модульность программы. Если же вы не можете обойтись без функций с общим состоянием, сделайте это состояние неизменяемым. 

    * Рекурсия
    Одно из серьезных отличий объектно-ориентированного программирования от функционального в том, что программы последнего избегают таких конструкций, как инструкции if else или циклы, которые в разных случаях выполнения могут выдавать разные выводы.
    Вместо циклов функциональные программы используют для всех задач по перебору рекурсию.

    * Функции первого класса
    Функции в ФП рассматриваются как типы данных и могут использоваться как любое другое значение. Например, мы заполняем функциями массивы, передаем их в качестве параметров или сохраняем их в переменных. 

    * Функции высшего порядка
    Эти функции могут принимать другие функции в качестве параметров или возвращать функции в качестве вывода. Они делают возможности вызова функций более гибкими и позволяют легче абстрагироваться от действий.

    * Композиция функций
    Для выполнения сложных операций функции можно выполнять последовательно. В этом случае результат каждой функции передается следующей функции в виде аргумента. Это позволяет с помощью всего одного вызова функции активировать целую серию их последовательных вызовов. 

    Преимущества функционального программирования
    - Легкая отладка: чистые функции и неизменяемые данные упрощают обнаружение мест определения значений переменных. В чистых функциях меньше факторов, влияющих на них, что позволяет быстрее находить проблемные участки кода. 
    - Отложенное вычисление: функциональные программы производят вычисления только при необходимости. Это позволяет им повторно использовать ранее полученные результаты и экономить время на выполнение. 
    - Модульность: чистые функции не полагаются на внешние переменные или состояния, в связи с чем их можно легко переиспользовать в разных местах программы. Кроме того, функции будут выполнять только одну операцию или вычисление, что не позволит вам при их использовании случайно импортировать лишний код.
    - Лучшая читаемость: функциональные программы легко читать, потому что поведение каждой функции неизменяемо и изолировано от состояния программы. В результате вы зачастую можете легко понять, что будет делать функция, просто по ее имени.
    - Параллельное программирование: программы легче создавать при помощи функционального подхода, потому что неизменяемые переменные снижают число изменений внутри этих программ. Каждой функции приходится работать только с вводом пользователя, и она может быть уверена, что состояние программы в основном останется прежним. 


плюсы:
  - Unit тестирование
  - Отладка
  - Многопоточность
  - Развёртывание по горячему 
  - Функции высшего порядка
  - Каррирование
  - Ленивые вычисления
  - Оптимизация
  - Абстрагирование структур управления
  - Бесконечные структуры данных

         
3. Что такое MVC?
    MVC — это шаблон (pattern) программирования, который позволяет разделить логику приложения на три части:
        - Model (модель). Получает данные от контроллера, выполняет необходимые операции и передаёт их в вид.
        - View (вид или представление). Получает данные от модели и выводит их для пользователя.
        - Controller (контроллер). Обрабатывает действия пользователя, проверяет полученные данные и передаёт их модели.
        
        Этот паттерн разработки нужен для того, чтобы разделить логические части приложения и создавать их отдельно друг от друга. То есть писать независимые блоки кода, которые можно как угодно менять, не затрагивая другие.

        Модель — метод, который запускается обработчиком и выполняет все основные операции (получение записей из базы данных, проведение вычислений).
        Вид — интерфейс.
        Контроллер — обработчик событий, инициируемых пользователем (нажатие на кнопку, переход по ссылке, отправка формы).

4. Что такое MVVM? 
MVVM — это паттерн разработки, позволяющий разделить приложение на три функциональные части:

Model — основная логика программы (работа с данными, вычисления, запросы и так далее).
View — вид или представление (пользовательский интерфейс).
ViewModel — модель представления, которая служит прослойкой между View и Model.

5. Что такое MVP? 
MVP — это паттерн программирования графических интерфейсов. В нём приложение делится на три компонента:

Model (Модель) работает с данными, проводит вычисления и руководит всеми бизнес-процессами.
View (Вид или представление) показывает пользователю интерфейс и данные из модели.
Presenter (Представитель) служит прослойкой между моделью и видом.

6. В чем разница между null и undefined?

   Для начала давайте поговорим о том, что у них общего.
     - они принадлежат к 7 «примитивам» (примитивным типам) JS:
       ['string', 'number', 'null', 'undefined', 'boolean', 'symbol', 'bigint']
     - они являются ложными значениями, т.е. результатом их преобразования в логическое значение с помощью Boolean() или оператора "!!" является false:
        console.log(!!null) // false
        console.log(!!undefined) // false

        console.log(Boolean(null)) // false
        console.log(Boolean(undefined)) // false

   Различия:
       * undefined («неопределенный») представляет собой значение по умолчанию:
           - переменной, которой не было присвоено значения, т.е. объявленной, но не инициализированной переменной;
           - функции, которая ничего не возвращает явно, например, console.log(1);
           - несуществующего свойства объекта.

            let _thisIsUndefined
            const doNothing = () => {}
            const someObj = {
                a: 'ay'
              }
            console.log(_thisIsUndefined) // undefined
            console.log(doNothing()) // undefined
            console.log(someObj['b']) // undefined


        * null — это «значение отсутствия значения». null — это значение, которое присваивается переменной явно. В примере ниже мы получаем null, когда метод fs.readFile отрабатывает без ошибок:

            fs.readFile('path/to/file', (e, data) => {
                console.log(e) // здесь мы получаем null
            if(e) {
                console.log(e)
            }
                console.log(data)
            })

        При сравнении null и undefined мы получаем true, когда используем оператор "==", и false при использовании оператора "===". О том, почему так происходит, см. ниже.
            console.log(null == undefined) // true
            console.log(null === undefined) // false

7. Для чего используется оператор "&&"?
       Оператор "&&" (логическое и) находит и возвращает первое ложное значение либо последний операнд, когда все значения истинные. Он использует короткое замыкание во избежание лишних затрат:
          console.log(false && 1 && []) // false
          console.log(' ' && true && 5) // 5


8. Для чего используется оператор "||"?
       Оператор "||" (логическое или) находит и возвращает первое истинное значение. Он также использует короткое замыкание. Данный оператор использовался для присвоения параметров по умолчанию в функциях до того, как параметры по умолчанию были стандартизированы в ES6.
            console.log(null || 1 || undefined) // 1

9. Является ли использование унарного плюса (оператор "+") самым быстрым способом преобразования строки в число? 
    Согласно MDN оператор "+" действительно является самым быстрым способом преобразования строки в число, поскольку он не выполняет никаких операций со значением, которое является числом.

10. Что такое DOM?

    - DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. DOM представляет собой древовидную структуру (дерево документа). DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.
    - В JS DOM представлен объектом Document. Объект Document имеет большое количество методов для работы с элементами, их созданием, модификацией, удалением и т.д.    

11. Что такое распространение события (Event Propagation)?

    Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие «распространяется» от объекта Window до вызвавшего его элемента (event.target). При этом событие последовательно пронизывает (затрагивает) всех предков целевого элемента. Распространение события имеет три стадии или фазы:
    - Фаза погружения (захвата, перехвата) — событие возникает в объекте Window и опускается до цели события через всех ее предков.
    - Целевая фаза — это когда событие достигает целевого элемента.
    - Фаза всплытия — событие поднимается от event.target, последовательно проходит через всех его предков и достигает объекта Window.

12. Что такое всплытие события?

    Когда событие происходит в элементе DOM, оно затрагивает не только этот элемент. Событие «всплывает» (подобно пузырьку воздуха в воде), переходит от элемента, вызвавшего событие (event.target), к его родителю, затем поднимается еще выше, к родителю родителя элемента, пока не достигает объекта Window.
    У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения (для «прослушивателей» событий, прикрепленных к цели события, событие находится в целевой фазе, а не в фазах погружения или всплытия. События в целевой фазе инициируют все прослушиватели на элементе в том порядке, в котором они были зарегистрированы независимо от параметра useCapture — прим. пер.). Если мы кликнем по элементу child, в консоль будет выведено: child, parent, grandparent, html, document, window. Вот что такое всплытие события.   

13. Что такое погружение события?

    Когда событие происходит в элементе DOM, оно происходит не только в нем. В фазе погружения событие опускается от объекта Window до цели события через всех его предков.
    У метода addEventListener есть третий необязательный параметр — useCapture. Когда его значение равняется false (по умолчанию), событие начинается с фазы всплытия. Когда его значение равняется true, событие начинается с фазы погружения. Если мы кликнем по элементу child, то увидим в консоли следующее: window, document, html, grandparent, parent, child. Это и есть погружение события.  


14.  В чем разница между методами event.preventDefault() и event.stopPropagation()?

     - Метод event.preventDefault() отключает поведение элемента по умолчанию. Если использовать этот метод в элементе form, то он предотвратит отправку формы (submit). Если использовать его в contextmenu, то контекстное меню будет отключено (данный метод часто используется в keydown для переопределения клавиатуры, например, при создании музыкального/видео плеера или текстового редактора — прим. пер.).
     - Метод event.stopPropagation() отключает распространение события (его всплытие или погружение). 

15.  Как узнать об использовании метода event.preventDefault()?

     Для этого мы можем использовать свойство event.defaulPrevented, возвращающее логическое значение, служащее индикатором применения к элементу метода event.preventDefault.   

16. Почему obj.someprop.x приводит к ошибке? 
        const obj = {}
        console.log(obj.someprop.x)
    Ответ очевиден: мы пытается получить доступ к свойству x свойства someprop, которое имеет значение undefined. obj.__proto__.__proto = null, поэтому возвращается undefined, а у undefined нет свойства x.    

17. Что такое цель события или целевой элемент (event.target)?
    event.target — это элемент, в котором происходит событие, или элемент, вызвавший событие.

18. Что такое текущая цель события (event.currentTarget)?
    Event.currentTarget — это элемент, к которому прикреплен прослушиватель событий.    

19. В чем разница между операторами "==" и "==="?

    Разница между оператором "==" (абстрактное или нестрогое равенство) и оператором "===" (строгое равенство) состоит в том, что первый сравнивает значения после их преобразования или приведения к одному типу (Coersion), а второй — без такого преобразования.

    Преобразование представляет собой процесс приведения значения к другому типу или, точнее, процесс приведения сравниваемых значений к одному типу. При сравнении оператор "==" производит так называемое неявное сравнение. Оператор "==" выполняет некоторые операции перед сравнением двух значений.

      Допустим, мы сравниваем x и y.

      Алгоритм следующий:
          Если x и y имеют одинаковый тип, сравнение выполняется с помощью оператора "===".
          Если x = null и y = undefined возвращается true.
          Если x = undefined и y = null возвращается true.
          Если x = число, а y = строка, возвращается x == toNumber(y) (значение y преобразуется в число).
          Если x = строка, а y = число, возвращается toNumber(x) == y (значение x преобразуется в число).
          Если x = логическое значение, возвращается toNumber(x) == y.
          Если y = логическое значение, возвращается x == toNumber(y).
          Если x = строка, символ или число, а y = объект, возвращается x == toPrimitive(y) (значение y преобразуется в примитив).
          Если x = объект, а y = строка, символ или число, возвращается toPrimitive(x) == y.
          Возвращается false.

          Запомните: для приведения объекта к «примитиву» метод toPrimitive сначала использует метод valueOf, затем метод toString.


20. Почему результатом сравнения двух похожих объектов является false?

        let a = {
            a: 1
        }
        let b = {
            a: 1
        }
        let c = a

        console.log(a === b) // false
        console.log(a === c) // true хм...

        В JS объекты и примитивы сравниваются по-разному. Примитивы сравниваются по значению. Объекты — по ссылке или адресу в памяти, где хранится переменная. Вот почему первый console.log возвращает false, а второй — true. Переменные «a» и «c» ссылаются на один объект, а переменные «a» и «b» — на разные объекты с одинаковыми свойствами и значениями.  

21. Для чего используется оператор "!!"?
        Оператор "!!" (двойное отрицание) приводит значение справа от него к логическому значению.          
              console.log(!!null) // false
              console.log(!!undefined) // false
              console.log(!!'') // false
              console.log(!!0) // false
              console.log(!!NaN) // false
              console.log(!!' ') // true
              console.log(!!{}) // true
              console.log(!![]) // true
              console.log(!!1) // true
              console.log(!![].length) // false

22. Как записать несколько выражений в одну строку?

        Для этого мы можем использовать оператор "," (запятая). Этот оператор «двигается» слева направо и возвращает значение последнего выражения или операнда.

        let x = 5

        x = (x++, x = addFive(x), x *= 2, x -= 5, x += 10)

        function addFive(num) {
            return num + 5
        }

        Если мы выведем значение x в консоль, то получим 27. Сначала мы увеличиваем значение x на единицу (x = 6). Затем вызываем функцию addFive() с параметром 6, к которому прибавляем 5 (x = 11). После этого мы умножаем значение x на 2 (x = 22). Затем вычитаем 5 (x = 17). И, наконец, прибавляем 10 (x = 27).              
             
23. Что такое поднятие (Hoisting)?

    Поднятие — это термин, описывающий подъем переменной или функции в глобальную или функциональную области видимости.

    Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения.
    Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение.

    - Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.).

    - Выполнение. В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.

    Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.

    Предположим, что у нас есть такой код:

          console.log(y)
          y = 1
          console.log(y)
          console.log(greet('Mark'))

          function greet(name) {
              return 'Hello ' + name + '!'
          }

          var y

          Получаем undefined, 1 и 'Hello Mark!'.

          Вот как выглядит фаза компиляции:

          function greet(name) {
              return 'Hello ' + name + '!'
          }

          var y // присваивается undefined

          // ожидается завершение фазы компиляции

          // затем начинается фаза выполнения
          /*
          console.log(y)
          y = 1
          console.log(y)
          console.log(greet('Mark'))
          */


          После завершения фазы компиляции начинается фаза выполнения, когда переменным присваиваются значения и вызываются функции. 
      


24. Контекст выполнения

    Контекст выполнения (execution context) — это, если говорить упрощённо, концепция, описывающая окружение, в котором производится выполнение кода на JavaScript. Код всегда выполняется внутри некоего контекста.

      ▍Типы контекстов выполнения
      В JavaScript существует три типа контекстов выполнения:
          * Глобальный контекст выполнения. Это базовый, используемый по умолчанию контекст выполнения. Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, которым, в случае с браузером, является объект window, и тем, что ключевое слово this указывает на этот глобальный объект. В программе может быть лишь один глобальный контекст.
          * Контекст выполнения функции. Каждый раз, когда вызывается функция, для неё создаётся новый контекст. Каждая функция имеет собственный контекст выполнения. В программе может одновременно присутствовать множество контекстов выполнения функций. При создании нового контекста выполнения функции он проходит через определённую последовательность шагов, о которой мы поговорим ниже.
          * Контекст выполнения функции eval. Код, выполняемый внутри функции eval, также имеет собственный контекст выполнения. Однако функцией eval пользуются очень редко, поэтому здесь мы об этом контексте выполнения говорить не будем.

25. Стек выполнения

        Стек выполнения (execution stack), который ещё называют стеком вызовов (call stack), это LIFO-стек, который используется для хранения контекстов выполнения, создаваемых в ходе работы кода. 
        Когда JS-движок начинает обрабатывать скрипт, движок создаёт глобальный контекст выполнения и помещает его в текущий стек. При обнаружении команды вызова функции движок создаёт новый контекст выполнения для этой функции и помещает его в верхнюю часть стека.

        Движок выполняет функцию, контекст выполнения которой находится в верхней части стека. Когда работа функции завершается, её контекст извлекается из стека и управление передаётся тому контексту, который находится в предыдущем элементе стека.

        Изучим эту идею с помощью следующего примера:
        let a = 'Hello World!';
        function first() {
          console.log('Inside first function');
          second();
          console.log('Again inside first function');
        }
        function second() {
          console.log('Inside second function');
        }
        first();
        console.log('Inside Global Execution Context');


          Вот как будет меняться стек вызовов при выполнении этого кода.
          Состояние стека вызовов
          Когда вышеприведённый код загружается в браузер, JavaScript-движок создаёт глобальный контекст выполнения и помещает его в текущий стек вызовов. При выполнении вызова функции first() движок создаёт для этой функции новый контекст и помещает его в верхнюю часть стека.
          При вызове функции second() из функции first() для этой функции создаётся новый контекст выполнения и так же помещается в стек. После того, как функция second() завершает работу, её контекст извлекается из стека и управление передаётся контексту выполнения, находящемуся в стеке под ним, то есть, контексту функции first().
          Когда функция first() завершает работу, её контекст извлекается из стека и управление передаётся глобальному контексту. После того, как весь код оказывается выполненным, движок извлекает глобальный контекст выполнения из текущего стека.    

26. Что такое область видимости (Scope)?

    Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).

        - Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.

        - Функциональная область видимости (область видимости функции) — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции.

        - Блочная область видимости — переменные (объявленные с помощью ключевых слов «let» и «const») внутри блока ({ }), доступны только внутри него.


    Область видимости — это также набор правил, по которым осуществляется поиск переменной. Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости. Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости. Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение. Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. Это называется цепочкой областей видимости (Scope Chain).          

27. Что такое замыкание (Closures)?
        По сути, замыкание — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости, в области видимости родительской функции, в области видимости родителя родительской функции и так до глобальной области видимости с помощью цепочки областей видимости. Обычно область видимости определяется при создании функции.

        Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена. Другими словами, замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.
        
        Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.  в JavaScript, все функции изначально являются замыканиями (есть только одно исключение, про которое будет рассказано в Синтаксис "new Function").
        То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]] и все они могут получить доступ к внешним переменным.

        Когда на собеседовании фронтенд-разработчик получает вопрос: «что такое замыкание?», – правильным ответом будет определение замыкания и объяснения того факта, что все функции в JavaScript являются замыканиями, и, может быть, несколько слов о технических деталях: свойстве [[Environment]] и о том, как работает лексическое окружение.

28. Какие значения в JS являются ложными?

    const falsyValues = ['', 0, null, undefined, NaN, false]
    Ложными являются значения, результатом преобразования которых в логическое значение является false.   

29. Как проверить, является ли значение ложным?
    Следует использовать функцию Boolean или оператор "!!" (двойное отрицание).   

30. Для чего используется директива «use strict»?

    «use strict» — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Строгий режим вводит некоторые ограничения по написанию кода, тем самым позволяя избегать ошибок на ранних этапах.

    Вот какие ограничения накладывает строгий режим.
        - Нельзя присваивать значения или обращаться к необъявленным переменным:
              function returnY() {
                  'use strict'
                  y = 123
                  return y
              }
              returnY() // Uncaught ReferenceError: y is not defined

        - Запрещено присваивать значения глобальный переменным, доступным только для чтения или записи:
          'use strict'
          var NaN = NaN // Uncaught TypeError: Cannot assign to read only property 'NaN' of object '#<Window>'
          var undefined = undefined
          var Infinity = 'and beyond'

        - Нельзя удалить «неудаляемое» свойство объекта:

          'use strict'
          const obj = {}
          Object.defineProperties(obj, 'x', {
              value: 1
          })

          delete obj.x // Uncaught TypeError: Property description must be an object: x

        - Запрещено дублирование параметров:

          'use strict'
          function someFunc(a, b, b, c) {} // Uncaught SyntaxError: Duplicate parameter name not allowed in this context

        - Нельзя создавать функции с помощью функции eval:

          'use strict'
          eval('var x = 1')
          console.log(x) // Uncaught ReferenceError: x is not defined

        - Значением «this» по умолчанию является undefined:

          'use strict'

          function showMeThis() {
              return this
          }
          showMeThis() // undefined

31. Какое значение имеет this?

        Обычно this ссылается на значение объекта, который в данный момент выполняет или вызывает функцию. «В данный момент» означает, что значение this меняется в зависимости от контекста выполнения, от того места, где мы используем this.  

        Call и apply принимают в качестве первого аргумента объект, который будет являться значением this внутри функции.

        В IIFE, функциях, которые создаются в глобальном области видимости, анонимных функциях и внутренних функциях методов объекта значением this по умолчанию является объект window.     

        Стрелочные функции не имеют собственного значения this. Они копируют значение this из внешнего лексического окружения. 

32. Что такое прототип объекта?

    В двух словах, прототип — это план (схема или проект) объекта. Он используется как запасной вариант для свойств и методов, существующих в данном объекте. Это также один из способов обмена свойствами и функциональностью между объектами. Это основная концепция прототипного наследования в JS.

    const o = {}
    console.log(o.toString()) // [object Object]

    Несмотря на то, что объект «о» не имеет свойства toString, обращение к этому свойству не вызывает ошибки. Если определенного свойства нет в объекте, его поиск осуществляется сначала в прототипе объекта, затем в прототипе прототипа объекта и так до тех пор, пока свойство не будет найдено. Это называется цепочкой прототипов. На вершине цепочки прототипов находится Object.prototype.

33. Что такое IIFE?

    IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так: (function(){})().
    const utility = (function( ) {
        return {
            // утилиты
        }
    })
    мы можем сохранить результат IIFE в переменной.

    Лучшее использование IIFE — это выполнение функций настройки инициализации и предотвращение конфликтов имен с другими переменными в глобальной области видимости (загрязнение глобального пространства имен). Приведем пример.

34. Для чего используется метод Function.prototype.apply?

        Apply используется для привязки определенного объекта к значению this вызываемой функции.

        const details = {
            message: 'Hello World!'
        }

        function getMessage() {
            return this.message
        }

        getMessage.apply(details) // Hello World!


        Этот метод похож на Function.prototype.call. Единственное отличие состоит в том, что в apply аргументы передаются в виде массива.

        const person = {
            name: 'Marko Polo'
        }

        function greeting(greetingMessage) {
            return `${greetingMessage} ${this.name}`
        }

        greeting.apply(person, ['Hello']) // Hello Marko Polo

35.  Для чего используется метод Function.prototype.call?

        Call используется для привязки определенного объекта к значению this вызываемой функции.

        const details = {
            message: 'Hello World!'
        };

        function getMessage() {
            return this.message;
        }

        getMessage.call(details); // Hello World!


        Этот метод похож на Function.prototype.apply. Отличие состоит в том, что в call аргументы передаются через запятую.      

36. В чем разница между методами call и apply?
    Отличие между call и apply состоит в том, как мы передаем аргументы в вызываемой функции. В apply аргументы передаются в виде массива, в call — через запятую.

    const obj1 = {
        result: 0
    }

    const obj2 = {
        result: 0
    }

    function reduceAdd() {
        let result = 0
        for (let i = 0, len = arguments.length; i < len; i++) {
            result += arguments[i]
        }
        this.result = result
    }

    reduceAdd.apply(obj1, [1, 2, 3, 4, 5]) // 15
    reduceAdd.call(obj2, 1, 2, 3, 4, 5) // 15

37. Для чего используется метод Function.prototype.bind?

    Bind возвращает новую функцию, значением this которой является объект, указанный в качестве первого параметра. В отличие от bind, call и apply сразу же вызывают функцию.   

38. Что такое функциональное программирование и какие особенности JS позволяют говорить о нем как о функциональном языке программирования?

    Функциональное программирование — это декларативная концепция программирования или образец (паттерн) того, как строятся приложения, как используются функции, содержащие выражения, которые вычисляют значения без изменения аргументов, которые им передаются.

    Объект Array содержит методы map, filter и reduce, которые являются самыми известными функциями в мире функционального программирования из-за их полезности, а также потому, что они не изменяют массив, что делает эти функции «чистыми». Также в JS имеются замыкание и функции высшего порядка, которые являются характеристиками функционального языка программирования.

    Метод map возвращает новый массив с результатами вызова callback для каждого элемента массива:

    const words = ['Functional', 'Procedural', 'Object-Oriented']

    const wordsLength = words.map(word => word.length)


    Метод filter создает новый массив со всеми элементами, которые удовлетворяют условию, указанному в callback:

    const data = {
        {
            name: 'Mark',
            isRegistered: true
        } {
            name: 'Mary',
            isRegistered: false
        } {
            name: 'Mae',
            isRegistered: true
        }
    }

    const registeredUsers = data.filter(user => user.isRegistered)


    Метод reduce выполняет callback один раз для каждого элемента массива, за исключением пустот, принимая четыре аргумента: начальное значение (или значение от предыдущего callback), значение текущего элемента, текущий индекс и итерируемый массив:

    const strs = ['I', ' ', 'am', ' ', 'Iron', ' ', 'Man']
    const result = strs.reduce((acc, currentStr) => acc + str, '')

39. Что такое функции высшего порядка (Higher Order Functions)?

    Функция высшего порядка — это функция, возвращающая другую функцию или принимающая другую функцию в качестве аргумента.   

40. Почему функции в JS называют объектами первого класса (First-class Objects)?

    Функции называют объектами первого класса, потому что они обрабатываются также, как и любое другое значение в JS. Они могут присваиваться переменным, быть свойством объекта (методом), элементом массива, аргументом другой функции, значением, возвращаемым функцией. Единственным отличием функции от любого другого значения в JS является то, что функция может быть выполнена или вызвана.     
     
41. Как бы Вы реализовали метод Array.prototype.map?

    function map(arr, mapCallback) {
        // проверяем переданные параметры
        if (!Array.isArray(arr) || !arr.length || typeof mapCallback !== 'function') {
            return []
        } else {
            let result = []
            // мы создаем массив с результатами при каждом вызове функции
            // поскольку мы не хотим менять оригинальный массив
            for (let i = 0, len = arr.length; i < len; i++) {
                result.push(mapCallback(arr[i], i, arr))
                // помещаем результаты mapCallback в result
            }
            return result
        }
    }


    Метод map создает новый массив с результатом вызова указанной функции для каждого элемента массива.      


42. Как бы Вы реализовали метод Array.prototype.filter?

    function filter(arr, filterCallback) {
        // проверяем передаваемые параметры
        if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') {
            return []
        } else {
            let result = []
            // ...
            for (let i = 0, len = arr.length; i < len; i++) {
                // определяем соответствие возвращаемого результата заданному условию
                if (filterCallback(arr[i], i, arr)) {
                    // помещаем значение, прошедшее фильтр, в result
                    result.push(arr[i])
                }
            }
            return result
        }
    }

    Метод filter создает новый массив со всеми элементами, прошедшими проверку, задаваемую в передаваемой функции.    

43. Как бы Вы реализовали метод Array.prototype.reduce?

    function reduce(arr, reduceCallbak, initialValue) {
        // ..
        if (!Array.isArray(arr) || !arr.length || typeof filterCallback !== 'function') {
            return []
        } else {
            // если в функцию не было передано значения initialValue, то
            let hasInitialValue = initialValue !== undefined
            let value = hasInitialValue ? initialValue : arr[0]
            // мы будем использовать первый элемент initialValue

            // затем мы перебираем массив, начиная с 1, если в функцию не передавалось значения initialValue, либо с 0, если значение было передано
            for (let i = hasInitialValue ? 0 : 1, len = arr.length; i < len; i++) {
                // затем на каждой итерации мы присваиваем результат вызова reduceCallback переменной
                value = reduceCallback(value, arr[i], i, arr)
            }
            return value
        }
    }
    Метод reduce применяет функцию reducer к каждому элементу массива (слева-направо), возвращая одно результирующее значение.  

44. Что такое объект arguments?

    Arguments — это коллекция аргументов, передаваемых функции. Это объект, подобный массиву, у него есть свойство length, мы можем получить доступ к определенному значению с помощью arguments[i], но у него отсутствуют методы forEach, reduce, filter и map. Он позволяет узнать количество параметров функции.

    Преобразовать arguments в массив можно с помощью Array.prototype.slice:

    Array.prototype.slice.call(arguments)

    Запомните: в стрелочных функциях объект arguments не работает.

    function one() {
        return arguments
    }
    const two = function() {
        return arguments
    }
    const three = function three({
        return arguments
    })
    const four = () => arguments

    four() // arguments is not defined


    Вызов функции four приводит к ошибке ReferenceError: arguments is not defined. Эту проблему можно решить с помощью оператора rest:

    const four = (...args) => args
    Это автоматически поместит все параметры в массив.    

45. Как создать объект, не имеющий прототипа?

    Это можно сделать с помощью Object.create:

    const o1 = {}
    console.log(o1.toString) // [object Object]

    const o2 = Object.create(null) // в качестве первого параметра методу Object-create передается объект-прототип
    // нам не нужен объект-прототип, поэтому передаем null
    console.log(o2.toString) // o2.toString is not a function
          
46. Почему в представленном коде переменная b становится глобальной при вызове функции?


    function myFunc(){
        let a = b = 0
    }
    myFunc()


    Так происходит, потому что оператор присваивания ("=") имеет правостороннюю ассоциативность, т.е. присваивает значения справа налево. Поэтому код принимает следующий вид:

    function myFunc(){
        let a = (b = 0)
    }
    myFunc()


    Сначала значение 0 присваивается переменной «b», которая не объявлена. Движок JS делает ее глобальной. Возвращаемое выражением b = 0 значение (0) затем присваивается локальной переменной «a».

    Эту проблему можно решить сначала объявив локальные переменные, а затем присвоив им значения:

    function myFunc(){
        let a, b
        a = b = 0
    }
    myFunc()

47. Что такое ECMAScript?

    ECMAScript — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.    

48.  Что нового привнес в JS стандарт ES6 или ECMAScript2015?

        - Стрелочные функции (Arrow Functions).
        - Классы (Classes).
        - Шаблонные строки (Template Strings).
        - Расширенные объектные литералы (Enhanced Object literals).
        - Деструктуризация (Object Destructuring).
        - Промисы (Promises).
        - Генераторы (Generators).
        - Модули (Modules).
        - Symbol.
        - Прокси (Proxies).
        - Множества (Sets).
        - Параметры по умолчанию.
        - Операторы rest и spread.
        - Блочная область видимости (ключевые слова «let» и «const»).

49. В чем разница между ключевыми словами «var», «let» и «const»?

      Переменные, объявленные с помощью ключевого слова «var», являются глобальными. Это означает, что они доступны из любого места в коде:

      function giveMeX(showX){
          if(showX){
              var x = 5
          }
          return x
      }

      console.log(giveMeX(false))
      console.log(giveMeX(true))

      Результатом первого console.log будет undefined, второго — 5. Мы имеем доступ к переменной «x» из-за ее всплытия в глобальную область видимости. Код из примера выше интерпретируется следующим образом:

      function giveMeX(showX){
          var x // имеет значение undefined
          if(showX){
              x = 5
          }
          return x
      }

      Результатом первого console.log является undefined, поскольку объявленные переменные, которым не присвоено значения, имеют значение undefined по умолчанию.
      Переменные, объявленные с помощью ключевых слов «let» и «const» имеют блочную область видимости. Это означает, что они доступны только внутри блока ({ }):

      function giveMeX(showX){
          if(showX){
              let x = 5
          }
          return x
      }

      function giveMeY(showY){
          if(showY){
              let y = 5
          }
          return y
      }

      Вызов этих функций с параметром false приведет к ошибке ReferenceError, потому что к переменным «x» и «y» нет доступа снаружи блока и их значения не возвращаются (не всплывают).
      Разница между «let» и «const» состоит в том, что в первом случае мы может менять значение переменной, а во втором — нет (константа). При этом, мы можем менять значение свойства объекта, объявленного с помощью const, но не само свойство (переменную).        

50. Что такое стрелочные функции (Arrow Functions)?

        Стрелочная функция — это относительно новый способ создания функций в JS. Стрелочные функции создаются быстрее и имеют более читаемый синтаксис, чем функциональные выражения. В стрелочных функциях опускается слово «function»:

        // ES5
        var getCurrentDate = function(){
            return new Date()
        }

        // ES6
        const getCurrentDate = () => new Date()


        В функциональном выражении мы используем ключевое слово «return» для возврата значения. В стрелочной функции мы этого не делаем, поскольку стрелочные функции неявно возвращают значения при условии, что мы возвращаем одно выражение или значение:

        // ES5
        function greet(name){
            return 'Hello ' + name + '!' 
        }

        // ES6
        const greet = (name) => `Hello ${name}`
        const greet2 = name = > `Hello ${name}`


        Мы также можем передавать параметры стрелочным функциям. Если мы передаем один параметр, его можно не оборачивать в круглые скобки:

        const getArgs = () => arguments
        const getArgs2 = (...rest) => rest


        У стрелочных функций нет доступа к объекту arguments. Поэтому вызов первой функции приведет к ошибке. Для получения параметров, переданных функции, мы можем использовать оператор rest.

        const data = {
            result: 0
            nums: [1,2,3,4,5]
            computeResult(){
                // this ссылается на объект data
                const addAll = () => {
                // стрелочные функции копируют значение this из лексического окружения
                return this.nums.reduce((total, cur) => total + cur, 0)
                }
            this.result = addAll()
            }
        }
        
        