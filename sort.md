1. Алгоритм пузырьковой сортировки.

  Пузырьковая сортировка, иногда называемая сортировкой погружением, представляет собой простой алгоритм сортировки, который многократно проходит через список для сортировки, сравнивает каждую пару соседних элементов и меняет их местами, если они расположены в неправильном порядке (по возрастанию или по убыванию). Проход по списку повторяется до тех пор, пока перестановки не понадобятся, что указывает на то, что список отсортирован.


        const bubblesortArray = (arr) => {
          let newArr = [...arr]
          for (let i = 0; i < newArr.length; i++) {
            for (let j = 0; j < newArr.length; j++) {
              if(newArr[i] < newArr[j]) {
                let cur = newArr[i]
                newArr[i] = newArr[j]
                newArr[j] = cur
              }      
            }    
          } console.log(newArr)
        }

        bubblesortArray([4, 6, 5, 9, 1, 3, 7, 2, 8, 10])

  Сложность
  Имя	                    Лучший	Средний	Худший	Память	Стабильный	Комментарии
  Пузырьковая сортировка    n	      n2	    n2	    1	        Yes	
	      


2. Сложность алгоритмов
  
   ![](./BIG_O.png)      



3. Задача

![](./2022-06-17_18-39-12.png)


4. Сортировка выбором

   Сортировка выбором — это алгоритм сортировки, в частности сортировка сравнением на месте. Он имеет временную сложность O(n2), что делает его неэффективным для больших списков и, как правило, работает хуже, чем аналогичная сортировка вставками. Сортировка выбором известна своей простотой и имеет преимущества в производительности по сравнению с более сложными алгоритмами в определенных ситуациях, особенно когда вспомогательная память ограничена.

  Сложность
  Имя	                Лучший	Средний	Худший	Память	Стабильный	Комментарии
  Сортировка выбором	  n2	    n2	    n2	    1	        No


5. Сортировка вставками
   Сортировка вставками — это простой алгоритм сортировки, который строит окончательный отсортированный массив (или список) по одному элементу за раз. Он гораздо менее эффективен для больших списков, чем более продвинутые алгоритмы, такие как быстрая сортировка, пирамидальная сортировка или сортировка слиянием.

  Сложность
  Имя	                  Лучший	Средний	Худший	Память	Стабильный	Комментарии
  Сортировка вставками	  n	      n2	    n2	    1	       Yes


6. Сортировка кучей

   Алгоритм выстраивает данные в виде двоичного дерева (двоичной кучи). Существует два варианта расположения элементов – max-heap (значение родителя больше значений потомков) и min-heap (значение родителя меньше значений потомков). Наибольший / наименьший элемент (в зависимости от типа) располагается в корне дерева. Он меняется местами с последним элементом кучи и помещается в конец массива. Размер кучи уменьшается на 1, после чего она перестраивается. Цикл повторяется, пока размер кучи больше 1.


7. * Сортировка пузырьком	
    Один из простейших методов сортировки. Заключается в постепенном смещении элементов с большим значением в конец массива. Элементы последовательно сравниваются попарно, и если порядок в паре нарушен – меняются местами.

   * Сортировка выбором
   	Алгоритм ищет наименьший элемент в текущем списке и производит обмен его значения со значением первой неотсортированной позиции. То же самое происходит со вторым элементом с наименьшим значением. Цикл повторяется до тех пор, пока все элементы не займут нужную последовательность.
   
   * Быстрая сортировка
   	Считается одним из самых быстрых алгоритмов сортировки. Как и сортировка слиянием, работает по принципу «разделяй и властвуй». Временная сложность алгоритма может достигать O(n log n).

          function quickSort(arr) {
            if (arr.length < 2) return arr;
            let pivot = arr[0];
            const left = [];
            const right = [];
            
          for (let i = 1; i < arr.length; i++) {
            if (pivot > arr[i]) {
              left.push(arr[i]);
            } else {
              right.push(arr[i]);
            }
          }
          return quickSort(left).concat(pivot, quickSort(right));
        }

   * Сортировка кучей (Пирамидальная сортировка)
   	Алгоритм выстраивает данные в виде двоичного дерева (двоичной кучи). Существует два варианта расположения элементов – max-heap (значение родителя больше значений потомков) и min-heap (значение родителя меньше значений потомков). Наибольший / наименьший элемент (в зависимости от типа) располагается в корне дерева. Он меняется местами с последним элементом кучи и помещается в конец массива. Размер кучи уменьшается на 1, после чего она перестраивается. Цикл повторяется, пока размер кучи больше 1.

   * Сортировка вставками.
   	Применяется для вставки элементов массива на «свое место». Сортировка вставками представляет собой простой метод сортировки и используется для раскладки колоды во время игры в бридж.


          function insertion(arr) {            
            for (let i = 1; i < array.length; i++) {
              for (let j = i - 1; j > -1; j--) {
                if(arr[j+1] < arr[j]) {
                  [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]
                }    
              }    
            }
            return arr
          }
          console.log(insertion([3,5,7,9,1,2,4,6,8]))



   * Сортировка слиянием. 
   	  Следует принципу «разделяй и властвуй», согласно которому массив данных разделяется на равные части, которые сортируются по-отдельности. После они сливаются, в результате получается отсортированный массив.   

        
          let array = [1, 7, 3, 9, 8, 4, 5, 2, 6, 10]

          function merge (left, right) {
            let sortArray = []
            while (left.length && right.length) {
              if(left[0] < right[0]) {
                sortArray.push(left.shift())
              } else {
                sortArray.push(right.shift())
              }
            }
            return [...sortArray, ...left, ...right]
          }

          function bifurcateArray(arr) {
            if(arr.length <= 1) {
              return arr;
            }
            const half = arr.length/2;
            let left = arr.splice(0, half)
            let right = arr
            let res = merge(bifurcateArray(left), bifurcateArray(right))
            return res
          }
          bifurcateArray(array)

8. Каррирование 

        function multiply(a, b, c) {
          return a * b * c;
        }

        function multiply(a) {
            return (b) => {
                return (c) => {
                    return a * b * c
                }
            }
        }
        log(multiply(1)(2)(3)) // 6

9. Быстрая сортировка (leedcode)

        function sortArray(nums: number[]): number[] {
            if (nums === null || nums.length === 0) {
                return nums;
            }
        
            let minVal: number = nums[0];
            let maxVal: number = nums[0];
            
            for (let i = 1; i < nums.length; i++) {
                if (nums[i] < minVal) minVal = nums[i];
                if (nums[i] > maxVal) maxVal = nums[i];
            }
        
            let range: number = maxVal - minVal + 1;
            const counts: number[] = new Array(range).fill(0);
        
            for (let i = 0; i < nums.length; i++) {
                let idx = nums[i] - minVal;
                counts[idx]++;
            }
        
            let index = 0;
            for (let i = 0; i < range; i++) {
                while (counts[i]) {
                    nums[index++] = i + minVal;
                    counts[i]--;
                }
            }
        
            return nums;
        };
