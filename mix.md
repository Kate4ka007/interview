1. Бинарная система.

  Двоичная система счисления — позиционная система счисления с основанием 2.  Основание данной системы равно двум, то есть используется только два символа для записи чисел. Благодаря непосредственной реализации в цифровых электронных схемах на логических вентилях, двоичная система используется практически во всех современных компьютерах и прочих вычислительных электронных устройствах.

              64  32  16  8   4   2    1
      число   1   1   0   1   1   1    0  =   64х1  + 32х1 + 16х0 + 8х1 + 4х1 + 2х1 + 1х0 = 110
              

              4   2   1
      число   1   1   1   =  4х1 + 2х1 + 1х1 = 7 


      11 = 2х1 + 1х1 = 3

      10 = 2х1 + 1х0 = 2



2.  Алгоритм перевода в бинарную систему

        function convertToBinary (number) {
            let num = number;
            let binary = (num % 2).toString();
            for (; num > 1; ) {
                num = parseInt(num / 2);
                binary =  (num % 2) + (binary);
            }
            console.log(binary);
        }


3. Типы данных в  JavaScript

   Типы данных можно разделить на два вида

   - Примитивные типы данных
   - Непримитивные типы данных (ссылки на объекты)

   * Примитивные типы данных в JavaScript включают в себя:

    - Числа (Numbers) - Целые числа, числа с плавающей точкой: typeof instance === "number"
    - Строки (Strings) - Любые данные в одинарных или двойных кавычках: typeof instance === "string"
    - Булевые (boolean) - true или false значения: typeof instance === "boolean"
    - Undefined - объявленная переменная без значения:  typeof instance === "undefined"
    - BigInt  : typeof instance === "bigint"
    - Symbol (в ECMAScript 6)  : typeof instance === "symbol"
    - Null - пустое значение или нет значения: typeof instance === "object". Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в Цепочке Прототипов;

   * Object (Объект) : typeof instance === "object". Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова new: new Object, new Array, new Map, new Set, new WeakMap, new WeakSet, new Date и множество других структур;  instanceof - проверка на вид  конструктора


   Непримитивные типы данных в JavaScript включают в себя:
   - Объекты
   - Функции
   - Массивы

4. Преобразование типов 

   Преобразование типов это процесс конвертации значения из одного типа в другой (как например, строки в число, объекта к булевому значению и т. д.). Любой тип, будь то примитив или объект, может быть преобразован в другой тип.  

   Преобразование типов может происходить явно и неявно.

   Когда разработчик хочет намеренно произвести преобразование типов, написав, к примеру Number(value), это называется явным преобразованием типов (или type casting).

   Так как JavaScript это слабо типизированный язык, преобразование между разными типами может происходить автоматически, и это называется неявным преобразованием типов. 


   * Строковое преобразование
   Строковое преобразование происходит, когда требуется представление чего-либо в виде строки.

   Например, alert(value) преобразует значение к строке.
   Также мы можем использовать функцию String(value), чтобы преобразовать значение к строке:

            let value = true;
            alert(typeof value); // boolean

            value = String(value); // теперь value это строка "true"
            alert(typeof value); // string

   Преобразование происходит очевидным образом. false становится "false", null становится "null" и т.п.

   * Численное преобразование
   Численное преобразование происходит в математических функциях и выражениях.

   Например, когда операция деления / применяется не к числу:

        alert( "6" / "2" ); // 3, строки преобразуются в числа

   Мы можем использовать функцию Number(value), чтобы явно преобразовать value к числу:

        let str = "123";
        alert(typeof str); // string

        let num = Number(str); // становится числом 123

        alert(typeof num); // number

   Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм.

   Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN. Например:

        let age = Number("Любая строка вместо числа");

        alert(age); // NaN, преобразование не удалось

   Правила численного преобразования:

        Значение	        Преобразуется в…
        undefined	        NaN
        null	            0
        true / false	    1 / 0
        string          	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.

    Примеры:

            alert( Number("   123   ") ); // 123
            alert( Number("123z") );      // NaN (ошибка чтения числа на месте символа "z")
            alert( Number(true) );        // 1
            alert( Number(false) );       // 0

    Учтите, что null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN.
    Большинство математических операторов также производит данное преобразование, как мы увидим в следующей главе.

    * Логическое преобразование
    Логическое преобразование самое простое.

    Происходит в логических операциях (позже мы познакомимся с условными проверками и подобными конструкциями), но также может быть выполнено явно с помощью функции Boolean(value).

    Правило преобразования:

    Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
    Все остальные значения становятся true.
    Например:

            alert( Boolean(1) ); // true
            alert( Boolean(0) ); // false

            alert( Boolean("Привет!") ); // true
            alert( Boolean("") ); // false

    Заметим, что строчка с нулём "0" — это true
    Некоторые языки (к примеру, PHP) воспринимают строку "0" как false. Но в JavaScript, если строка не пустая, то она всегда true.

            alert( Boolean("0") ); // true
            alert( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)


5. Switch

   Конструкция switch заменяет собой сразу несколько if.

   Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.

   Синтаксис
   Конструкция switch имеет один или более блок case и необязательный блок default.

   Выглядит она так:

        switch(x) {
        case 'value1':  // if (x === 'value1')
            ...
            [break]

        case 'value2':  // if (x === 'value2')
            ...
            [break]

        default:
            ...
            [break]
        }
        
Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
Если ни один case не совпал – выполняется (если есть) вариант default.

6. Разница между function declaration и function expression?

   Function Declaration - функция, объявленная в основном потоке кода.

        // Function Declaration
        function sum(a, b) {
        return a + b;
        }


   Function Expression - объявление функции в контексте какого-либо выражения, например присваивания.

        // Function Expression
        var sum = function(a, b) {
        return a + b;
        }


    Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.

    Поэтому их можно вызвать до объявления, например:

            sayHi("Вася"); // Привет, Вася

            function sayHi(name) {
            console.log( "Привет, " + name );
            }

    А если бы это было объявление Function Expression, то такой вызов бы не сработал:

            sayHi("Вася"); // ошибка!

            var sayHi = function(name) {
            console.log( "Привет, " + name );
            }    


7.  Типы таймеров в JavaScript?

    Таймеры – это функции высшего порядка, при помощи которых можно откладывать или повторять выполнение других функций (таймер получает такую функцию в качестве первого аргумента).

    Вот пример отложенного выполнения:

            // example1.js
            setTimeout(
            () => {
                console.log('Hello after 4 seconds');
            },
            4 * 1000
            );


    ...

7.  Что такое поднятие (Hoisting)?

    Поднятие или hoisting — это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен. Как следствие, это означает то, что совершенно неважно где были объявлены функция или переменные, все они передвигаются вверх своей области видимости, вне зависимости от того локальная она или же глобальная.
    Стоит отметить то, что механизм “поднятия” передвигает только объявления функции или переменной. Назначения переменным остаются на своих местах.
    - все необъявленные переменные это по факту глобальные переменные

    Одним из преимуществ помещения в память объявлений функций до выполнения кода то, что можно использовать функцию до её объявления. Даже если мы вызываем функцию до её объявления, код работает. Это происходит благодаря тому, как работает контекст выполнения в JavaScript.
    Hoisting хорошо работает и с другими типами данных и переменными. Переменные могут быть инициализированы и использованы до их объявления. Однако, они не могут быть использованы без инициализации.

8.  Что такое область видимости (Scope)?

    Область видимости (scope) определяет видимость или доступность переменной (другого ресурса) в области кода.

    - глобальная   
        В JavaScript есть только одна глобальная область. Область за пределами всех функций считается глобальной областью, и переменные, определенные в глобальной области, могут быть доступны и изменены в любых других областях.

    - локальная Local scope
        Переменные, объявленные внутри функций, становятся локальными для функции и рассматриваются в соответствующей локальной области. Каждая функция имеет свою область видимости. Одна и та же переменная может использоваться в разных функциях, поскольку они связаны с соответствующими функциями и не являются взаимно видимыми.
        Локальная область видимости может быть разделена на область видимости функции и область видимости блока. Концепция область видимости блока или block scope была представлена в ECMAScript6 (ES6) вместе с новыми способами объявления переменных - const и let.
        * Область видимости функции
            Всякий раз, когда мы объявляем переменную в функции, переменная видна только внутри функции. Мы не можем получить к ней доступ вне функции. var - это ключевое слово, определяющее переменную для доступности области функций.
        * Область видимости блока
            Область видимости блока - это область в условиях if и switch или циклов for, и while. Вообще говоря, всякий раз, когда мы видим фигурные скобки {} - это блок. В ES6 ключевые слова const и let позволяют разработчикам объявлять переменные в области видимости блока, что означает, что эти переменные существуют только в соответствующем блоке.

    Лексическая область видимости
    Ещё один момент, о котором стоит упомянуть - это лексическая область. Лексическая область означает, что дочерняя область имеет доступ к переменным, определенным в родительской области. Дочерние функции лексически связаны с контекстом исполнения их родителей.   

    - Лексическая область видимости - это набор правил о том, как и где движок JavaScript может найти переменную. Ключевой характеристикой лексического контекста является то, что он определяется во время написания кода (при условии, что мы не используем eval () или with).
    - Динамическая область видимости, по понятным причинам, подразумевает, что существует модель, в которой область видимости может определяться динамически во время выполнения, а не статически во время создания.     

    Лексическая область - определяется во время написания кода, тогда как динамическая область (и this) - во время выполнения. Лексическая область заботится о том, где была объявлена функция, а динамическая область - о том, откуда была вызвана функция. И наконец: this заботится о том, как была вызвана функция. Это показывает нам, насколько тесно механизм this связан с идеей динамической области видимости.

9. Разница между var, let и const?

   * var -  Var-объявления могут обладать видимостью глобальной или локальной (область видимости в пределах функции).
    Переменная var является глобальной, когда объявлена вне какой-либо функции. Это означает, что любая переменная, объявленная через var вне блока функции, доступна для использования во всем окне.
    Var является локальной, когда объявлена внутри функции. Это означает, что она доступна и к ней можно обращаться только изнутри этой функции.
     - переменные var поднимаются в верхнюю часть своей области видимости и инициализируются со значением undefined.

   * let -  let имеет блочную область видимости. Блок — это фрагмент кода, ограниченный фигурными скобками {}. Всё, что находится внутри фигурных скобок, относится к блоку. Таким образом, переменная, объявленная в блоке через let, будет доступна только внутри этого блока. 

        Точно так же, как и в случае с var, переменные, объявленные через let, можно обновлять внутри их области видимости. Но, в отличие от var, let-переменные нельзя повторно объявить внутри области видимости. 

        Точно так же, как в случае с var, объявления через let перемещаются вверх. Но в отличие от var-переменных, которые инициализируются как undefined, ключевое слово для let не инициализируется. Так что если вы попытаетесь использовать переменную let до того, как она будет объявлена, то получите ошибку обращения к переменной ReferenceError.


    * const - Переменные, объявленные через const, сохраняют постоянные значения. Объявления через const имеют некоторое сходство с объявлениями через let.  
        - const имеет блочную область видимости. Точно как и в случае с let, переменные, объявленные через const, могут быть доступны только внутри того блока, где были объявлены.
        - Переменные const не могут быть ни обновлены, ни объявлены повторно. Это означает, что значение переменной, объявленной через const, остается неизменным внутри ее области видимости. Нельзя ни обновить его, ни объявить повторно. 
        - каждое объявление через const должно быть инициализировано в момент объявления. Это поведение несколько отличается, когда речь идет об объектах, объявленных через const. Пускай const-объект не может быть обновлен, свойства таких объектов обновлять можно. 
        - Точно так же, как и let, объявления через const перемещаются вверх, но не инициализируются.



    Так что на случай, если вы упустили суть отличий, то вот они вкратце:
    - Переменные, объявленные через var, могут быть глобальными или иметь область видимости в рамках функции; let и const имеют блочную область видимости.
    - var-переменные могут быть как обновлены, так и переопределены внутри области видимости; let-переменные можно обновлять, но не переопределять; const-переменные нельзя ни обновлять, ни переопределять.
    - Со всеми ними осуществляется поднятие наверх области видимости. Но если var-переменные при этом инициализируются как undefined, let и const не инициализируются.
    - В то время как var и let можно объявить, но не инициализировать, const необходимо инициализировать во время объявления.    

10. Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.

11. Что обозначает this в JavaScript?

    Свойство контекста выполнения кода (global, function или eval), которое в нестрогом режиме всегда является ссылкой на объект.В большинстве случаев значение this определяется тем, каким образом вызвана функция. Значение this не может быть установлено путём присваивания во время исполнения кода и может иметь разное значение при каждом вызове функции. В ES5 представлен метод bind(), который используется для привязки значения ключевого слова this независимо от того, как вызвана функция. Также в ES2015 представлены стрелочные функции, которые не создают собственные привязки к this (они сохраняют значение this лексического окружения, в котором были созданы).


12. Функции высшего порядка — это функции, которые работают с другими функциями, либо принимая их в виде параметров, либо возвращая их. Проще говоря, функцией высшего порядка называется такая функция, которая принимает функцию как аргумент или возвращает функцию в виде выходного значения.


13. Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?

    Для явного преобразования к булевому значению, нужно применить функцию Boolean() или !!. Неявное преобразование происходит в логическом контексте if (val) { … } или при применении логических операторов (|| && !)

    Поскольку существует всего два возможных результата преобразования, легче просто запомнить список ложных значений:

        Boolean('')           // false
        Boolean(0)            // false     
        Boolean(-0)           // false
        Boolean(NaN)          // false
        Boolean(null)         // false
        Boolean(undefined)    // false
        Boolean(false)        // false


14. Методы строк в JavaScript? 

    - Как изменить регистр
        * toLowerCase - преобразует символы в строке в нижний регистр.

                "Hello Tproger".toLowerCase(); // "hello tproger"

        * toUpperCase - Преобразует символы в строке в верхний регистр.

                "Hello Tproger".toUpperCase(); // "HELLO TPROGER"

    - Как объединить строки
        * concat - Объединяет две или более строки и возвращает одну строку.

                "Hello".concat(" Tproger"); // "Hello Tproger"
                "Hello".concat(" T", "p", "r", "o", "g", "e", "r"); // "Hello Tproger"

    - Как разделить строку на подстроки
        * split - Разбивает строку в массив по указанному разделителю, которым может быть подстрока или регулярное выражение. Вторым параметром можно указать ограничитель.

                // Получаем каждый символ
                "Hello Tproger".split(""); // ["H", "e", "l", "l", "o", " ", "T", "p", "r", "o", "g", "e", "r"]

                // Получаем каждое слово из строки
                "Hello Tproger".split(" "); //["Hello", "Tproger"]

                // Устанавливаем ограничитель
                "Hello Tproger".split(" ", 1); //["Hello"]

    - Как повторить строку
        * repeat - Принимает в качестве параметра число и повторяет строку указанное количество раз.

                "Tproger ".repeat(3); // "Tproger Tproger Tproger "

    - Как найти подстроку
        * charAt - Возвращает символ по указанному индексу.

                "Hello Tproger".charAt(); // "H"

        * includes - Проверяет, содержит ли строка указанную подстроку. Возвращает значение true или false. Вторым параметром можно указать позицию в строке, с которой следует начать поиск.

                "Hello Tproger".includes("Tproger"); // true
                "Hello Tproger".includes("Hello", 1); // false

        * indexOf - Возвращает индекс первого найденного вхождения указанного значения. Поиск ведётся от начала до конца строки. Если совпадений нет, возвращает -1. Вторым параметром можно передать позицию, с которой следует начать поиск.

                "Hello World".indexOf("o"); // 4
                "Hello World".indexOf("o", 5); // 7

        * lastIndexOf - Возвращает индекс последнего найденного вхождения указанного значения. Поиск ведётся от конца к началу строки. Если совпадений нет, возвращает -1. Вторым параметром можно передать позицию, с которой следует начать поиск.

                "Hello World".lastIndexOf("o"); // 7
                "Hello World".lastIndexOf("o", 5); // 4

        * endsWith - Проверяет, заканчивается ли строка символами, заданными первым параметром. Возвращает true или false. Есть второй необязательный параметр — ограничитель по диапазону поиска. По умолчанию он равен длине строки.

                "Hello Tproger".endsWith("Tproger"); // true
                "Hello Tproger".endsWith("Tproger", 12); // false

        * startsWith - Проверяет, начинается ли строка с указанных символов. Возвращает true или false. Вторым параметром можно указать индекс, с которого следует начать проверку.

                "Hello Tproger".startsWith("Hello"); // true
                "Hello Tproger".startsWith("Hello", 1); // 
            
        * search - Проверяет, есть ли в строке указанное значение или регулярное выражение и возвращает индекс начала совпадения.

                "hi, hello, hey".search("hello"); // 4

    - Как извлечь подстроку
        * slice - Извлекает часть строки и возвращает новую строку. Обязательный параметр — начало извлечения. Вторым параметром можно установить границу (по умолчанию — до конца строки).

                "Методы строк на Tproger".slice(16); // "Tproger"
                "Методы строк на Tproger".slice(16, 21); // "Tprog"

                // Отрицательные значения тоже работают
                "Методы строк на Tproger".slice(-7); // "Tproger"
                "Методы строк на Tproger".slice(-7, -2); // "Tprog"

        * substring - Извлекает символы из строки между двумя указанными индексами. Второй индекс указывать не обязательно. В таком случае будут извлечены все символы от начала до конца строки. В отличие от slice, можно задавать start больше, чем end. Отрицательные значения не поддерживаются, они интерпретируются как 0.

                "Методы строк на Tproger".substring(5, 2); // "тод"

        * substr - Извлекает часть строки указанной длины. Первым параметром принимает стартовую позицию, вторым — длину. Значение первого параметра может быть отрицательным, тогда позиция определяется с конца строки.

                "Методы строк на Tproger".substr(7, 5); // "строк"
                "Методы строк на Tproger".substr(-7, 5); // "Tprog"

    - Как заменить подстроку
        * replace - Ищет в строке указанное значение или регулярное выражение и возвращает новую строку, в которой выполнена замена на второй параметр. Можно заменить найденные значения другой строкой или передать функцию для работы над совпадениями.

                "hi, hello, hi".replace("hi", "hey"); // "hey, hello, hi"
                "hi, hello, hi".replace(/hi/g, "hey"); // "hey, hello, hey"

        * replaceAll - Даёт такой же результат, как метод replace() с глобальным флагом g. Заменяет все найденные совпадения другой строкой или переданной функцией.

                "hi, hello, hi".replaceAll("hi", "hey"); // "hey, hello, hey"

    - Как добавить в строку пробелы или другие символы
        * padEnd - Добавляет в конце отступы, пока строка не достигнет длины, заданной первым параметром. Вторым параметром можно указать другой символ вместо пробела.

                "Hello Tproger".padEnd(20, "*"); // "Hello Tproger*******"

        * padStart - Добавляет в начале отступы, пока строка не достигнет длины, заданной первым параметром. Вторым параметром можно указать другой символ вместо пробела.

                "Hello Tproger".padStart(20, "*"); // "*******Hello Tproger"

    - Как удалить пробелы в строке
        * trim - Обрезает пробелы с обоих концов строки.

                "   Hello Tproger ".trim(); // "Hello Tproger"

        * trimEnd - Обрезает пробелы в конце строки

                "   Hello Tproger ".trimEnd(); // "   Hello Tproger"

        * trimStart - Обрезает пробелы в начале строки

                "   Hello Tproger ".trimStart(); // "Hello Tproger "


    - Как работать с Юникодом
        * charCodeAt - Возвращает числовое значение Юникода по указанному индексу. Обратите внимание: у букв в верхнем и нижнем регистрах разные коды.

                "T".charCodeAt() // 84
                "t".charCodeAt() // 116

        * fromCharCode - Преобразует числовые значения Юникода в читаемые символы.

                String.fromCharCode(72, 101, 108, 108, 111); // "Hello"

    Примечание: при работе с эмодзи, редкими математическими символами, иероглифами нужно помнить о суррогатных парах. Это символы, которые записываются двумя 16-битными словами. Длина таких строк — 2.

                '?'.length; // 2, редкий китайский иероглиф

    Суррогатные пары не учитывались при создании JS и методы строк charCodeAt / fromCharCode обрабатывают их некорректно. Правильно работают с суррогатными парами редкие методы String.fromCodePoint и str.codePointAt, которые появились в языке недавно.        