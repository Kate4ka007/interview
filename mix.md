1. Бинарная система.

  Двоичная система счисления — позиционная система счисления с основанием 2.  Основание данной системы равно двум, то есть используется только два символа для записи чисел. Благодаря непосредственной реализации в цифровых электронных схемах на логических вентилях, двоичная система используется практически во всех современных компьютерах и прочих вычислительных электронных устройствах.

              64  32  16  8   4   2    1
      число   1   1   0   1   1   1    0  =   64х1  + 32х1 + 16х0 + 8х1 + 4х1 + 2х1 + 1х0 = 110
              

              4   2   1
      число   1   1   1   =  4х1 + 2х1 + 1х1 = 7 


      11 = 2х1 + 1х1 = 3

      10 = 2х1 + 1х0 = 2



2.  Алгоритм перевода в бинарную систему

        function convertToBinary (number) {
            let num = number;
            let binary = (num % 2).toString();
            for (; num > 1; ) {
                num = parseInt(num / 2);
                binary =  (num % 2) + (binary);
            }
            console.log(binary);
        }


3. Типы данных в  JavaScript

   Типы данных можно разделить на два вида

   - Примитивные типы данных
   - Непримитивные типы данных (ссылки на объекты)

   * Примитивные типы данных в JavaScript включают в себя:

    - Числа (Numbers) - Целые числа, числа с плавающей точкой: typeof instance === "number"
    - Строки (Strings) - Любые данные в одинарных или двойных кавычках: typeof instance === "string"
    - Булевые (boolean) - true или false значения: typeof instance === "boolean"
    - Undefined - объявленная переменная без значения:  typeof instance === "undefined"
    - BigInt  : typeof instance === "bigint"
    - Symbol (в ECMAScript 6)  : typeof instance === "symbol"
    - Null - пустое значение или нет значения: typeof instance === "object". Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в Цепочке Прототипов;

   * Object (Объект) : typeof instance === "object". Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова new: new Object, new Array, new Map, new Set, new WeakMap, new WeakSet, new Date и множество других структур;  instanceof - проверка на вид  конструктора


   Непримитивные типы данных в JavaScript включают в себя:
   - Объекты
   - Функции
   - Массивы

4. Преобразование типов 

   Преобразование типов это процесс конвертации значения из одного типа в другой (как например, строки в число, объекта к булевому значению и т. д.). Любой тип, будь то примитив или объект, может быть преобразован в другой тип.  

   Преобразование типов может происходить явно и неявно.

   Когда разработчик хочет намеренно произвести преобразование типов, написав, к примеру Number(value), это называется явным преобразованием типов (или type casting).

   Так как JavaScript это слабо типизированный язык, преобразование между разными типами может происходить автоматически, и это называется неявным преобразованием типов. 


   * Строковое преобразование
   Строковое преобразование происходит, когда требуется представление чего-либо в виде строки.

   Например, alert(value) преобразует значение к строке.
   Также мы можем использовать функцию String(value), чтобы преобразовать значение к строке:

            let value = true;
            alert(typeof value); // boolean

            value = String(value); // теперь value это строка "true"
            alert(typeof value); // string

   Преобразование происходит очевидным образом. false становится "false", null становится "null" и т.п.

   * Численное преобразование
   Численное преобразование происходит в математических функциях и выражениях.

   Например, когда операция деления / применяется не к числу:

        alert( "6" / "2" ); // 3, строки преобразуются в числа

   Мы можем использовать функцию Number(value), чтобы явно преобразовать value к числу:

        let str = "123";
        alert(typeof str); // string

        let num = Number(str); // становится числом 123

        alert(typeof num); // number

   Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм.

   Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN. Например:

        let age = Number("Любая строка вместо числа");

        alert(age); // NaN, преобразование не удалось

   Правила численного преобразования:

        Значение	        Преобразуется в…
        undefined	        NaN
        null	            0
        true / false	    1 / 0
        string          	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.

    Примеры:

            alert( Number("   123   ") ); // 123
            alert( Number("123z") );      // NaN (ошибка чтения числа на месте символа "z")
            alert( Number(true) );        // 1
            alert( Number(false) );       // 0

    Учтите, что null и undefined ведут себя по-разному. Так, null становится нулём, тогда как undefined приводится к NaN.
    Большинство математических операторов также производит данное преобразование, как мы увидим в следующей главе.

    * Логическое преобразование
    Логическое преобразование самое простое.

    Происходит в логических операциях (позже мы познакомимся с условными проверками и подобными конструкциями), но также может быть выполнено явно с помощью функции Boolean(value).

    Правило преобразования:

    Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
    Все остальные значения становятся true.
    Например:

            alert( Boolean(1) ); // true
            alert( Boolean(0) ); // false

            alert( Boolean("Привет!") ); // true
            alert( Boolean("") ); // false

    Заметим, что строчка с нулём "0" — это true
    Некоторые языки (к примеру, PHP) воспринимают строку "0" как false. Но в JavaScript, если строка не пустая, то она всегда true.

            alert( Boolean("0") ); // true
            alert( Boolean(" ") ); // пробел это тоже true (любая непустая строка это true)


5. Switch

   Конструкция switch заменяет собой сразу несколько if.

   Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.

   Синтаксис
   Конструкция switch имеет один или более блок case и необязательный блок default.

   Выглядит она так:

        switch(x) {
        case 'value1':  // if (x === 'value1')
            ...
            [break]

        case 'value2':  // if (x === 'value2')
            ...
            [break]

        default:
            ...
            [break]
        }
        
Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
Если ни один case не совпал – выполняется (если есть) вариант default.

6. Разница между function declaration и function expression?

   Function Declaration - функция, объявленная в основном потоке кода.

        // Function Declaration
        function sum(a, b) {
        return a + b;
        }


   Function Expression - объявление функции в контексте какого-либо выражения, например присваивания.

        // Function Expression
        var sum = function(a, b) {
        return a + b;
        }


    Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.

    Поэтому их можно вызвать до объявления, например:

            sayHi("Вася"); // Привет, Вася

            function sayHi(name) {
            console.log( "Привет, " + name );
            }

    А если бы это было объявление Function Expression, то такой вызов бы не сработал:

            sayHi("Вася"); // ошибка!

            var sayHi = function(name) {
            console.log( "Привет, " + name );
            }    


7.  Типы таймеров в JavaScript?

    Таймеры – это функции высшего порядка, при помощи которых можно откладывать или повторять выполнение других функций (таймер получает такую функцию в качестве первого аргумента).

    Вот пример отложенного выполнения:

            // example1.js
            setTimeout(
            () => {
                console.log('Hello after 4 seconds');
            },
            4 * 1000
            );


    ...

7.  Что такое поднятие (Hoisting)?

    Поднятие или hoisting — это механизм в JavaScript, в котором переменные и объявления функций, передвигаются вверх своей области видимости перед тем, как код будет выполнен. Как следствие, это означает то, что совершенно неважно где были объявлены функция или переменные, все они передвигаются вверх своей области видимости, вне зависимости от того локальная она или же глобальная.
    Стоит отметить то, что механизм “поднятия” передвигает только объявления функции или переменной. Назначения переменным остаются на своих местах.
    - все необъявленные переменные это по факту глобальные переменные

    Одним из преимуществ помещения в память объявлений функций до выполнения кода то, что можно использовать функцию до её объявления. Даже если мы вызываем функцию до её объявления, код работает. Это происходит благодаря тому, как работает контекст выполнения в JavaScript.
    Hoisting хорошо работает и с другими типами данных и переменными. Переменные могут быть инициализированы и использованы до их объявления. Однако, они не могут быть использованы без инициализации.

8.  Что такое область видимости (Scope)?

    Область видимости (scope) определяет видимость или доступность переменной (другого ресурса) в области кода.

    - глобальная   
        В JavaScript есть только одна глобальная область. Область за пределами всех функций считается глобальной областью, и переменные, определенные в глобальной области, могут быть доступны и изменены в любых других областях.

    - локальная Local scope
        Переменные, объявленные внутри функций, становятся локальными для функции и рассматриваются в соответствующей локальной области. Каждая функция имеет свою область видимости. Одна и та же переменная может использоваться в разных функциях, поскольку они связаны с соответствующими функциями и не являются взаимно видимыми.
        Локальная область видимости может быть разделена на область видимости функции и область видимости блока. Концепция область видимости блока или block scope была представлена в ECMAScript6 (ES6) вместе с новыми способами объявления переменных - const и let.
        * Область видимости функции
            Всякий раз, когда мы объявляем переменную в функции, переменная видна только внутри функции. Мы не можем получить к ней доступ вне функции. var - это ключевое слово, определяющее переменную для доступности области функций.
        * Область видимости блока
            Область видимости блока - это область в условиях if и switch или циклов for, и while. Вообще говоря, всякий раз, когда мы видим фигурные скобки {} - это блок. В ES6 ключевые слова const и let позволяют разработчикам объявлять переменные в области видимости блока, что означает, что эти переменные существуют только в соответствующем блоке.

    Лексическая область видимости
    Ещё один момент, о котором стоит упомянуть - это лексическая область. Лексическая область означает, что дочерняя область имеет доступ к переменным, определенным в родительской области. Дочерние функции лексически связаны с контекстом исполнения их родителей.   

    - Лексическая область видимости - это набор правил о том, как и где движок JavaScript может найти переменную. Ключевой характеристикой лексического контекста является то, что он определяется во время написания кода (при условии, что мы не используем eval () или with).
    - Динамическая область видимости, по понятным причинам, подразумевает, что существует модель, в которой область видимости может определяться динамически во время выполнения, а не статически во время создания.     

    Лексическая область - определяется во время написания кода, тогда как динамическая область (и this) - во время выполнения. Лексическая область заботится о том, где была объявлена функция, а динамическая область - о том, откуда была вызвана функция. И наконец: this заботится о том, как была вызвана функция. Это показывает нам, насколько тесно механизм this связан с идеей динамической области видимости.

9. Разница между var, let и const?

   * var -  Var-объявления могут обладать видимостью глобальной или локальной (область видимости в пределах функции).
    Переменная var является глобальной, когда объявлена вне какой-либо функции. Это означает, что любая переменная, объявленная через var вне блока функции, доступна для использования во всем окне.
    Var является локальной, когда объявлена внутри функции. Это означает, что она доступна и к ней можно обращаться только изнутри этой функции.
     - переменные var поднимаются в верхнюю часть своей области видимости и инициализируются со значением undefined.

   * let -  let имеет блочную область видимости. Блок — это фрагмент кода, ограниченный фигурными скобками {}. Всё, что находится внутри фигурных скобок, относится к блоку. Таким образом, переменная, объявленная в блоке через let, будет доступна только внутри этого блока. 

        Точно так же, как и в случае с var, переменные, объявленные через let, можно обновлять внутри их области видимости. Но, в отличие от var, let-переменные нельзя повторно объявить внутри области видимости. 

        Точно так же, как в случае с var, объявления через let перемещаются вверх. Но в отличие от var-переменных, которые инициализируются как undefined, ключевое слово для let не инициализируется. Так что если вы попытаетесь использовать переменную let до того, как она будет объявлена, то получите ошибку обращения к переменной ReferenceError.


    * const - Переменные, объявленные через const, сохраняют постоянные значения. Объявления через const имеют некоторое сходство с объявлениями через let.  
        - const имеет блочную область видимости. Точно как и в случае с let, переменные, объявленные через const, могут быть доступны только внутри того блока, где были объявлены.
        - Переменные const не могут быть ни обновлены, ни объявлены повторно. Это означает, что значение переменной, объявленной через const, остается неизменным внутри ее области видимости. Нельзя ни обновить его, ни объявить повторно. 
        - каждое объявление через const должно быть инициализировано в момент объявления. Это поведение несколько отличается, когда речь идет об объектах, объявленных через const. Пускай const-объект не может быть обновлен, свойства таких объектов обновлять можно. 
        - Точно так же, как и let, объявления через const перемещаются вверх, но не инициализируются.



    Так что на случай, если вы упустили суть отличий, то вот они вкратце:
    - Переменные, объявленные через var, могут быть глобальными или иметь область видимости в рамках функции; let и const имеют блочную область видимости.
    - var-переменные могут быть как обновлены, так и переопределены внутри области видимости; let-переменные можно обновлять, но не переопределять; const-переменные нельзя ни обновлять, ни переопределять.
    - Со всеми ними осуществляется поднятие наверх области видимости. Но если var-переменные при этом инициализируются как undefined, let и const не инициализируются.
    - В то время как var и let можно объявить, но не инициализировать, const необходимо инициализировать во время объявления.    

10. Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания. В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.

11. Что обозначает this в JavaScript?

    Свойство контекста выполнения кода (global, function или eval), которое в нестрогом режиме всегда является ссылкой на объект.В большинстве случаев значение this определяется тем, каким образом вызвана функция. Значение this не может быть установлено путём присваивания во время исполнения кода и может иметь разное значение при каждом вызове функции. В ES5 представлен метод bind(), который используется для привязки значения ключевого слова this независимо от того, как вызвана функция. Также в ES2015 представлены стрелочные функции, которые не создают собственные привязки к this (они сохраняют значение this лексического окружения, в котором были созданы).


12. Функции высшего порядка — это функции, которые работают с другими функциями, либо принимая их в виде параметров, либо возвращая их. Проще говоря, функцией высшего порядка называется такая функция, которая принимает функцию как аргумент или возвращает функцию в виде выходного значения.


13. Как превратить любой тип данных в булевый? Перечислите ложные значения в JS?

    Для явного преобразования к булевому значению, нужно применить функцию Boolean() или !!. Неявное преобразование происходит в логическом контексте if (val) { … } или при применении логических операторов (|| && !)

    Поскольку существует всего два возможных результата преобразования, легче просто запомнить список ложных значений:

        Boolean('')           // false
        Boolean(0)            // false     
        Boolean(-0)           // false
        Boolean(NaN)          // false
        Boolean(null)         // false
        Boolean(undefined)    // false
        Boolean(false)        // false


14. Методы строк в JavaScript? 

    - Как изменить регистр
        * toLowerCase - преобразует символы в строке в нижний регистр.

                "Hello Tproger".toLowerCase(); // "hello tproger"

        * toUpperCase - Преобразует символы в строке в верхний регистр.

                "Hello Tproger".toUpperCase(); // "HELLO TPROGER"

    - Как объединить строки
        * concat - Объединяет две или более строки и возвращает одну строку.

                "Hello".concat(" Tproger"); // "Hello Tproger"
                "Hello".concat(" T", "p", "r", "o", "g", "e", "r"); // "Hello Tproger"

    - Как разделить строку на подстроки
        * split - Разбивает строку в массив по указанному разделителю, которым может быть подстрока или регулярное выражение. Вторым параметром можно указать ограничитель.

                // Получаем каждый символ
                "Hello Tproger".split(""); // ["H", "e", "l", "l", "o", " ", "T", "p", "r", "o", "g", "e", "r"]

                // Получаем каждое слово из строки
                "Hello Tproger".split(" "); //["Hello", "Tproger"]

                // Устанавливаем ограничитель
                "Hello Tproger".split(" ", 1); //["Hello"]

    - Как повторить строку
        * repeat - Принимает в качестве параметра число и повторяет строку указанное количество раз.

                "Tproger ".repeat(3); // "Tproger Tproger Tproger "

    - Как найти подстроку
        * charAt - Возвращает символ по указанному индексу.

                "Hello Tproger".charAt(); // "H"

        * includes - Проверяет, содержит ли строка указанную подстроку. Возвращает значение true или false. Вторым параметром можно указать позицию в строке, с которой следует начать поиск.

                "Hello Tproger".includes("Tproger"); // true
                "Hello Tproger".includes("Hello", 1); // false

        * indexOf - Возвращает индекс первого найденного вхождения указанного значения. Поиск ведётся от начала до конца строки. Если совпадений нет, возвращает -1. Вторым параметром можно передать позицию, с которой следует начать поиск.

                "Hello World".indexOf("o"); // 4
                "Hello World".indexOf("o", 5); // 7

        * lastIndexOf - Возвращает индекс последнего найденного вхождения указанного значения. Поиск ведётся от конца к началу строки. Если совпадений нет, возвращает -1. Вторым параметром можно передать позицию, с которой следует начать поиск.

                "Hello World".lastIndexOf("o"); // 7
                "Hello World".lastIndexOf("o", 5); // 4

        * endsWith - Проверяет, заканчивается ли строка символами, заданными первым параметром. Возвращает true или false. Есть второй необязательный параметр — ограничитель по диапазону поиска. По умолчанию он равен длине строки.

                "Hello Tproger".endsWith("Tproger"); // true
                "Hello Tproger".endsWith("Tproger", 12); // false

        * startsWith - Проверяет, начинается ли строка с указанных символов. Возвращает true или false. Вторым параметром можно указать индекс, с которого следует начать проверку.

                "Hello Tproger".startsWith("Hello"); // true
                "Hello Tproger".startsWith("Hello", 1); // 
            
        * search - Проверяет, есть ли в строке указанное значение или регулярное выражение и возвращает индекс начала совпадения.

                "hi, hello, hey".search("hello"); // 4

    - Как извлечь подстроку
        * slice - Извлекает часть строки и возвращает новую строку. Обязательный параметр — начало извлечения. Вторым параметром можно установить границу (по умолчанию — до конца строки).

                "Методы строк на Tproger".slice(16); // "Tproger"
                "Методы строк на Tproger".slice(16, 21); // "Tprog"

                // Отрицательные значения тоже работают
                "Методы строк на Tproger".slice(-7); // "Tproger"
                "Методы строк на Tproger".slice(-7, -2); // "Tprog"

        * substring - Извлекает символы из строки между двумя указанными индексами. Второй индекс указывать не обязательно. В таком случае будут извлечены все символы от начала до конца строки. В отличие от slice, можно задавать start больше, чем end. Отрицательные значения не поддерживаются, они интерпретируются как 0.

                "Методы строк на Tproger".substring(5, 2); // "тод"

        * substr - Извлекает часть строки указанной длины. Первым параметром принимает стартовую позицию, вторым — длину. Значение первого параметра может быть отрицательным, тогда позиция определяется с конца строки.

                "Методы строк на Tproger".substr(7, 5); // "строк"
                "Методы строк на Tproger".substr(-7, 5); // "Tprog"

    - Как заменить подстроку
        * replace - Ищет в строке указанное значение или регулярное выражение и возвращает новую строку, в которой выполнена замена на второй параметр. Можно заменить найденные значения другой строкой или передать функцию для работы над совпадениями.

                "hi, hello, hi".replace("hi", "hey"); // "hey, hello, hi"
                "hi, hello, hi".replace(/hi/g, "hey"); // "hey, hello, hey"

        * replaceAll - Даёт такой же результат, как метод replace() с глобальным флагом g. Заменяет все найденные совпадения другой строкой или переданной функцией.

                "hi, hello, hi".replaceAll("hi", "hey"); // "hey, hello, hey"

    - Как добавить в строку пробелы или другие символы
        * padEnd - Добавляет в конце отступы, пока строка не достигнет длины, заданной первым параметром. Вторым параметром можно указать другой символ вместо пробела.

                "Hello Tproger".padEnd(20, "*"); // "Hello Tproger*******"

        * padStart - Добавляет в начале отступы, пока строка не достигнет длины, заданной первым параметром. Вторым параметром можно указать другой символ вместо пробела.

                "Hello Tproger".padStart(20, "*"); // "*******Hello Tproger"

    - Как удалить пробелы в строке
        * trim - Обрезает пробелы с обоих концов строки.

                "   Hello Tproger ".trim(); // "Hello Tproger"

        * trimEnd - Обрезает пробелы в конце строки

                "   Hello Tproger ".trimEnd(); // "   Hello Tproger"

        * trimStart - Обрезает пробелы в начале строки

                "   Hello Tproger ".trimStart(); // "Hello Tproger "


    - Как работать с Юникодом
        * charCodeAt - Возвращает числовое значение Юникода по указанному индексу. Обратите внимание: у букв в верхнем и нижнем регистрах разные коды.

                "T".charCodeAt() // 84
                "t".charCodeAt() // 116

        * fromCharCode - Преобразует числовые значения Юникода в читаемые символы.

                String.fromCharCode(72, 101, 108, 108, 111); // "Hello"

    Примечание: при работе с эмодзи, редкими математическими символами, иероглифами нужно помнить о суррогатных парах. Это символы, которые записываются двумя 16-битными словами. Длина таких строк — 2.

                '?'.length; // 2, редкий китайский иероглиф

    Суррогатные пары не учитывались при создании JS и методы строк charCodeAt / fromCharCode обрабатывают их некорректно. Правильно работают с суррогатными парами редкие методы String.fromCodePoint и str.codePointAt, которые появились в языке недавно.   


15. Методы массивов в JavaScript?

    1. some()

    Этот метод проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции. Он вернет значение true, если хотя бы один элемент совпадет с проверяемой функцией, и значение false — если нет.

            const myAwesomeArray = ["a", "b", "c", "d", "e"]

            myAwesomeArray.some(test => test === "d")
            //-------> Output : true

    2. reduce()

    Этот метод принимает функцию, которая имеет в качестве аргумента аккумулятор и значение. Он применяет функцию к аккумулятору и каждому значению массива, чтобы в результате вернуть только одно значение.

            const myAwesomeArray = [1, 2, 3, 4, 5]

            myAwesomeArray.reduce((total, value) => total * value)
            // 1 * 2 * 3 * 4 * 5
            //-------> Output = 120

    3. every()

    Этот метод проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции. Он вернет значение true, если каждый элемент совпадет с проверяемой функцией, и значение false — если нет.

            const myAwesomeArray = ["a", "b", "c", "d", "e"]

            myAwesomeArray.every(test => test === "d")
            //-------> Output : false

            const myAwesomeArray2 = ["a", "a", "a", "a", "a"]

            myAwesomeArray2.every(test => test === "a")
            //-------> Output : true

    4. map()

    Этот метод принимает функцию в качестве параметра и создает новый массив с результатом вызова указанной функции для каждого элемента массива. Он всегда будет возвращать одинаковое количество элементов.

            const myAwesomeArray = [5, 4, 3, 2, 1]
            myAwesomeArray.map(x => x * x)

            //-------> Output : 25
            //                  16
            //                  9
            //                  4
            //                  1


    5. flat()

    Этот метод принимает в качестве аргумента массив массивов и сглаживает вложенные массивы в массив верхнего уровня. Обратите внимание, что этот метод работает только для одного уровня.

            const myAwesomeArray = [[1, 2], [3, 4], 5]

            myAwesomeArray.flat()
            //-------> Output : [1, 2, 3, 4, 5]

    6. filter()

    Этот метод принимает функцию в качестве параметра и возвращает новый массив, содержащий все элементы массива, для которого функция фильтрации передавалась в качестве аргумента, и возвращает ее со значением true.

            const myAwesomeArray = [
            { id: 1, name: "john" },
            { id: 2, name: "Ali" },
            { id: 3, name: "Mass" },
            { id: 4, name: "Mass" },
            ]

            myAwesomeArray.filter(element => element.name === "Mass")
            //-------> Output : 0:{id: 3, name: "Mass"},
            //                  1:{id: 4, name: "Mass"}

    7. forEach()

    Этот метод применяет функцию к каждому элементу массива.

            const myAwesomeArray = [
            { id: 1, name: "john" },
            { id: 2, name: "Ali" },
            { id: 3, name: "Mass" },
            ]

            myAwesomeArray.forEach(element => console.log(element.name))
            //-------> Output : john
            //                  Ali
            //                  Mass

    8. findIndex()

    Этот метод принимает функцию в качестве параметра и в дальнейшем применяет ее к массиву. Он возвращает индекс найденного элемента, если элемент удовлетворяет условию проверяющей функции, переданной в качестве аргумента. Если не удовлетворяет, возвращается –1.

            const myAwesomeArray = [
            { id: 1, name: "john" },
            { id: 2, name: "Ali" },
            { id: 3, name: "Mass" },
            ]

            myAwesomeArray.findIndex(element => element.id === 3)
            //-------> Output : 2

            myAwesomeArray.findIndex(element => element.id === 7)
            //-------> Output : -1

    9. find()

    Этот метод принимает функцию в качестве аргумента и в дальнейшем применяет ее к массиву. Он возвращает значение элемента, найденного в массиве, если элемент удовлетворяет условию проверяющей функции. В противном случае оно возвращается со значением undefined.

            const myAwesomeArray = [
            { id: 1, name: "john" },
            { id: 2, name: "Ali" },
            { id: 3, name: "Mass" },
            ]

            myAwesomeArray.find(element => element.id === 3)
            //-------> Output : {id: 3, name: "Mass"}

            myAwesomeArray.find(element => element.id === 7)
            //-------> Output : undefined

    10. sort()

    Этот метод принимает функцию в качестве параметра. Он сортирует элементы массива и возвращает их.

            const myAwesomeArray = [5, 4, 3, 2, 1]

            // Sort from smallest to largest
            myAwesomeArray.sort((a, b) => a - b)
            //-------> Output : [1, 2, 3, 4, 5]

            // Sort from largest to smallest
            myAwesomeArray.sort((a, b) => b - a)
            //-------> Output : [5, 4, 3, 2, 1]

    11. concat()

    Этот метод объединяет два или более массива/значения и возвращает новый массив.

            const myAwesomeArray = [1, 2, 3, 4, 5]
            const myAwesomeArray2 = [10, 20, 30, 40, 50]
            myAwesomeArray.concat(myAwesomeArray2)
            //-------> Output : [1, 2, 3, 4, 5, 10, 20, 30, 40, 50]

    12. fill()

    Этот метод заполняет все элементы массива одинаковым значением, от начального индекса (по умолчанию 0) до конечного индекса (по умолчанию array.length).

            const myAwesomeArray = [1, 2, 3, 4, 5]

            // The first argument (0) is the value
            // The second argument (1) is the starting index
            // The third argument (3) is the ending index
            myAwesomeArray.fill(0, 1, 3)
            //-------> Output : [1, 0, 0, 4, 5]

    13. includes()

    Этот метод возвращает значение true, если массив содержит определенный элемент, и значение false — если нет.

            const myAwesomeArray = [1, 2, 3, 4, 5]

            myAwesomeArray.includes(3)
            //-------> Output : true

            myAwesomeArray.includes(8)
            //-------> Output : false

    14. reverse()

    Этот метод меняет порядок следования элементов в массиве на обратный. Первый элемент становится последним, а последний — первым.

            const myAwesomeArray = ["e", "d", "c", "b", "a"]

            myAwesomeArray.reverse()
            //-------> Output : ['a', 'b', 'c', 'd', 'e']

    15. flatMap()

    Этот метод применяет функцию к каждому элементу массива, а затем сглаживает результат в новый массив. Он объединяет метод flat() и метод map() в одну функцию.

            const myAwesomeArray = [[1], [2], [3], [4], [5]]

            myAwesomeArray.flatMap(arr => arr * 10)
            //-------> Output : [10, 20, 30, 40, 50]

            // With .flat() and .map()
            myAwesomeArray.flat().map(arr => arr * 10)
            //-------> Output : [10, 20, 30, 40, 50]

    16. push()
    17. pop()
    18. shift()
    19. unshift()
    20. join() 
        Метод Array.join() используется для объединения элементов массива в одну строку. Методу можно передать необязательный строковой аргумент, который будет использоваться для разделения элементов в строке. Если разделитель не задан, то при вызове метода символом-разделителем по умолчанию будет запятая.

                var a = ["Ветер","Дождь","Огонь"];
                var myVar1 = a.join();      //"Ветер,Дождь,Огонь"
                var myVar2 = a.join(", ");  //"Ветер, Дождь, Огонь"
                var myVar3 = a.join(" + "); //"Ветер + Дождь + Огонь"    

    21. slice()
        Метод Array.slice() используется для копирования указанного участка из массива и возвращает новый массив содержащий скопированные элементы. Исходный массив при этом не меняется.

        Синтаксис метода:

        имя_массива.slice(begin, end);
        Метод принимает два аргумента, которые определяют начало и конец возвращаемого участка массива. Метод копирует участок массива, начиная от begin до end, не включая end. Если указан только один аргумент, возвращаемый массив будет содержать все элементы от указанной позиции до конца массива. Можно использовать отрицательные индексы - они отсчитываются с конца массива.

                var arr = [1,2,3,4,5];
                arr.slice(0,3);   //Возвращает [1,2,3]
                arr.slice(3);     //Возвращает [4,5]
                arr.slice(1,-1);  //Возвращает [2,3,4]
                arr.slice(-3,-2); //Возвращает [3]   

    22. splice()
        Метод Array.splice() - это универсальный метод для работы с массивами. Он изменяет массив на месте, а не возвращает новый измененный массив, как это делают методы slice() и concat(). Метод splice может удалять элементы из массива, вставлять новые элементы, заменять элементы - по очереди и одновременно. Он возвращает массив, состоящий из удаленных элементов, если ни один из элементов не был удален, вернет пустой массив.

        Синтаксис метода:


                имя_массива.splice(index , кол-во, elem1, ..., elemN);

        Первый аргумент указывает индекс в массиве, с которого начинается вставка или удаление элементов. Второй аргумент задает количество элементов, которые должны быть удалены из массива начиная с индекса, указанного в первом аргументе, если второй аргумент равен 0, то элементы не будут удалены. Если второй аргумент опущен, удаляются все элементы массива начиная с указанного индекса до конца массива. При использовании отрицательного номера позиции, отсчет элементов будет с конца массива.

                var fruits = ["апельсины", "яблоки", "груши", "виноград"];
                
                var deleted = fruits.splice(2,2);  //возвращает ["груши", "виноград"]
                document.write(deleted);
                            
                var arr = [1,2,3,4,5,6,7,8];
                
                arr.splice(4);    //Возвращает [5,6,7,8]; массив стал: [1,2,3,4]
                arr.splice(1,2);  //Возвращает [2,3]; массив стал: [1,4]
                arr.splice(1,1);  //Возвращает [4]; массив стал: [1]

        Первые два аргумента метода splice() задают элементы массива, подлежащие удалению. За этими двумя аргументами может следовать любое количество дополнительных аргументов, задающих элементы, которые будут вставлены в массив, начиная с позиции, заданной первым аргументом.

                var fruits = ["апельсины", "яблоки"];
                
                fruits.splice(2,0, "арбузы");  //возвращает []
                document.write(fruits);  //стало ["апельсины", "яблоки", "арбузы"]
                            
                var arr = [1,2,3,4,5];
                
                arr.splice(2,0,'a','b'); //Возвращает []; стало [1,2,'a','b',3,4,5]
                arr.splice(2,2,[1,2]);   //Возвращает ['a','b']; стало [1,2,[1,2],3,4,5]

        Стоит обратить внимание, что в отличие от concat(), метод splice() не разбивает на отдельные элементы массивы, передаваемые в качестве аргументов. То есть, если методу передается массив для вставки, он вставляет сам массив, а не элементы этого массива.                        


16. Разница между .forEach и .map()?    

    Два наиболее часто используемых для итерации - Array.prototype.map() и Array.prototype.forEach(). Так в чем же разница?

    Определение
    - Метод map() создает новый массив с результатами вызова предоставленной функции для каждого элемента в массиве, который вызывается; 
    - Метод forEach() выполняет предоставленную функцию один раз для каждого элемента массива. 

    
    4 основных различия между forEach () и map ()

    1. Возвращаемое значение
    map() выделяет память и сохраняет значение return. forEach() выбрасывает значение return и всегда возвращает undefined.

            const myAwesomeArray = [1, 2, 3, 4, 5]
            myAwesomeArray.forEach(x => x * x)
            //>>>>>>>>>>>>>return value: undefined

            myAwesomeArray.map(x => x * x)
            //>>>>>>>>>>>>>return value: [1, 4, 9, 16, 25]


    2. Возможность привязывать другие методы
    Второе различие между этими методами: map() можно привязывать к другим методам -  reduce(), sort(), filter() и т.д. А вот forEach(), как вы можете догадаться, возвращается undefined.

            const myAwesomeArray = [1, 2, 3, 4, 5]
            myAwesomeArray.forEach(x => x * x).reduce((total, value) => total + value)
            //>>>>>>>>>>>>> Uncaught TypeError: Cannot read property 'reduce' of undefined

            myAwesomeArray.map(x => x * x).reduce((total, value) => total + value)
            //>>>>>>>>>>>>>return value: 55

    3. Изменчивость
    map() возвращает совершенно новый массив с преобразованными элементами и тем же количеством данных. В случае forEach(), даже если он вернется undefined, он изменит исходный массив с помощью callback. Поэтому что map() опирается на неизменность и forEach() является мутатором.

    4. Скорость исполнения
    Что касается производительности, они немного отличаются. Ну, это зависит от разных вещей, таких как компьютер, объем данных и т.д. Вы можете проверить это самостоятельно с помощью приведенного ниже примера или с помощью jsPerf, чтобы узнать, какой метод быстрее.

            const myAwesomeArray = [1, 2, 3, 4, 5]

            const startForEach = performance.now()
            myAwesomeArray.forEach(x => (x + x) * 10000000000)
            const endForEach = performance.now()
            console.log(`Speed [forEach]: ${endForEach - startForEach} miliseconds`)

            const startMap = performance.now()
            myAwesomeArray.map(x => (x + x) * 10000000000)
            const endMap = performance.now()
            console.log(`Speed [map]: ${endMap - startMap} miliseconds`)

    Во многих случаях forEach() медленнее map(). Результаты для различных ОС и браузеров могут отличаться.

    Вывод
    Выбор между map() и forEach() будет зависеть от варианта использования. Если вы планируете изменять, чередовать или использовать данные, лучше выбирать map(), поскольку он возвращает новый массив с преобразованными данными. Но, если вам не понадобится возвращаемый массив, не используйте map(), вместо этого используйте forEach() или даже цикл for.


17. Разница между .call(), .apply() и bind()?

    1.1 Function.prototype.apply()
    Метод apply () вызывает функцию с указанным значением this и параметрами, предоставленными в виде массива (или объекта, подобного массиву).

    Синтаксис

            func.apply(thisArg, [argsArray])

    1.2 Function.prototype.call()
    Метод call () вызывает функцию с указанным значением this и отдельно предоставленными параметрами (списком параметров).

    Синтаксис

            fun.call(thisArg, arg1, arg2, ...)

    1.3 Function.prototype.bind()
    Метод bind () создает новую функцию, при ее вызове устанавливает для своего ключевого слова this предоставленное значение, а при вызове новой функции предоставляет заданную последовательность параметров перед любыми предоставленными.

    Синтаксис

            fun.bind (thisArg, очередь или массив) ()

    2. Использование
    Использование этих трех методов очень похоже, привязка функции к контексту используется для изменения точки this в функции.

        2.1 Обычное письмо

                let me = {
                    name: "me",
                    sayHello: function (age) {
                            console.log("hello, I am", this.name + " " + age + " " + "years old")
                    }
                }
                let someone = {
                        name: "someone",
                }
                me.sayHello(24) // hello, I am me 24 years old

        2.2 Использование методов call и apply

                me.sayHello.apply(someone, [24]) // hello, I am someone 24 years old
                me.sayHello.call(someone, 24) // hello, I am someone 24 years old

        Результат тот же, call () и apply (), первый параметр должен привязать контекст, а следующие параметры должны быть переданы функции, которая вызывает метод. Разница в том, что при передаче параметров вызывающей функции apply () представляет собой массив, а параметры call () перечисляются один за другим.

        2.3 Использование bind ()
        
                me.sayHello.bind(someone, 24)() // hello, I am someone 24 years old
                me.sayHello.bind(someone, ([24])() // hello, I am someone 24 years old

        Параметры, передаваемые методом привязки вызывающей функции, могут быть перечислены один за другим или записаны в массив. Самая большая разница между методом bind и call и apply заключается в том, что первый возвращает функцию, которая связывает контекст, а последние два выполняют функцию напрямую. Следовательно, приведенный выше код также можно записать так:

                me.sayHello.bind(someone)(24) // hello, I am someone 24 years old
                me.sayHello.bind(someone)([24]) // hello, I am someone 24 years old

        Подведем итоги использования bind (): этот метод создает новую функцию, называемую функцией привязки. Функция привязки будет использовать первый параметр, переданный в bind (), при ее создании как this, а второй - в bind (). И следующие параметры плюс параметры функции привязки, когда она запущена, используются как параметры исходной функции для вызова исходной функции.

    3. Сценарии применения

            3.1 Найдите максимальное и минимальное значения в массиве

                    let arr = [1,2,3,89,46]
                    let max = Math.max.apply(null,arr)//89
                    let min = Math.min.apply(null,arr)//1
            
            3.2 Преобразование массива в массив

                    let trueArr = Array.prototype.slice.call(arrayLike)
            
            3.3 Добавление массива

                    let arr1 = [1,2,3]
                    let arr2 = [4,5,6]
                    let total = [].push.apply(arr1, arr2) //6
                    // arr1 [1, 2, 3, 4, 5, 6]
                    // arr2 [4,5,6]

            3.4 Определите тип переменной
                    
                    function isArray(obj){
                        return Object.prototype.toString.call(obj) == '[object Array]'
                    }
                    isArray([]) // true
                    isArray('dot') // false

            3.5 Используйте вызов и подайте заявку на наследование
                    
                    function Person(name,age){
                        // Здесь все указывает на экземпляр
                        this.name = name
                        this.age = age
                        this.sayAge = function(){
                            console.log(this.age)
                        }
                    }
                    function Female(){
                            Person.apply (this, arguments) // Здесь выполняются все методы родительского элемента, а затем наследуются
                    }
                    let dot = new Female('Dot',2)

            3.6 Использование прокси-сервера журнала console.log

                    function log(){
                    console.log.apply(console, arguments);
                    }
                    // Конечно, есть и более удобный let log = console.log ()

    4. Резюме
        - (1) Все три могут изменить объект this функции.
        - (2). Первый параметр из трех - это объект, на который он указывает. Если такого параметра нет, по умолчанию он будет указывать на глобальное окно.
        - (3). Все три параметра могут быть переданы, но apply представляет собой массив, а вызов передается по порядку.
        - (4) .bind возвращает соответствующую функцию, которую удобно вызывать позже; apply и call выполняются немедленно.


18. Почему в JS функции называют объектами первого класса?        

    Объектами первого класса в контексте конкретного языка программирования называются элементы, которые могут быть переданы как параметр, возвращены из функции или присвоены переменной. Другими словами, речь идёт обо всём, что может быть данными.

    Объектами первого класса может быть не только то, что мы привыкли именовать словом "данные", но и любая конструкция языка, например, функции. В JavaScript функции это объекты первого класса.


19. Как определить наличие свойства в объекте?

    Метод hasOwnProperty() возвращает логическое значение, указывающее, содержит ли объект указанное свойство.

    obj.hasOwnProperty(prop)

        o = new Object();
        o.prop = 'существует';

        function changeO() {
        o.newprop = o.prop;
        delete o.prop;
        }

        o.hasOwnProperty('prop');   // вернёт true
        changeO();
        o.hasOwnProperty('prop');   // вернёт false


        o = new Object();
        o.prop = 'существует';
        o.hasOwnProperty('prop');             // вернёт true
        o.hasOwnProperty('toString');         // вернёт false
        o.hasOwnProperty('hasOwnProperty');   // вернёт false


        x = {'key': 1};
        if ( x.hasOwnProperty('key') ) {
            //Do this
        }

20. Что такое IIFE?

    IIFE (Immediately Invoked Function Expression) это JavaScript функция, которая выполняется сразу же после того, как она была определена.

        (function () {
            statements
        })();

21. Что такое псевдомассив arguments? 

    Объект arguments — это подобный массиву объект, который содержит аргументы, переданные в функцию. arguments имеет свойство length, а элементы индексируются начиная с нуля. Но при это он не может обращаться к встроенным методам Array, таким как forEach() или map() 

        function func1(a, b, c) {
          console.log(arguments[0]);
          // expected output: 1

          console.log(arguments[1]);
          // expected output: 2

          console.log(arguments[2]);
          // expected output: 3
        }

        func1(1, 2, 3);  

    Объект arguments — это локальная переменная, доступная внутри любой (нестрелочной) функции. Объект arguments позволяет ссылаться на аргументы функции внутри неё. Он состоит из переданных в функцию аргументов, индексация начинается с 0. Например, если в функцию было передано 3 аргумента, обратиться к ним можно следующим образом:

        arguments[0]
        arguments[1]
        arguments[2]


    Аргументам может быть присвоено значение:

        arguments[1] = 'new value';
     
    Объект arguments не является Array. Он похож на массив, но не обладает ни одним из его свойств, кроме length. Например, у него нет метода pop. Однако он может быть преобразован в обычный массив:

        var args = Array.prototype.slice.call(arguments);
        var args = [].slice.call(arguments);

        // ES2015
        const args = Array.from(arguments);
        const args = [...arguments];   

22. Разница между host-объектами и нативными объектами?

    Встроенные объекты: String, Math, RegExp, Object, Function и т.д. - основные предопределенные объекты, всегда доступные в JavaScript. Определено в спецификации ECMAScript.

    Объекты хоста: объекты типа window, XmlHttpRequest, узлы DOM и т.д., которые предоставляются средой выполнения (браузером или Node). Они отличаются от встроенных объектов, потому что не все окружения будут иметь одни и те же объекты хоста. Если JavaScript работает за пределами браузера, например, на языке сценариев на стороне сервера, например, в Node.js, будут доступны разные объекты хоста.

23. Почему результат сравнения 2х объектов это false?

    Сравнение объекта истинно лишь в том случае, если оба операнда ссылаются на один и тот же объект в памяти  

24. Что такое прототипное наследование? Как создать объект без прототипа?

    Все объекты в JavaScript имеют свойство prototype, которое является ссылкой на другой объект. Когда происходит обращение к свойству объекта, и если свойство не найдено в этом объекте, то механизм JavaScript просматривает прототип объекта, затем прототип прототипа и т.д. До тех пор, пока не найдет определенное свойство на одном из прототипов или до тех пор, пока он не достигнет конца цепочки прототипов. Такое поведение имитирует классическое наследование, но на самом деле это скорее делегирование, чем наследование.

    Мы можем создавать объекты без прототипов с помощью Object. create(null) . Такие объекты можно использовать как «чистые словари», у них нет проблем с использованием строки "__proto__" в качестве ключа.

25. Почему расширение нативных JavaScript-объектов это плохая практика?

    Когда вы расширяете объект, вы меняете его поведение.

    Можно изменить поведение объекта, который будет использоваться только вашим собственным кодом. Но когда вы меняете поведение чего-то, что также используется другим кодом, есть риск, что вы сломаете этот другой код.

    Когда дело доходит до добавления методов к классам объектов и массивов в javascript, риск поломки очень высок из-за того, как работает javascript. 

    Если вам нужно настраиваемое поведение, гораздо лучше определить свой собственный класс (возможно, подкласс), а не изменять собственный. Так вы вообще ничего не сломаете.

    Возможность изменять способ работы класса без создания подклассов - важная особенность любого хорошего языка программирования, но ее следует использовать редко и с осторожностью.

26. Что такое NaN? Как определить, что значение равно NaN?

    NaN - специальное значение "не число", которое обычно говорит о том, что была выполнена бессмысленная операция. Результатом любой операции, в которой участвует NaN , будет NaN . NaN интересное значение, хотя оно обозначает "не число" — с точки зрения типов, оно является числом.
    Это возвращаемое значение в ситуациях, когда математические (Math) функции не срабатывают должным образом (например, при вызове Math.sqrt(-1)) или когда функция, пытающаяся считать число из строки, терпит неудачу по причине того, что в строке не число (parseInt('blabla')).

    NaN является неравным (посредством сравнения через ==, !=, ===, and !==) любому другому значению, включая другое значение NaN. Используйте Number.isNaN() или isNaN(), чтобы наиболее понятным образом определить является ли значение значением NaN. Или выполните само-сравнение: NaN, и только NaN, в результате такого сравнения будет неравным самому себе.

        NaN === NaN;        // false
        Number.NaN === NaN; // false
        isNaN(NaN);         // true
        isNaN(Number.NaN);  // true

    Тем не менее, обратите внимание на разницу между функцией isNaN() и методом Number.isNaN(): первая вернёт true, если значение в настоящий момент является NaN, или если оно станет NaN после того, как преобразуется в число, в то время как последний вернёт true, только если текущим значением является NaN:

        isNaN('hello world');        // true
        Number.isNaN('hello world'); // false  

27. Что такое объектная обертка (Wrapper Objects)?  

    Примитивы строка, число и boolean имеют свойства и методы, несмотря на то, что они не являются объектами:

        let name = 'marko'

        console.log(typeof name) // string
        console.log(name.toUpperCase()) // MARKO

    Name — это строка (примитивный тип), у которого нет свойств и методов, но когда мы вызываем метод toUpperCase(), это приводит не к ошибке, а к «MARKO».

    Причина такого поведения заключается в том, что name временно преобразуется в объект. У каждого примитива, кроме null и undefined, есть объект-обертка. Такими объектами являются String, Number, Boolean, Symbol и BigInt. В нашем случае код принимает следующий вид:

        console.log(new String(name).toUpperCase()) // MARKO

    Временный объект отбрасывается по завершении работы со свойством или методом.

28. Как в JavaScript создать объект?

    Объект – это один из типов данных в JavaScript, который предназначен для хранения коллекции различных значений и более сложных сущностей.

    Создавать объекты в JavaScript можно разными способами:
    - с использованием литерального синтаксиса;

        const person = {
          firstName: 'Александр',
          lastName: 'Мальцев',
          age: 28,
          getFullName: function () {
            return `${this.firstName} ${this.lastName}`
          }
        }

    - с помощью ключевого слова new и указания типа создаваемого объекта;

        // функция-конструктор Point
        function Point(x,y) {
          this.x = x;
          this.y = y;
        }
        // создание объекта point1 типа Point
        var point1 = new Point(10, 40);
        // создание объекта point2 типа Point
        var point2 = new Point(30, 30);


    - на основе прототипов ( Object. create() )

    Метод Object.create() позволяет создать новый объект с указанным прототипом.

        // создадим новый объект point2d;
        const point2d = {
          x: 5,
          y: 7
        }
        // создадим новый объект, прототипом которого будет point2d
        const point3d = Object.create(point2d);
        point3d.z = 8;

        // получим прототип объекта point3d
        console.log( Object.getPrototypeOf(point3d) ); // {x: 5, y: 7}

    Создание объекта с прототипом Object.prototype:

        const obj = Object.create(Object.prototype);
        // эквивалентно этому:
        // const obj = {};

    Создание объекта без прототипа:

        const obj = Object.create(null);

29. Как проверить, является ли значение массивом?

    Метод Array. isArray() возвращает true , если объект является массивом и false , если он массивом не является.

        const re = [1, 2, 3]
        Object.prototype.toString.call(re) === '[object Array]'

30. Для чего используется оператор % (остатка)?

    Чтобы получить остаток от деления мы можем воспользоваться оператором %

        console.log(20 % 3) // 2 (3 * 6 = 18)

    Как видно из примера, мы получим 2 — это и будет остаток от деления.

    Где такое может понадобиться? Как пример, если в цикле вы будете генерировать строки таблицы и каждую 3 строку вам нужно будет стилизовать:

        for (let i = 0; i < tableRows.length; i++) {
            ...
            // Если на данной итерации счетчик i делится на 3 без остатка (т.е. деление равно 0)
            // Тогда в этом условии мы можем сделать необходимые операции
            if (i % 3 === 0) {
                ...
            }
        }

    В данном примере показана каждая третья строка, но можно также сделать и с другим числом:

        if (i % 2 === 0) — каждая вторая строка
        if (i % 5 === 0) — каждая пятая строка
        if (i % 10 === 0) — каждая 10я строка и т.д.

    Другой пример, когда вам нужно проверить делимость числа например на 10 и 100 без остатка:

        if (num % 10 === 0 && num % 100 === 0) {...}

31. Как работает boxing/unboxing в JavaScript?

    JavaScript автоматически упаковывает примитивные типы в соответствующие объекты, когда встречает вызовы методов на них (и затем автоматически распаковывает). То есть в действительности, все методы которые мы вызываем на строках, хранятся в прототипе конструктора String. То же самое касается и всех остальных типов:

        // Ручная упаковка примитивных значений
        const number = new Number(1);
        number.toString(); // "1"
        const bool = new Boolean(true);
        bool.toString(); // "true"

        // Автоматическая упаковка
        const one = 1;
        // Во время вызова происходит упаковка
        one.toString(); // "1"
        // Обратите внимание что, такой код завершится с ошибкой:
        // 1.toString();
        // js ожидает, что после точки будет продолжение числа
        // А вот так заработает (1).toString();

        const yes = true;
        // Во время вызова происходит упаковка
        yes.toString(); // "true"

    Интересно то, как происходит распаковка. Для этого JavaScript автоматически вызывает метод valueOf() у объекта:

        const number = new Number(100);
        // Его можно вызвать самостоятельно
        number.valueOf(); // 100

        // А еще он вызывается в результате разных операций над объектом
        const newName = `${number} is a big number`; // "100 is a big number!"

    В отличие от упаковки, распаковка выполняется абсолютно для всех объектов. Это позволяет определять valueOf() самостоятельно:

        const words = ['Hello'];
        const helloBuilder = (string) => words.push(string);
        const build = () => words.join(' ');

        helloBuilder.valueOf = () => build();

        helloBuilder('from');
        helloBuilder('valueOf');

        console.log(helloBuilder == 'Hello from valueOf'); // true

32. Что такое мемоизация? Реализуйте базовую логику функции для мемоизации?

    Мемоизация — сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизации, применяемый для увеличения скорости выполнения компьютерных программ.

        // простая функция, прибавляющая 10 к переданному ей числу
        const add = (n) => (n + 10);
        add(9);

        // аналогичная функция с мемоизацией
        const memoizedAdd = () => {
          let cache = {};
          return (n) => {
            if (n in cache) {
              console.log('Fetching from cache');
              return cache[n];
            }
            else {
              console.log('Calculating result');
              let result = n + 10;
              cache[n] = result;
              return result;
            }
          }
        }

        // эту функцию возвратит memoizedAdd
        const newAdd = memoizedAdd();
        console.log(newAdd(9)); // вычислено
        console.log(newAdd(9)); // взято из кэша

33. Разница между оператором in и методом hasOwnProperty?

    - Оператор in возвращает значение true, если к свойству можно получить доступ через объект.
    - hasOwnProperty () возвращает значение true, только если свойство существует в экземпляре.

    Используйте оператор удаления, чтобы полностью удалить атрибуты экземпляра, что позволяет нам объединить и пересмотреть атрибуты в прототипе.

        function Person(){
        }
        Person.prototype.name = "Nicholas";
        Person.prototype.age = 29;
        Person.prototype.job = "Software Engineer";
        Person.prototype.sayName = function(){
            alert(this.name);
        };
 
        var person1 = new Person();
        var person2 = new Person();
        
        alert(person1.hasOwnProperty("name"));//false
        alert("name" in person1);//true
        
        person1.name = "Greg";
        alert(person1.name);//"Greg"
        alert(person1.hasOwnProperty("name"));//true
        alert("name" in person1);//true
        
        delete person1.name;
        alert(person1.name);//"Nicholas"
        alert(person1.hasOwnProperty("name"));//false
        alert("name" in person1);//true

34. Базовые структуры данных и их организация (массив, список, стек, очередь, дерево, хэш таблица и т. д.).

    Основные структуры данных.
    - Массивы
    - Стеки
    - Очереди
    - Связанные списки
    - Графы
    - Деревья
    - Префиксные деревья
    - Хэш таблицы

    * Массивы

    Массив — это самая простая и широко используемая структура данных. Другие структуры данных, такие как стеки и очереди, являются производными от массивов.
    Каждому элементу данных присваивается положительное числовое значение (индекс), который соответствует позиции элемента в массиве. Большинство языков определяют начальный индекс массива как 0.

    Бывают
    - Одномерные, как показано выше.
    - Многомерные, массивы внутри массивов.


    * Стеки

    Стек — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»).
    Примером стека может быть куча книг, расположенных в вертикальном порядке. Для того, чтобы получить книгу, которая где-то посередине, вам нужно будет удалить все книги, размещенные на ней. Так работает метод LIFO (Last In First Out). Функция «Отменить» в приложениях работает по LIFO.

    Основные операции
    - Push-вставляет элемент сверху
    - Pop-возвращает верхний элемент после удаления из стека
    - isEmpty-возвращает true, если стек пуст
    - Top-возвращает верхний элемент без удаления из стека


    * Очереди

    Подобно стекам, очередь — хранит элемент последовательным образом. Существенное отличие от стека – использование FIFO (First in First Out) вместо LIFO.
    Пример очереди – очередь людей. Последний занял последним и будешь, а первый первым ее и покинет.
    Изображение очереди, в четыре элемента (1, 2, 3 и 4), где 1 находится наверху и будет удален первым

    Основные операции
    Enqueue—) — вставляет элемент в конец очереди
    Dequeue () — удаляет элемент из начала очереди
    isEmpty () — возвращает значение true, если очередь пуста
    Top () — возвращает первый элемент очереди


    * Связанный список

    Связанный список – массив где каждый элемент является отдельным объектом и состоит из двух элементов – данных и ссылки на следующий узел.

    Принципиальным преимуществом перед массивом является структурная гибкость: порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.

    Бывают

    - Однонаправленный, каждый узел хранит адрес или ссылку на следующий узел в списке и последний узел имеет следующий адрес или ссылку как NULL.

        1->2->3->4->NULL

    - Двунаправленный, две ссылки, связанные с каждым узлом, одним из опорных пунктов на следующий узел и один к предыдущему узлу.

        NULL<-1<->2<->3->NULL

    - Круговой, все узлы соединяются, образуя круг. В конце нет NULL. Циклический связанный список может быть одно-или двукратным циклическим связанным списком.

        1->2->3->1

    Самое частое, линейный однонаправленный список. Пример – файловая система.

    Основные операции
    - InsertAtEnd — Вставка заданного элемента в конец списка
    - InsertAtHead — Вставка элемента в начало списка
    - Delete — удаляет заданный элемент из списка
    - DeleteAtHead — удаляет первый элемент списка
    - Search — возвращает заданный элемент из списка
    - isEmpty — возвращает True, если связанный список пуст


    * Графы

    Граф-это набор узлов (вершин), которые соединены друг с другом в виде сети ребрами (дугами).
    
    Бывают

    - Ориентированный, ребра являются направленными, т.е. существует только одно доступное направление между двумя связными вершинами.
    - Неориентированные, к каждому из ребер можно осуществлять переход в обоих направлениях.
    - Смешанные

    Встречаются в таких формах как
    - Матрица смежности
    - Список смежности

    Общие алгоритмы обхода графа

    - Поиск в ширину – обход по уровням
    - Поиск в глубину – обход по вершинам


    * Деревья

    Дерево-это иерархическая структура данных, состоящая из узлов (вершин) и ребер (дуг). Деревья по сути связанные графы без циклов.

    Древовидные структуры везде и всюду. Дерево скилов в играх знают все.

    Типы деревьев
    - N дерево
    - Сбалансированное дерево
    - Бинарное дерево
    - Дерево Бинарного Поиска
    - AVL дерево
    - 2-3-4 деревья

    Бинарное дерево самое распространенное.

    Бинарное дерево — это иерархическая структура данных, в которой каждый узел имеет значение (оно же является в данном случае и ключом) и ссылки на левого и правого потомка. Узел, находящийся на самом верхнем уровне (не являющийся чьим либо потомком) называется корнем. Узлы, не имеющие потомков (оба потомка которых равны NULL) называются листьями.

    Три способа обхода дерева

    - В прямом порядке (сверху вниз) — префиксная форма.
    - В симметричном порядке (слева направо) — инфиксная форма.
    - В обратном порядке (снизу вверх) — постфиксная форма.



        class Node {
            constructor(data) {
                this.data = data; // node value
                this.left = null;   // left node child reference
                this.right = null; // right node child reference
            }
        }

        class BinarySearchTree {
            constructor() {
                this.root = null; // корень bst
            }
        }

        insert(data) {
            let newNode = new Node(data);
            if (this.root === null) {
                this.root = newNode;
            } else {
                this.insertNode(this.root, newNode); // helper method below
            }
        }
        insertNode(node, newNode) {
            if (newNode.data < node.data) {
                if (node.left === null) {
                    node.left = newNode;
                } else {
                    this.insertNode(node.left, newNode);
                }
            } else {
                if (node.right === null) {
                    node.right = newNode;
                } else {
                    this.insertNode(node.right, newNode);
                }
            }
        }

    * Хэш таблицы

    Хэширование — это процесс, используемый для уникальной идентификации объектов и хранения каждого объекта в заранее рассчитанном уникальном индексе (ключе). 
    Хеширование — операция, которая преобразует любые входные данные в строку (реже число) фиксированной длины. Функция, реализующая алгоритм преобразования, называется "хеш-функцией", а результат называют "хешем" или "хеш-суммой". Наиболее известны CRC32, MD5 и SHA (много разновидностей).  

    Объект хранится в виде пары «ключ-значение», а коллекция таких элементов называется «словарем». Каждый объект можно найти с помощью этого ключа.

    По сути это массив, в котором ключ представлен в виде хеш-функции.

    Эффективность хеширования зависит от

    - Функции хеширования
    - Размера хэш-таблицы
    - Метода борьбы с коллизиями      

    Ассоциативный массив — абстрактный тип данных, с помощью которого хранятся пары ключ-значение. У него есть и другие названия: "словарь", "мап" (от слова map). В разных языках ему соответствуют разные типы данных. В JavaScript — это Object
    Ассоциативный массив, в отличие от обычного массива (называемого индексированным, так как значения в нем расположены по индексам), нельзя положить в память "как есть". У него нет индексов, которые бы могли определить порядок и простой способ добраться до значений. Для реализации ассоциативных массивов часто используют специальную структуру данных — хеш-таблицу. Она позволяет организовать данные ассоциативного массива удобным для хранения способом. Для этого хеш-таблица использует две вещи: индексированный массив и функцию для хеширования ключей. Обратите внимание, что хеш-таблица это не просто способ размещать данные в памяти, она включает в себя логику. 

    Коллизии
    Ключом в ассоциативном массиве может быть абсолютно любая строка (любой длины и содержания). Другими словами, множество всех возможных ключей — бесконечно. В свою очередь, результат работы хеш-функции — строка фиксированной длины, а значит множество всех выходных значений — конечно.

    Из этого факта следует, что не для всех входных данных найдётся уникальный хеш. На каком-то этапе возможно появление дублей (когда для разных значений получается один и тот же хеш). Такую ситуацию принято называть коллизией. Способов разрешения коллизий несколько, и каждому из них соответствует свой тип хеш-таблицы. 

    Путем наблюдений мы выяснили различия между хэш-таблицами и массивами:

    - хэш-таблицы, как правило, работают быстрее при поиске элементов; в массивах нужно перебрать все элементы, чтобы найти искомое, в то время как в хэш-таблице вы переходите непосредственно к местоположению элемента;
    - вставка элемента выполняется быстрее в хэш-таблицах, так как вы просто хешируете ключ и вставляете его; в массивах важно сначала переместить элементы, прежде чем вставлять еще один.

35. Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?   

    Есть два способа передачи и копирования: один по значению, а другой по ссылке. Когда вы копируете что-то по значению, это означает, что вы создаете новое отдельное и независимое значение, подобное оригиналу - глубокая копия( Deep Copy ).

    Но когда вы копируете что-то по ссылке, вы создаете просто псевдоним оригинала, а не новую или независимую копию - поверхностную копию( Shallow copy ).

    - Глубокое копирование
    Когда вы создаете глубокую копию, вы создаете идентичную копию исходного элемента с его свойствами.
    Оригинал и копия не связаны, что означает, если вы изменили свойства оригинала, это не повлияет на скопированный элемент и не изменит его.

    - Поверхностное копирование
    С другой стороны, когда вы создаете поверхностную копию, вы просто помещаете ссылку на оригинальный объект в другую переменную.
    Таким образом, когда вы меняете оригинал, это также повлияет и изменит скопированный, и то же самое, если вы изменили что-то в скопированном элементе, это же что-то изменится и в оригинале.


    Как создать глубокую копию
    Есть много способов копировать объекты, но какой из них является глубоким, а какой поверхностным?

    1. Примитивные типы
    Все элементы с примитивными типами, такими как числа, строки и логические значения, копируются "глубоко", что означает, что скопированный элемент и оригинал не связаны, и любые изменения не повлияют на исходный элемент.
    С другой стороны, объекты и массивы сохраняются только один раз во время их создания, и назначение переменной этого объекта или массива лишь создает указатель (ссылку) на это значение, поэтому изменение копии также повлияет на оригинальный объект или массив.

    2. Объекты
    Назначение исходного объекта новой переменной создает поверхностную копию, что означает, что копия - это просто ссылка на оригинальный объект, и любое изменение повлияет на них обоих.
      2.1 Оператор Spread
      Это также называется деструктуризацией, которая помогает распространить все свойства или элементы из массива или объекта в новый элемент, это создает глубокую копию, что означает, что изменение в копии не повлияет на оригинал.
      Метод не выполняет глубокой копии вложенных объектов или массивов в оригинальный объект.

      2.2 Object.assign
      Другой способ глубокого копирования объекта с помощью Object.assign (), который создает совершенно новую и отдельную копию.
      Метод не выполняет глубокой копии вложенных объектов или массивов в оригинальный объект.


      2.3 JSON.parse() и JSON.stringify()
      JSON.stringify() преобразует переданный элемент в строку с форматом JSON. Затем JSON.parse () преобразует его обратно в объект JavaScript, это позволяет выполнять глубокое клонирование и для вложенных объектов, чего не происходит с оператором Object.assign или Spread.


    3. Массивы
    Массивы также являются просто объектами, поэтому у них та же проблема с поверхностной копией, однако мы также можем глубоко копировать и массивы.

      3.1 Оператор Spread
      Оператор Spread также используются с массивами, поэтому мы можем избежать поверхностной копии, создавая новую копию, которая не связана с оригиналом.
      Метод не выполняет глубокой копии вложенных объектов или массивов в оригинальный массив.


      3.2 map, filter, reduce
      Эти методы помогают создать глубокую копию массива, возвращая новый массив, не связанный с оригиналом.

      Метод не выполняет глубокой копии вложенных объектов или массивов в оригинальный массив.


      3.3 JSON.parse() и JSON.stringify()
      Как и с объектами, этим методы также используется с массивами для создания глубокой копии. Данный способ, как и в случае с объектами, единственный из представленных позволяет выполнить полноценную глубокую копию массива, даже если последний содержит в себе другие объекты или массивы.




36.  Object.is() method determines whether two values are the same value.
     Two values are the same if one of the following holds:
     * both undefined;
     * both null;
     * both true or both false
     * both strings of the same length with the same characters in the same order
     * both the same object (meaning both values reference the same object in memory)
     * both numbers and
        - both +0
        - both -0
        - both NaN
        - or both non-zero and both not NaN and both have the same value     








