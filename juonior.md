- На что необходимо обратить внимание при разработке мультиязычных сайтов?

  * Используй атрибут lang в HTML.
  * Перенаправляй пользователей на версию сайта на их языке. Позволяйте быстро и без проблем изменить страну и язык.
  * Текст на картинках плохо поддается адаптации. Многие до сих пор помещают текст на картинки чтобы получить хорошо выглядящий несистемный шрифт на любом компьютере. Однако чтобы перевести текст картинкой, нужно иметь подготовленную картинку с каждой строкой текста для каждого языка. При большом количестве текста это быстро выйдет из под контроля.
  * Ограничение длины слов и предложений. Некоторый контент может быть длиннее при написании на другом языке. Будьте внимательны к макету и проверяйте поведение блоков при переполнении. Количество символов важно в таких элементах, как заголовки, лейблы и кнопки. Но не так важно в основном тексте или в блоке комментария.
  * Помните о восприятии цветов. В разных языках и культурах цвета имеют разное значение. Дизайн должен учитывать эти особенности.
  * Форматируете даты и валюты. Календарные даты иногда пишутся по-разному. Например, «Май 31, 2012» в Америке или «31 мая 2012» в большинстве стран Европы.
  * Не склеивайте переведенные строки. Не пишите что-то вроде "Сегодняшняя дата " + date. Эта фраза будет выглядеть коряво на языках с другим порядком слов. Вместо этого используйте параметры шаблона.
  * Разные направления чтения. В русском мы читаем слева направо, сверху вниз. В традиционном японском языке текст читается сверху вниз, справа налево.

- Что такое прогрессивная отрисовка?
  * Прогрессивный рендеринг — имя, данное технологиям, используемым для ускорения отрисовки страниц (в частности, уменьшение времени загрузки), чтобы показать пользователю контент как можно скорее.

  * До того, как широкополосный интернет распространился повсеместно, прогрессивный рендеринг встречался довольно часто. Но этот подход по прежнему полезен в современной разработке, поскольку все более популярным (и ненадежным) становится мобильный доступ в интернет.

  Примеры технологий:

  * Ленивая загрузка картинок. Картинки на странице не загружаются все разом. JavaScript подгрузит картинки тогда, когда пользователь доскроллит до той части страницы, на которой они расположены.
  * Приоритизация видимого контента. Только минимум CSS, контента, скриптов, необходимых для отрисовки той части страницы, которую пользователь увидит первой. Вы можете использовать отложенные скрипты или слушать события DOMContentLoaded или load, чтобы загрузить остальные ресурсы и контент.
  * Асинхронные фрагменты HTML. Отправка в браузер частей HTML-страницы, созданной на бэкенде.

- Объясни разницу между `<script>,<script async> и <script defer>`
  * `<script>` — отрисовка HTML блокируется, скрипт извлекается и выполняется немедленно, отрисовка HTML возобновляется после окончания выполнения скрипта.
  * `<script async>` — скрипт будет извлечен и обработан параллельно с отрисовкой HTML, его выполнение закончится как только это будет возможно (обычно до того, как закончилась отрисовка HTML). Используйте async тогда, когда скрипт не зависит от других скриптов на странице, например для аналитики.
  * `<script defer>` — скрипт будет извлечен параллельно с отрисовкой HTML, его выполнение произойдет после того, как вся страница будет загружена. Если таких скриптов несколько, то каждый из них будет исполнятся в том порядке, в котором они расположены в документе. Если скрипту нужен полностью распарсеный DOM, то атрибут defer обеспечит уверенность в том, что на момент отработки скрипта весь HTML отрисован. Нет особой разницы со скриптами, расположенными перед тегом `<body>`. Отложенный скрипт не должен содержать document.write.
- Какие существуют принципы семантической вёрстки?
  * Семантическая вёрстка — подход к разметке, который опирается не на содержание сайта, а на смысловое предназначение каждого блока и логическую структуру документа.

  * Почему семантика важна
    - Чтобы сделать сайт доступным. Зрячие пользователи могут без проблем с первого взгляда понять, где какая часть страницы находится — где заголовок, списки или изображения. Для незрячих или частично незрячих всё сложнее. Основной инструмент для просмотра сайтов не браузер, который отрисовывает страницу, а скринридер, который читает текст со страницы вслух.
    - Этот инструмент «зачитывает» содержимое страницы, и семантическая структура помогает ему лучше определять, какой сейчас блок, а пользователю понимать, о чём идёт речь. Таким образом семантическая разметка помогает большему количеству пользователей работать с вашим сайтом. Например, наличие заголовков помогает незрячим в навигации по странице. У скринридеров есть функция навигации по заголовкам, что ускоряет знакомство с информацией на сайте.
    - Чтобы сайт был выше в поисковиках. Поисковики не разглашают правила ранжирования, но известно, что наличие семантической разметки страниц помогает поисковым ботам лучше понимать, что находится на странице, и в зависимости от этого ранжировать сайты в поисковой выдаче.  
  * Основные семантические теги HTML
    - Среди «старых» тегов из ранних версий HTML тоже есть семантические — например, тег `<p>`, который обозначает параграф. При этом теги `<i>` или `<b>` не семантические, потому что они не добавляют смысла выделенному тексту, а просто определяют его внешний вид.
    - `<article>` Значение: независимая, отделяемая смысловая единица, например комментарий, твит, статья, виджет ВК и так далее. 
        - Особенности: желателен заголовок внутри.
        - Типовые ошибки: путают с тегами `<section>` и `<div>`.
    - `<section>` Значение: смысловой раздел документа. Неотделяемый, в отличие от `<article>`.
        - Особенности: желателен заголовок внутри.
        - Типовые ошибки: путают с тегами `<article>` и `<div>`.
    - `<aside>` Значение: побочный, косвенный для страницы контент.
        - Особенности: может иметь свой заголовок. Может встречаться несколько раз на странице.
        - Типовые ошибки: считать `<aside>` тегом для «боковой панели» и размечать этим тегом основной контент, который связан с окружающими его элементами.
    - `<nav>` Значение: навигационный раздел со ссылками на другие страницы или другие части страниц.
        - Особенности: используется для основной навигации, а не для всех групп ссылок. Основной является навигация или нет — на усмотрение верстальщика. Например, меню в подвале сайта можно не оборачивать в `<nav>`. В подвале обычно появляется краткий список ссылок (например, ссылка на главную, копирайт и условия) — это не является основной навигацией, семантически для такой информации предназначен `<footer>` сам по себе.
        - Типовые ошибки: многие считают, что в `<nav>` может быть только список навигационных ссылок, но согласно спецификации там может быть навигация в любой форме.
    - `<header>` Значение: вводная часть смыслового раздела или всего сайта, обычно содержит подсказки и навигацию. Чаще всего повторяется на всех страницах сайта.
        - Особенности: этих элементов может быть несколько на странице.
        - Типовые ошибки: использовать только как шапку сайта.
    - `<main>` Значение: основное, не повторяющееся на других страницах, содержание страницы.
        - Особенности: должен быть один на странице, исходя из определения.
        - Типовые ошибки: включать в этот тег то, что повторяется на других страницах (навигацию, копирайты и так далее).
    - `<footer>` Значение: заключительная часть смыслового раздела или всего сайта, обычно содержит информацию об авторах, список литературы, копирайт и так далее. Чаще всего повторяется на всех страницах сайта.
        - Особенности: этих элементов может быть несколько на странице. Тег `<footer>` не обязан находиться в конце раздела.
        - Типовые ошибки: использовать только как подвал сайта.
 
  * Как разметить страницу с точки зрения семантики
    - Процесс разметки можно разделить на несколько шагов с разной степенью детализации.
    - Крупные смысловые блоки на каждой странице сайта. Теги:` <header>, <main>, <footer>`.
    - Крупные смысловые разделы в блоках. Теги: `<nav>, <section>, <article>, <aside>`.
    - Заголовок всего документа и заголовки смысловых разделов. Теги: `<h1>-<h6>`.
    - Мелкие элементы в смысловых разделах. Списки, таблицы, демо-материалы, параграфы и переносы, формы, цитаты, контактная информация и прогресс.
    - Фразовые элементы. Изображения, ссылки, кнопки, видео, время и мелкие текстовые элементы.
    - Более подробно методика создания семантической разметки описана в навыке «Создание семантической разметки по макету» и профессиональных курсах HTML Academy.
  
  * Есть простые правила для выбора нужных тегов.
    - Получилось найти самый подходящий смысловой тег — использовать его.
    - Для потоковых контейнеров — `<div>`.
    - Для мелких фразовых элементов (слово или фраза) — `<span>`.
    - Правило для определения `<article>, <section> и <div>`:
      - Можете дать имя разделу и вынести этот раздел на другой сайт? — `<article>`
      - Можете дать имя разделу, но вынести на другой сайт не можете? — `<section>`
      - Не можете дать имя? Получается что-то наподобие «новости и фотогалерея» или «правая колонка»? — `<div>`
  
  * Не используйте семантические теги для красоты. А любое выделение, сдвиг или иные превращения текста можно выполнить с помощью CSS.

- Что такое #shadow-root в инспекторе HTML-страницы?
  Shadow root (теневой корневой элемент) — это фрагмент документа, который присоединяется к хост-элементу. Элемент обзаводится теневым DOM тогда, когда к нему присоединяют теневой корневой элемент. Для того, чтобы создать для некоего элемента теневой DOM, нужно воспользоваться командой вида element.attachShadow():

      var header = document.createElement('header');
      var shadowRoot = header.attachShadow({mode: 'open'});
      shadowRoot.appendChild(document.createElement('<p> Shadow DOM </p>');

- Назови популярные CSS-методологии и их различия
  * БЭМ (BEM, ru.bem.info/methodology). БЭМ расшифровывается как Блок-Элемент-Модификатор. Методология CSS-архитектуры, созданная в Yandex.
      - Цель методологии БЭМ «разрабатывать сайты, которые необходимо быстро запустить и долго поддерживать. Методология помогает создавать расширяемые и повторно используемые компоненты интерфейса.»
      - Основная концепция – легкая поддержка проектов со временем и повторное использование компонентов.
      - Главная стратегия БЭМ состоит в организации CSS-кода в повторно используемые модули с помощью умной системы именования. 
  * OOCSS ( github.com/stubbornella/oocss/wiki ) - Object Oriented CSS или объектно-ориентированный CSS 
      Как и было сказано в самом начале, методология OOCSS базируется на двух основных вещах:
        - Стили структуры
        - Стили оформления

      К структуре относится всё, что непосредственно влияет на расположение контента внутри. Пользователи обычно «не видят» эти стили — пока у элемента нет оформления, он просто будет представлен пустым блоком. 
      К стилям структуры можно отнести:
        - Высоту
        - Ширины
        - Внутренние и внешние отступы

      К стилям оформления относятся:
        - Фон
        - Шрифты
        - Тени и цвет границ.

  * SMACSS (smacss.com)
      - Масштабируемая и модульная архитектура CSS или SMACSS – методология веб-разработки для организации и написания CSS-кода. 
      - В ядре лежит способ разделения CSS-правил на категории. Базовые категории SMACSS:
        * Base – в эту категорию входят правила, которые определяют внешний вид элементов по умолчанию. Одиночные селекторы элементов, селекторы атрибутов, селекторы псевдоклассов, смежные селекторы и т.д. Например, html, body, a, a:hover и т.д.
        * Layout – категория для стилей, с помощью которых страница разделяется на секции.
        * Module – модули – это повторно используемые части дизайна, как в лего. Например, меню, диалоговые окна, поисковой блок и т.д.
        * State – к этой категории относятся стили внешнего вида макета или модулей в определенном состоянии (например, видимый, скрытый, раскрытый или закрытый) или в определенном виде (например, домашняя страница или внутренняя страница).
        * Theme – категория похожа на State, в нее входят стили, отвечающие за внешний вид макетов и модулей. Эта категория нужна не во всех проектах, но знать про нее необходимо.
      - Система именования SMACSS. Под категории, описанные сверху, SMACSS предлагает систему именования, помогающую с организацией кода и повышающую производительность команды разработчиков.
        * К правилам Layout, State и Module добавляется префикс с осмысленным именем или сокращением. Для правил Layout можно использовать префикс layout-, grid- или даже l-. Для правил State необходимо добавлять префикс состояния is-. Например, is-hidden, is-visible и т.д. Для модулей используйте сами имена компонентов, например, .menu, .dialog и т.д.
        * Например, для стилей диалогового окна можно использовать селекторы типа .dialog.is-open. Связанные элементы внутри модуля и вариации модуля должны использовать базовое имя модуля в качестве префикса. Старайтесь не использовать id, элементные селекторы и вложенные селекторы. Например, чтобы выбрать пункт меню в модуле menu, используйте что-то типа .menu-link или .menu-item, а не .menu li a.
        * В отличие от БЭМ, SMACSS не предписывает слишком строгое соглашение об именовании. Jonathan Snook дал четко понять: «… не думайте, что нужно жестко придерживаться этих правил. У вас есть соглашение, задокументируйте и придерживайтесь его.»

  * Atomic CSS (acss.io) - создать отдельные классы, отвечающие за одну инструкцию

- Как изменить цвет в svg-файле?
    * SVG (Scalable Vector Graphic) — масштабируемая векторная графика.
    1. Меняем цвет с помощью свойства fill
    2. Меняем цвет в файле style.css
    3. Изменяем цвет с помощью инлайновых стилей
- Что такое замыкание (closure) и какие существуют сценарии его использования?
  * Замыкание (англ. closure) в программировании — функция первого класса, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции в окружающем коде и не являющиеся её параметрами. Говоря другим языком, замыкание — функция, которая ссылается на свободные переменные в своей области видимости.
  * Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена.
- Что такое Event loop и как он работает? Можешь в подробностях рассказать про микро- и макрозадачи?
- С помощью чего в JS реализуются наследование? Классы в JavaScript поддерживают наследование с помощью ключевого слова extends
- Как объекты преобразовываются в примитивы?
- Как работает «сборщик мусора» в JS?
  * Основной концепцией управления памятью в JavaScript является принцип достижимости. Если упростить, то «достижимые» значения – это те, которые доступны или используются. Они гарантированно находятся в памяти.
    - Существует базовое множество достижимых значений, которые не могут быть удалены:
      * Выполняемая в данный момент функция, её локальные переменные и параметры.
      * Другие функции в текущей цепочке вложенных вызовов, их локальные переменные и параметры.
      * Глобальные переменные.
    - Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.
  * Внутренние алгоритмы
    Основной алгоритм сборки мусора называется «алгоритм пометок» (от англ. «mark-and-sweep»).
    Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:
      1. Сборщик мусора «помечает» (запоминает) все корневые объекты.
      2. Затем он идёт по ним и «помечает» все ссылки из них.
      3. Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
      4. …И так далее, пока не будут посещены все достижимые (из корней) ссылки.
      5. Все непомеченные объекты удаляются.

- Что такое полифил?
  * Полифил — это фрагмент кода (в сети — обычно JavaScript), который позволяет использовать современную функциональность в более старых браузерах, которые не поддерживают ее по умолчанию.
- Что такое webpack?
  * Вебпак — это сборщик модулей. Он анализирует модули приложения, создает граф зависимостей, затем собирает модули в правильном порядке в один или более бандл (bundle), на который может ссылаться файл «index.html».
- Что такое XSS (Cross-Site Scripting)?
  * XSS (англ. Cross-Site Scripting — «межсайтовый скриптинг») — довольно распространенная уязвимость. Ее суть довольно проста, злоумышленнику удается внедрить на страницу JavaScript-код, который не был предусмотрен разработчиками. Этот код будет выполняться каждый раз, когда жертвы (обычные пользователи) будут заходить на страницу приложения, куда этот код был добавлен. А дальше существует несколько сценариев развития.
    - Первый: злоумышленнику удастся заполучить авторизационные данные пользователя и войти в его аккаунт.  
    - Второй: злоумышленник может незаметно для жертвы перенаправить его на другую страницу-клон. Эта страница может выглядеть совершенно идентично той, на которой пользователь рассчитывал оказаться. Но вот принадлежать она будет злоумышленнику. Если пользователь не заметит подмены и на этой странице введет какие-то sensitive data, то есть личные данные, они окажутся у злоумышленника.
    - Специфика подобных атак заключается в том, что вредоносный код может использовать авторизацию пользователя в веб-системе для получения к ней расширенного доступа или для получения авторизационных данных пользователя. Вредоносный код может быть вставлен в страницу как через уязвимость в веб-сервере, так и через уязвимость на компьютере пользователя
- Приведи пример функции с мемоизацией. Когда необходимо использовать эту технику?
  * Мемоизация — сохранение результатов выполнения функций для предотвращения повторных вычислений. Это один из способов оптимизации, применяемый для увеличения скорости выполнения компьютерных программ.

        // простая функция, прибавляющая 10 к переданному ей числу
        const add = (n) => (n + 10);
        add(9);
        // аналогичная функция с мемоизацией
        const memoizedAdd = () => {
          let cache = {};
          return (n) => {
            if (n in cache) {
              console.log('Fetching from cache');
              return cache[n];
            }
            else {
              console.log('Calculating result');
              let result = n + 10;
              cache[n] = result;
              return result;
            }
          }
        }
        // эту функцию возвратит memoizedAdd
        const newAdd = memoizedAdd();
        console.log(newAdd(9)); // вычислено
        console.log(newAdd(9)); // взято из кэша


        // простая чистая функция, которая возвращает сумму аргумента и 10
        const add = (n) => (n + 10);
        console.log('Simple call', add(3));
        // простая функция, принимающая другую функцию и
        // возвращающая её же, но с мемоизацией
        const memoize = (fn) => {
          let cache = {};
          return (...args) => {
            let n = args[0];  // тут работаем с единственным аргументом
            if (n in cache) {
              console.log('Fetching from cache');
              return cache[n];
            }
            else {
              console.log('Calculating result');
              let result = fn(n);
              cache[n] = result;
              return result;
            }
          }
        }
        // создание функции с мемоизацией из чистой функции 'add'
        const memoizedAdd = memoize(add);
        console.log(memoizedAdd(3));  // вычислено
        console.log(memoizedAdd(3));  // взято из кэша
        console.log(memoizedAdd(4));  // вычислено
        console.log(memoizedAdd(4));  // взято из кэша

    * мемоизация рекурсивных функций 
    * Мемоизация — это разновидность кэширования.    
- Как подготовить сборник к деплою?

    * ng build --prod
    * Оптимизированная сборка включает в себя:
        - компиляцию в режиме AOT;
        - активацию режима prod (в момент запуска приложения по умолчанию вызывается метод enableProdMode());
        - объединение всех файлов в несколько больших (bundles);
        - минификацию и замену названий свойств и методов на более короткие;
        - удаление неиспользуемого кода.

    * В режиме prod приложение работает гораздо быстрее за счет отключения специфических для режима разработки проверок, например, за счет отключения двойного запуска механизма ChangeDetection.
    * Для настройки параметров, зависящих от режима запуска приложения (dev, test или prod), например, URL-адреса сервера, с которого запрашиваются данные, манипулируйте файлами в директории environments. 
    * Для уменьшения размера bundle-файлов можно использовать флаг --build-optimizer:


ng build --prod --build-optimizer    
- Зачем нужна forRoot-функция модуля?
- Что такое NgRx? Когда стоит использовать?
- Как работает Dependency injection?
- Как протестировать API-сервис?
- Что вы изучили вчера/на этой неделе?
- Что вас привлекает в программировании?
- С какой технической сложностью вы недавно столкнулись и как с ней справились?
- Какие методы для повышения производительности вы использовали при создании или обслуживании сайта?
- Можете ли вы описать некоторые методы SEO, которые вы использовали в последнее время?
- Можете ли вы объяснить общие принципы относительно фронтенд-безопасности или недавние проблемы, которые вы решили?
- Какие действия вы лично предприняли в недавних проектах для повышения удобства использования вашего кода?
- Расскажите о предпочитаемой среде разработки.
- С какими системами контроля версий вы знакомы?
- Можете ли вы описать порядок действий при создании новой веб-страницы?
- Если у вас есть 5 разных файлов со стилями, какой лучший способ интегрировать их в сайт?
- Можете ли вы описать разницу между прогрессивным улучшением и изящной деградацией?
- Как можно оптимизировать загрузку внешних ресурсов на странице?
- Сколько ресурсов браузер может одновременно загружать с одного домена?
- Какие есть исключения?
- Назовите три способа уменьшения времени загрузки страницы (воспринимаемого или реального).
- Если вы присоединились к проекту, где для форматирования используются табы, а вы привыкли использовать пробелы, как вы поступите?
- Опишите, как бы вы реализовали примитивное слайд-шоу.
- Если бы у вас была возможность освоить новую технологию в этом году, что бы это было?
- Объясните важность стандартов и комитетов по стандартам.
- Что такое FOUC (Flash Of Unstyled Content)? Как его избежать?
- Объясните, что такое ARIA и скринридеры, а также как сделать сайт доступным.
- Какие преимущества и недостатки у CSS и JavaScript анимаций?
- Что означает CORS и какую проблему решает?
 
[⬆] Вопросы по HTML:
- Для чего нужен doctype?
  * <!DOCTYPE> — это сокращение от «document type» (тип документа). Он объявляется в HTML для того, чтобы различать стандартный режим или режим совместимости (quirks mode). Его наличие говорит браузеру работать со страницей в стандартном режиме.
  * Мораль истории — просто добавляй `<!DOCTYPE html>` в начало страницы.

- Как следует оформлять страницу, содержимое которой может быть на разных языках?
- На что необходимо обратить внимание при разработке мультиязычных сайтов?
- Для чего нужны атрибуты, начинающиеся с data-?
  * До того, как JavaScript-фреймворки стали популярны, фронтенд-разработчики использовали data-атрибуты чтобы хранить дополнительные данные прямо в DOM без хаков вроде нестандартных атрибутов или дополнительных свойств в DOM. Атрибуты этого семейства предназначены для хранения частных данных пользователя, для которых не существует более подходящих атрибутов или элементов, на странице или в приложении.

  * На сегодняшний день использование data-атрибутов не поощряется. Одной из причин является то, что пользователь может модифицировать данные в атрибуте, используя инспектор кода в браузере. Данные лучше хранить в самом JavaScript и обновлять DOM при помощи связывания данных через библиотеку или фреймворк.
- Представьте HTML5 как открытую веб-платформу. Из каких блоков состоит HTML5?
  * Семантика. Позволяет более точно описать из чего состоит контент.
  * Связанность. Позволяет общаться с сервером новыми и инновационными способами.
  * Офлайн и хранилище. Позволяют страницам хранить данные локально на клиентской стороне и более эффективно работать в офлайне.
  * Мультимедиа. Ставит создание видео и аудио на первое место в вебе.
  * 2D- и 3D-графика и эффекты. Позволяет расширить возможности презентации.
  * Производительность и интеграция. Обеспечивает большую скорость оптимизации и лучшее использование аппаратных средств.
  * Доступ к устройствам. Позволяет взаимодействовать с различными устройствами ввода и вывода.
  * Стилизация. Позволяет создавать более сложные темы оформления.
- Объясните разницу между cookie, sessionStorage и localStorage.
  Все вышеупомянутые технологии являются механизмами хранения типа ключ-значение на клиентской стороне. Они могут хранить данные только как строки.

  * Cookie
    - Инициатор: клиент или сервер. Сервер может использовать заголовок Set-Cookie.
    - Срок хранения: устанавливается вручную.
    - Хранение между сессиями: зависит от установки срока хранения.
    - Связь с доменом: да.
    - Отправка на сервер с каждым HTTP-запросом: автоматически, с помощью заголовка Cookie.
    - Емкость, на один домен: 4 КБ.
    - Доступность: в любом окне.
  * Local Storage
    - Инициатор: клиент.
    - Срок хранения: всегда.
    - Хранение между сессиями: да.
    - Связь с доменом: нет.
    - Отправка на сервер с каждым HTTP-запросом: нет.
    - Емкость, на один домен: 5 МБ.
    - Доступность: в любом окне.
  * Session Storage
    - Инициатор: клиент.
    - Срок хранения: до закрытия вкладки.
    - Хранение между сессиями: нет.
    - Связь с доменом: нет.
    - Отправка на сервер с каждым HTTP-запросом: нет.
    - Емкость, на один домен: 5 МБ.
    - Доступность: в той же вкладке.

- Почему хорошей практикой считается располагать `<link>` для подключения CSS между `<head></head>`, а `<script>` для подключения JS ставить перед `</body>`? Знаете ли вы исключения?
  * Размещение `<link>` внутри `<head>`
    - Необходимость помещать теги `<link>` внутри шапки сайта описана в спецификации. Кроме того, размещение в верхней части разметки позволяет загружать страницу постепенно, что хорошо отражается на опыте использования. Проблема, возникающая при размещении таблиц стилей в нижней части страницы, заключается в том, что этот порядок препятствует прогрессивной загрузке страницы во многих браузерах. В том числе в Internet Explorer. Некоторые браузеры блокируют загрузку страницы, чтобы избежать перерисовки элемента, если его стили изменятся. Все это время пользователь будет пялиться на белый экран. Такое поведение браузеров предотвращает мерцание или отрисовку нестилизованых элементов.

  * Размещение `<script>` прямо перед `</body>`
    - Теги `<script>` блокируют отрисовку HTML на то время, пока они скачиваются и исполняются. Скачивание скриптов в конце позволяет сперва распарсить и показать пользователю весь HTML.
    - Исключением является случай, когда в вашем скрипте содержится `document.write()`. Но на сегодняшний день его использование не считается хорошей практикой. К тому же, расположение скриптов внизу разметки означает, что браузер не может начать их скачивать до тех пор, пока не отрисован весь документ. Единственным рабочим способом, при котором `<script>` будет расположен внутри `<head>`, является добавление атрибута defer.
- Что такое прогрессивная отрисовка?
- Для чего используется атрибут srcset в теге изображения? Опишите процесс, который использует браузер при оценке содержимого этого атрибута.
  * Вы должны использовать атрибут srcset, когда хотите показывать пользователям разные изображения в зависимости от их ширины дисплея их устройств - предоставление изображений более высокого качества устройствам с retina-дисплеями улучшает работу пользователя, в то время как предоставление изображений с низким разрешением на устройства с низким разрешением повышает производительность и уменьшает объём передаваемых данных (поскольку нет видимой разницы с большими изображениями). Например: `<img srcset="small.jpg 500w, medium.jpg 1000w, large.jpg 2000w" src="..." alt="">` указывает браузеру отображать малое, среднее или большое изображение в зависимости от разрешения дисплея пользователя. Первое значение - это имя изображения, а второе - ширина изображения в пикселях. Для ширины устройства 320px выполняются следующие расчеты:

      500 / 320 = 1.5625
      1000 / 320 = 3.125
      2000 / 320 = 6.25

  Если у клиента стандартное разрешение 1x, то 1.5625 является ближайшим коэффициентом, и 500w соответствующее small.jpg будет отображено в браузере.
  Если же разрешение retina (2x), браузер будет использовать ближайшее разрешение выше минимального. Это означает, что он не выберет 500w (1.5625), потому что оно больше 1 и изображение может выглядеть плохо. Браузер затем выберет изображение с результирующим соотношением ближе к 2, то есть 1000w (3.125).

  * srcset решает проблему, когда вы хотите показывать файлы изображений меньшего размера для устройств с узким экраном, поскольку они не нуждаются в больших изображениях, как на настольных дисплеях, - а также, при желании, вы можете показывать изображения с различным разрешением для экранов с высокой/низкой плотностью пикселей.
- Приходилось ли вам работать с языками HTML-шаблонизации?
  * Да, Pug (ранее известный как Jade), ERB, Slim, Handlebars, Jinja, Liquid и это только некоторые из них. По моему мнению, все они более или менее одинаковые и предоставляют одинаковые возможности экранирования контента и полезных фильтров для работы с отображаемыми данными. Большинство движков позволяют вводить собственные фильтры, если вам требуется дополнительная обработка контента перед его отображением.

[⬆] Вопросы по CSS:
- Что такое специфичность CSS-селекторов и как она работает?
- В чем разница между «сбросом» и «нормализацией» CSS? Что бы вы выбрали и почему?
- Объясните, что такое плавающие элементы (floats) и как они работают.
- Объясните, что такое z-index и как формируется контекст наложения.
- Объясните, что такое блочный контекст форматирования и как он работает.
- Какие вы знаете методы запрета обтекания (clearing) и в каких случаях они применяются?
- Как вы решаете стилевые проблемы, связанные с особенностями браузеров?
- Как вы обеспечиваете отображение страниц в браузерах с ограниченными возможностями?
- Какие приёмы/процессы вы при этом используете?
- Какими способами можно визуально скрыть элемент (оставив его доступным только для скринридера)?
- Использовали ли вы систему сеток, и если да, то какую вы предпочитаете?
- Приходилось ли вам использовать или реализовывать медиазапросы или вёрстку под мобильные устройства?
- Вы знакомы со стилизацией SVG?
- Можете ли вы привести пример свойства @media, отличного от screen?
- На что нужно обратить внимание при написании эффективного CSS?
- Какие преимущества/недостатки в использовании CSS препроцессоров?
- Опишите, что вам нравится и не нравится в CSS препроцессорах, которыми вы пользовались.
- Как вы реализуете макет, который использует нестандартные шрифты?
- Объясните, как браузер определяет, на какие элементы накладывать CSS стили?
- Объясните, что такое псевдоэлементы и для чего они нужны.
- Объясните своими словами, что такое блочная модель.
- Что делает * { box-sizing: border-box; }? В чем его преимущества?
- Что означает свойство display и можете ли вы привести несколько примеров его использования?
- В чем разница между строчным и блочно-строчным элементом?
- В чем разница между относительным, фиксированным, абсолютным и статически позиционированным элементом?
- Какими CSS-фреймворками вы пользовались? Что бы вы хотели в них изменить/улучшить?
- Пользовались ли вы Flexbox или Grid?
- Можете ли вы объяснить разницу между отзывчивым (responsive) сайтом и сайтом, сделанным по принципу mobile-first?
- Вы имеете опыт работы с ретиновой графикой? Если да, то какие методы вы использовали?
- В каком случае вы предпочтёте использовать translate() вместо абсолютного позиционирования и наоборот? И почему?

[⬆] Вопросы по JavaScript:
- Объясните делегирование событий.
- Объясните, как this работает в JavaScript.
- Расскажите, как работает прототипное наследование.
- Что вы думаете о AMD против CommonJS?
- Объясните, почему это не является IIFE: function foo(){ }();.
- Что необходимо изменить, чтобы это стало IIFE?
- В чём различие между переменными, значение которых: null, undefined и не объявлено?
- Как бы вы проверили их на каждое из этих значений?
- Что такое замыкание и как/для чего его используют?
- Можете ли вы описать основное различие между циклом forEach и циклом .map()? И в каких случаях каждый из них используется?
- В каких случаях обычно используются анонимные функции?
- Как вы организуете свой код? (module pattern, classical inheritance)
- В чем разница между host-объектами и нативными объектами?
- В чем разница между: function Person(){}, var person = Person(), и var person = new Person()?
- В чем разница между .call и .apply?
- Что делает и для чего нужна функция Function.prototype.bind?
- В чем разница между feature detection (определение возможностей браузера), feature inference (предположение возможностей) и анализом строки user-agent?
- Расскажите об Ajax как можно более подробно.
- Какие преимущества и недостатки в использовании Ajax?
- Объясните, как работает JSONP (и почему это не совсем AJAX).
- Вы когда-нибудь использовали шаблонизацию на JavaScript?
- Если да, то какие библиотеки вы использовали?
- Расскажите, что такое поднятие (hoisting).
- Объясните, что такое всплытие событий (event bubbling).
- В чём разница между «атрибутом» (attribute) и «свойством« (property)?
- Почему не следует расширять нативные JavaScript-объекты?
- В чём разница между событием document load и событием document DOMContentLoaded?
- В чём разница между == и ===?
- Объясните same-origin policy в контексте JavaScript.
- Сделайте так, чтобы этот код работал:

      duplicate([1,2,3,4,5]); // [1,2,3,4,5,1,2,3,4,5]

- Почему тернарный оператор так называется?
- Что делает строчка "use strict";? Какие достоинства и недостатки от ее использования?
- Напишите цикл, который перебирает числа до 100, возвращая “fizz” на числа кратные 3, “buzz” на числа кратные 5 и “fizzbuzz” на числа кратные 3 и 5
- Почему считается хорошим тоном оставить глобальную область видимости (global scope) в нетронутом состоянии?
- Для чего используют событие load? Есть ли у этого события недостатки? Знаете ли вы какие-либо альтернативы, и в каких случаях бы стали их использовать?
- Расскажите, что такое одностраничное приложение, и как сделать его SEO-оптимизированным.
- Насколько вы опытны в работе с промисами (promises) и/или их полифилами?
- Какие преимущества и недостатки при использовании промисов вместо колбэков (callbacks)?
- Каковы преимущества и недостатки написания JavaScript-кода на языке, который компилируется в JavaScript?
- Какие инструменты и методы вы используете при отладке кода?
- Какие языковые конструкции вы используете для итерации по свойствам объекта и элементам массива?
- Объясните разницу между изменяемыми (mutable) и неизменяемыми (immutable) объектами.
- Приведите пример неизменяемого объекта в JavaScript.
- Какие преимущества и недостатки у неизменяемости?
- Как вы можете достигнуть неизменяемости в вашем коде?
- Объясните разницу между синхронными и асинхронными функциями.
- Что такое цикл событий (event loop)?
- В чём разница между стеком вызовов (call stack) и очередью событий (task queue)?
- Объясните разницу при использовании foo в function foo() {} и var foo = function() {}
- В чём различие между переменными, созданными при помощи let, var и const?
- В чём разница между классом в ES6 и функцией-конструктором в ES5?
- Можете ли вы привести пример использования стрелочных функции =>? Чем они отличаются от других функций?
- Дайте определение функции высшего порядка.
- Можете ли вы привести пример деструктуризации объекта или массива?
- Шаблонные строки в ES6 намного упрощают создание строк, можете ли вы привести пример их использования?
- Можете ли вы привести пример каррированной функции (curry function) и в чём их преимущество?
- В чём преимущества использования spread оператора и чем он отличается от rest оператора?
- Каким образом можно обмениваться кодом между файлами?
- Для чего используются статические члены класса?

[⬆] Вопросы по тестированию:
- Какие преимущества/недостатки в тестировании собственного кода?
- Какие инструменты вы будете использовать для тестирования работоспособности своего кода?
- В чём различие между юнит-тестами и функциональными/интеграционными тестами?
- Для чего предназначены линтеры (code style linting tool)?

[⬆] Вопросы по производительности:
- Какие инструменты вы используете, чтобы найти недостатки в производительности вашего кода?
- Какие вы знаете способы улучшения производительности при скроллинге на вебсайте?
- Объясните разницу между раскладкой (layout), painting и композитингом (compositing).

[⬆] Вопросы по сетям:
- Почему лучше загружать ресурсы для сайта с нескольких доменов?
- Опишите весь процесс, начиная с ввода адреса сайта в адресную строку до окончания его загрузки на экране.
- В чём различия между Long-Polling, Websockets и Server-Sent Events?
- Опишите следующие заголовки HTTP-запросов и ответов:
- Разницу между Expires, Date, Age и If-Modified-…
- Do Not Track
- Cache-Control
- Transfer-Encoding
- ETag
- X-Frame-Options
- Что такое HTTP-методы? Перечислите все HTTP-методы, которые вы знаете, и объясните их.

[⬆] Примеры кода на JavaScript
- Вопрос: Чему равно foo?

      var foo = 10 + '20';

- Вопрос: Что выводит код ниже?

      console.log(0.1 + 0.2 == 0.3);

- Вопрос: Как сделать, чтобы это выражение работало?
 
      add(2, 5); // 7
      add(2)(5); // 7

- Вопрос: Какое значение возвращает данное выражение?
 
     "i'm a lasagna hog".split("").reverse().join("");

- Вопрос: Чему равно window.foo?
 
    ( window.foo || ( window.foo = "bar" ) );

- Вопрос: Что покажут эти два alert?
 
      var foo = "Hello";
      (function() {
      var bar = " World";
      alert(foo + bar);
      })();
      alert(foo + bar);

- Вопрос: Чему равно foo.length?
 
      var foo = [];
      foo.push(1);
      foo.push(2);

- Вопрос: Чему равно foo.x?
 
      var foo = {n: 1};
      var bar = foo;
      foo.x = foo = {n: 2};

- Вопрос: Что выводит код ниже?
 
      console.log('one');
      setTimeout(function() {
        console.log('two');
      }, 0);
      console.log('three');

- Вопрос: В чем разница между этими четырьмя промисами (promises)?
 
      doSomething().then(function () {
        return doSomethingElse();
      });
      
      doSomething().then(function () {
        doSomethingElse();
      });
      
      doSomething().then(doSomethingElse());
      
      doSomething().then(doSomethingElse);

[⬆] «Светская беседа»:
- Самое крутое, что вы когда-либо делали и чем гордитесь?
- Что вы больше всего любите в ваших инструментах разработки?
- Кто из фронтенд-сообщества вас вдохновляет?
- У вас есть какие-нибудь личные проекты? Какого рода?
- Какая ваша любимая “фишка” Internet Explorer?
- Какой кофе вы предпочитаете?